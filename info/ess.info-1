This is ess.info, produced by makeinfo version 4.0 from ess.texi.

START-INFO-DIR-ENTRY
* ESS: (ess). Emacs Speaks Statistics (S/S+/R, SAS, BUGS, Stata, XLisp-Stat).
END-INFO-DIR-ENTRY

ESS -- Emacs Speaks Statistics
******************************

   Currently maintained by A.J. (Tony) Rossini, Richard M. Heiberger,
Kurt Hornik, Martin Maechler, and Rodney A. Sparapani.

   This file documents `ESS', a GNU Emacs package for running
`S(plus)', `R', `XLisp-Stat', `SAS' and potentially any other
interactive `statistical' languages in an `inferior' buffer, editing
source code in these languages and interacting with the running program.

   This documentation relates to Version 5.1.21 of `ESS'.

   Original Info Author: David M. Smith (<D.M.Smith@lancaster.ac.uk>),
Department of Mathematics and Statistics, Lancaster University, UK.

   Current Info Author: A.J. Rossini
(<rossini@biostat.washington.edu>), Department of Biostatistics,
University of Washington, Seattle, WA 98185, USA


File: ess.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

ESS: Emacs Speaks Statistics
****************************

   ESS version 5.1.21

   (Documentation $Revision: 1.5 $ $Date: 2002/05/21 05:13:55 $).

     A.J. Rossini, R.M. Heiberger, K. Hornik, M. Maechler, and R.
     Sparapani (Formerly: Doug Bates, Ed Kademan, Frank Ritter and
     David Smith).

     A programming and inferior mode package for (X)Emacs intended for
     interacting with statistical software packages (primarily S(plus),
     R, XLisp-Stat, and SAS), for data analysis and statistical software
     development.

* Menu:

* Introduction::                Overview of features provided by this package
* Starting Up::                 Starting the ESS process
* Entering commands::           Interacting with the process buffer
* Editing::                     How to create or edit S objects or functions
* Help::                        Reading help files in ESS
* Transcript Mode::             Manipulating saved transcript files
* Miscellaneous::               Other features of ESS
* Bugs Etc::
* Help for Statistical Packages::
* Installation::                Installing ESS on your system
* Customization::               Customizing ESS
* Key Index::
* Command Index::
* Concept Index::
* Variable and command index::

 --- The Detailed Node Listing ---

Introduction to ESS

* Features::                    Why should I use ESS?
* New features::
* Credits::                     Authors of and contributors to ESS
* Latest version::              Getting the latest version of ESS
* Manual::                      How to read this manual

Starting the ESS process

* Multiple ESS processes::
* ESS processes on Remote Computers::
* Customizing startup::         Changing the startup actions

Interacting with the ESS process

* Command-line editing::        Entering commands and fixing mistakes
* Completion::                  Completion of object names
* Completion details::          Advanced completion concepts
* Transcript::                  Manipulating the transcript
* Command History::             Command History
* History expansion::           References to historical commands
* Hot keys::                    Hot keys for common commands
* Statistical Process running in ESS?::
* Other::                       Other commands provided by inferior-ESS

Manipulating the transcript

* Last command::                Manipulating the output from the last command
* Process buffer motion::       Viewing more historic commands
* Transcript resubmit::         Re-submitting commands from the transcript
* Saving transcripts::          Keeping a record of your S session

Editing S functions

* Edit buffer::                 Edit objects in a specialized buffer
* Loading::                     Loading source files into the ESS process
* Error Checking::              Detecting errors in source files
* Evaluating code::             Sending code to the ESS process
* Indenting::                   Indenting and formatting S code
* Other edit buffer commands::  Commands for motion, completion and more
* Source Files::                Maintaining S source files
* Source Directories::          Names and locations of dump files

Manipulating saved transcript files

* Resubmit::                    Resubmitting commands from the transcript file
* Clean::                       Cleaning transcript files

Other features of ESS

* Highlighting::                Syntactic highlighting of buffers
* Graphics::                    Using graphics with ESS
* Object Completion::

Using graphics with ESS

* printer::                     The printer() graphics driver
* X11::                         The X11() (and other X-windows based) driver

Bugs and Bug Reporting, Mailing Lists

* Bugs::
* Reporting Bugs::
* Mailing Lists::

Help for Statistical Packages

* Help for the S family::
* Help for SAS::

Help for the S family

* ESS(S)--Editing files::
* iESS(S)--Inferior ESS processes::
* Handling and Reusing Transcripts::
* ESS-help--assistance with viewing help::
* Philosophies for using ESS(S)::
* Scenarios for use (possibilities--based on actual usage)::
* Customization Examples and Solutions to Problems::

Help for SAS

* ESS(SAS)--Design philosophy::
* ESS(SAS)--Recommended autoexec::
* ESS(SAS)--Editing files::
* iESS(SAS)--Inferior ESS processes::
* ESS(SAS)--Batch processes::
* ESS(SAS)--Function keys for batch processing::
* ESS(SAS)--TAB key::
* ESS(SAS)--Usage scenarios::
* ESS(SAS)--Common problems::

Installing ESS on your system

* System dependent::            Other variables you may need to change

Customizing ESS

* Variables::                   Variables for customization
* Hooks::                       Customizing ESS with hooks
* Keybindings::                 Changing the default ESS keybindings

Variables for customization

* Variables for starting ESS::  Variables for starting ESS
* Dump file variables::         Variables for dump files
* Indentation variables::       Variables controlling indentation
* Variables controlling interaction::  Variables controlling interaction
					with the ESS process


File: ess.info,  Node: Introduction,  Next: Starting Up,  Prev: Top,  Up: Top

Introduction to ESS
*******************

   The S and Splus packages provide sophisticated statistical and
graphical routines for manipulating data.  S-mode, the package on which
ESS was based, provided a programming environment for data analysis and
statistical programming, as well as an intelligent interface to the S
process.

   The _ESS (:= Emacs Speaks Statistics)_ package is an extension of
S-mode to provide a common, generic, and useful interface, through
Emacs, to many statistical packages.  It has currently been extended
for R, XLisp-Stat, and SAS, with other statistical languages such as
Stata, SPSS, and Fiasco slated for implementations in the future.

   A bit of notation before we begin.  _Emacs_ refers to both _Emacs_
as distributed by the Free Software Foundation, as well as _XEmacs_,
which is a second GNU version of Emacs.  The Emacs major mode
`ESS[language]' which is used for editing source for dialect
`language', can take values `S', `SAS', or `XLS', for instance.  The
inferior process interface (the connection between Emacs and the
running process) referred to as interactive ESS (`iESS'), is denoted in
the modeline by `ESS[dialect]', where `dialect' can take values `S3',
`S4', `S+3', `S+4', `S+5', `S+6', `R', `XLS', `VST', `SAS', as well as
others.

   Currently, the documentation contains many references to ``S'' where
actually any supported (statistics) language is meant, i.e., `S' could
also mean `XLisp-Stat' or `SAS'.

   For exclusively interactive users of S, ESS provides a number of
features to make life easier.  There is an easy to use command history
mechanism, including a quick prefix-search history.  To reduce typing,
command-line completion is provided for all S objects and "hot keys"
are provided for common S function calls.  Help files are easily
accessible, and a paging mechanism is provided to view them.  Finally,
an incidental (but very useful) side-effect of ESS is that a transcript
of your session is kept for later saving or editing.

   No special knowledge of Emacs is necessary when using S
interactively under ESS.

   For those that use S in the typical edit-test-revise cycle when
programming S functions, ESS provides for editing of S functions in
Emacs edit buffers.  Unlike the typical use of S where the editor is
restarted every time an object is edited, ESS uses the current Emacs
session for editing.  In practical terms, this means that you can edit
more than one function at once, and that the ESS process is still
available for use while editing.  Error checking is performed on
functions loaded back into S, and a mechanism to jump directly to the
error is provided.  ESS also provides for maintaining text versions of
your S functions in specified source directories.

* Menu:

* Features::                    Why should I use ESS?
* New features::
* Credits::                     Authors of and contributors to ESS
* Latest version::              Getting the latest version of ESS
* Manual::                      How to read this manual


File: ess.info,  Node: Features,  Next: New features,  Prev: Introduction,  Up: Introduction

Why should I use ESS?
=====================

   S is a powerful system for manipulating and analyzing data, but its
user interface -- particularly on Unix platforms -- leaves something to
be desired.  ESS is a package which is designed to make S easier to use.

   ESS provides several features which make it easier to interact with
the ESS process (i.e. enter commands and view the output).  These
include:

   * Command-line editing for fixing mistakes in commands before they
     are entered.  The `-e' flag for S-plus provides something similar
     to this, but here you have the full range of Emacs commands rather
     than a limited subset.  However, other packages such as XLisp-Stat
     and S3 do not necessarily have features like this built-in.  *Note
     Command-line editing::.

   * Searchable command history for recalling previously-submitted
     commands.  This provides all the features of the `Splus -e' history
     mechanism, plus added features such as history searching.  *Note
     Command History::.

   * Command-line completion of both object and file names for quick
     entry.  This is similar to `tcsh''s facility for filenames; here it
     also applies to object names and list components.  *Note
     Completion::.

   * Hot-keys for quick entry of commonly-used commands in `S' such as
     `objects()' and `search()'.  *Note Hot keys::.

   * Transcript recording for a complete record of all the actions in an
     S session.  *Note Transcript::.

   * Interface to the help system, with a specialized mode for viewing S
     help files.  *Note Help::.


   If you commonly create or modify S functions, you will have found
the standard facilities for this (the `fix()' function, for example)
severely limiting.  Using S's standard features, one can only edit one
function at a time, and you can't continue to use S while editing.  ESS
corrects these problems by introducing the following features:

   * Object editing.  ESS allows you to edit more than one function
     simultaneously in dedicated Emacs buffers.  The ESS process may
     continue to be used while functions are being edited.  *Note Edit
     buffer::.

   * A specialized editing mode for S code, which provides syntactic
     indentation and highlighting.  *Note Indenting::.

   * Facilities for loading and error-checking source files, including a
     keystroke to jump straight to the position of an error in a source
     file.  *Note Error Checking::.

   * Source code revision maintenance, which allows you to keep historic
     versions of S source files.  *Note Source Files::.

   * Facilities for evaluating S code such as portions of source files,
     or line-by-line evaluation of files (useful for debugging).  *Note
     Evaluating code::.

   Finally, ESS provides features for re-submitting commands from saved
transcript files, including:

   * Evaluation of previously entered commands, stripping away
     unnecessary prompts.  *Note Transcript resubmit::.



File: ess.info,  Node: New features,  Next: Credits,  Prev: Features,  Up: Introduction

New features in ESS
===================

   Changes/New Features in 5.1.21:
   * ESS[SAS]: info documentation now available!, see ESS->Help for
     Statistical Packages->Help for SAS; F12 opens GSASFILE nearest
     point for viewing either within emacs, when available, or via an
     external viewer; more syntax highlighting keywords; more
     enhancements for remote SAS batch jobs with Kermit; new framework
     for remote SAS interactive jobs, see ess-remote

   * ESS[S]: info documentation now available!, see ESS->Help for
     Statistical Packages->Help for the S family

   * Makefile: tag now independent of rel; info files made by
     doc/Makefile and installed in new info sub-directory

   Changes/New Features in 5.1.20:
   * New `options()$STERM' in the S dialects (S, S-Plus, R).  The S
     program can determine the environment in which it is currently
     running.  ESS sets the option to `iESS' or `ddeESS' when it starts
     an S language process.  We recommend other specific values for S
     language processes that ESS does not start.

   * New `ess-mouse-me' function, assigned to S-mouse-3 by default.
     User may click on a word or region and then choose from the menu
     to display the item, or a summary, or a plot, etc.  This feature
     is still under development.

   * GNU Emacs 21.1 is now supported (fixed for S dialects, SAS & BUGS),
     (some from Stephen Eglen).

   * XEmacs 21.x is now supported (fixed w32-using-nt bug)

   * XEmacs on Win (NT) is better supported.

   * Workaround for bug in Sqpe+6 (S-PLUS 6 for Win).

   * should now work even when imenu is not available (for old
     Xemacsen).

   * ESS[SAS]: XEmacs-Imenu fix; C-TAB is globalized along with your
     function-key definitions, if specified; you can specify your SAS
     library definitions outside of autoexec.sas for ess-sas-data-view
     with SAS code placed in the variable ess-sas-data-view-libname,
     also the dataset name is defaulted to the nearest permanent dataset
     to point; Speedbar support now works for permanent datasets, please
     ignore first./last.; new font-locking is now the default with more
     improvements for font-locking PROCs, macro statements, * ; and %* ;
     comments; you can toggle sas-log-mode with F10 which will font-lock
     your .log (if it isn't too big); submit remote .sas files accessed
     with ange-ftp, EFS or Tramp (Kermit is experimental) by setting
     ess-sas-submit-method to 'sh; ess-sas-submit-command and
     ess-sas-submit-command-options are buffer-local so you can have
     local file variable sections at the end of your .sas files to
     request different executables or specify special options and the
     local file variables are re-read at submit instead of only at file
     open so that if you make a change it is picked up immediately;

   * ESS[BUGS]: font-lock with `in' fixed.

   * for STATA: font-lock bug fixed.

   * for Rd mode: C-c C-v and `switch-process' in menu.  further, C-c
     C-f prefix (Rd-font) for inserting or surrounding a word by things
     such as \code{.}, \code{\link{.}}, \emph{.} etc.

   * new functions (ess-directory-function) and (ess-narrow-to-defun)
     ess-directory <-> default-directory logic (Jeff Mincy).

   * Re-organized Makefile and fixed a few bugs.

   Changes/New Features in 5.1.19:
   * S+6 now supported (Tony Rossini (Unix) and Rich Heiberger
     (Windows))

   * New BUGS support through ESS[BUGS] mode (Rodney Sparapani)
     Templates assist you in writing .bug and .cmd code (.cmd and .log
     are replaced by .bmd and .bog to avoid emacs extension collisions).
     Substitution" parameters facilitate "automagic" generation of
     data...in" and "init...in" filenames, "const N=" from your data
     file and "monitor()/stats()" commands.  Activated by pressing F12.

   * Fixes for `ess-smart-underscore' SAS breakage (Rich Heiberger)

   * You can change between PC and Unix, local and global SAS
     function-key definitions interactively (Rich Heiberger)

   * C-Submit a highlighted region to SAS batch (Rodney Sparapani)

   * New and improved SAS syntax highlighting (Rodney Sparapani) To get
     the new functionality, set ess-sas-run-make-regexp to nil.  Also
     available in .log files via F10.

   * Open a permanent SAS dataset for viewing via F9 (Rodney Sparapani)
     You must have the library defined in autoexec.sas for it to work.

   * User-friendly defaults for `sas-program',
     `ess-sas-batch-pre-command' and `ess-sas-batch-post-command' as
     well Customize support for these and other ESS[SAS] variables
     (Rodney Sparapani)

   * `ess-sas-suffix-2' now defaults to .dat via F11 (Rodney Sparapani)

   * Emacs/XEmacs, Unix/Windows issues collectively handled in
     ess-emcs.el

   * defadvice solves problem of missing *ESS* (thanks to Jeff Mincy)

   * Improved manual a bit by including things that were only in
     `README'.

   Changes/New Features in 5.1.18:
   * New `ess-smart-underscore' function, now assigned to "_" by
     default.  Inserts `ess-S-assign' (customizable " <- "), unless
     inside string and comments where plain "_" is used instead. (MM)

   * Fixes for longstanding interactive SAS breakage (RMH)

   Changes/New Features in 5.1.17:
   * Documentation for Windows Installation (Rich Heiberger
     (<rmh@surfer.stat.temple.edu>))

   * removal of ess-vars, finalization of customize support (in the
     sense that there is no more use of ess-vars, but that we need to
     fix ess-cust) (AJ Rossini (<rossini@u.washington.edu>))

   * Many small (and large) fixes/contributions (MMaechler,
     (<maechler@stat.math.ethz.ch>)).

   * addition of the "S-equal" variable and provide M-x ess-add-MM-keys
     a way to remap "_" to `ess-S-assign', typically " <- ", but
     customizable. (MMaechler, (<maechler@stat.math.ethz.ch>)).

   Changes/New Features in 5.1.16:
   * BUG FIXES

   * Better SAS support

   Changes/New Features in 5.1.15:
   * BUG FIXES

   Changes/New Features in 5.1.14:
   * Yet more fixes to SAS mode, (Rich Heiberger
     (<rmh@surfer.stat.temple.edu>) and Rodney Sparapani
     <rsparapa@mcw.edu>)).

   * Customize support (for most Emacsen which support it) (AJRossini,
     (<rossini@biostat.washington.edu>)

   * ARC and ViSta support out of the box, and fixes for XLispStat
     (AJRossini, <rossini@biostat.washington.edu>)

   Changes/New Features in 5.1.13:
   * Version numbering finally all depending on the ./VERSION file,
     thanks to Martin Maechler.

   * Yet more fixes to SAS mode, thanks to Rich Heiberger
     (<rmh@surfer.stat.temple.edu>).

   Changes/New Features in 5.1.12:
   * Splus 5.1 stabilized, thanks to Martin Maechler, Bill Venables,
     Chuck Taylor, and others.

   * More fixes to SAS mode, thanks to Rodney Sparapani
     (<rsparapa@mcw.edu>) and Rich Heiberger
     (<rmh@surfer.stat.temple.edu>).

   Changes/New Features in 5.1.11:
   * More fixes to Stata mode, thanks to Brendan Halpin
     (<brendan@essex.ac.uk>)

   * fixed bugs in ESS-elsewhere, thanks to many testers

   * README.SPLUS4WIN has DETAILED instructions for S-PLUS 2000, thanks
     to David Brahm (<brahm@alum.mit.edu>).

   * Fixes to SAS mode, thanks to Rodney Sparapani (<rsparapa@mcw.edu>)

   Changes/New Features in 5.1.10:
   * More fixes to Stata mode

   * primitive generic version of ESS-elsewhere

   * Small fixes to SAS/Stata.

   Changes/New Features in 5.1.9:
   * Stata mode works

   * Literate Data Analysis using Noweb works

   Changes/New Features in 5.1.8:
   * Bug fixes

   * R documentation mode defaults changed

   Changes/New Features in 5.1.2:
   * able to use inferior iESS mode to communicate directly with a
     running S-Plus 4.x process using the Microsoft DDE protocol.  We
     use the familiar (from Unix ESS) C-c C-n and related key sequences
     to send lines from the S-mode file to the inferior S process.  We
     continue to edit S input files in ESS[S] mode and transcripts of
     previous S sessions in ESS Transcript mode.  All three modes know
     the S language, syntax, and indentation patterns and provide the
     syntactic highlighting that eases the programming tasks.


File: ess.info,  Node: Credits,  Next: Latest version,  Prev: New features,  Up: Introduction

Authors of and contributors to ESS
==================================

   ESS is based on Olin Shivers' excellent comint package (which is
supplied with version 19 of GNU Emacs).  The original version of ESS
(then known as `S-mode') was written by Doug Bates
(<bates@stat.wisc.edu>) and Ed Kademan (<kademan@stat.wisc.edu>).
Frank Ritter (<ritter@psy.cmu.edu>) then merged this version with his
own S-mode mode to form `S.el' version 2.1.

   Version 2.1 of `S.el' was then updated and expanded by David Smith
to form version 3.4.  This was then updated for Emacs 19 to create
version 4.  Most bugs have now been fixed (and several new ones
introduced) and many new features have been added.  Thanks must go to
the many people who have helped with the development of the present
version of ESS:

   * The multiple process code, and the idea for
     `ess-eval-line-and-next-line' are by Rod Ball.

   * Thanks to Doug Bates for many useful suggestions.

   * Thanks to Martin Maechler for reporting and fixing bugs, providing
     many useful comments and suggestions, and for maintaining the
     S-mode mailing list.

   * Thanks to Frank Ritter for updates from the previous version, the
     menu code, and invaluable comments on the manual.

   * Thanks to Ken'ichi Shibayama for his excellent indenting code, and
     many comments and suggestions.

   * Last but definitely not least, thanks to the many beta testers of
     the S-mode and ESS mailing lists.

   The new version, _ESS_ version 5, is being developed and currently
maintained by

   * A.J. Rossini (http://www.biostat.washington.edu/~rossini/)
     <rossini@u.washington.edu>

   * Richard M. Heiberger
     (http://www.sbm.temple.edu/departments/statistics/)
     <rmh@surfer.sbm.temple.edu>

   * Kurt Hornik (http://www.ci.tuwien.ac.at/~hornik)
     <hornik@ci.tuwien.ac.at>

   * Martin Maechler (http://stat.ethz.ch/~maechler/)
     <maechler@stat.math.ethz.ch>

   * Rodney Sparapani (http://www.mcw.edu/pcor/rsparapa)
     <rsparapa@mcw.edu>


File: ess.info,  Node: Latest version,  Next: Manual,  Prev: Credits,  Up: Introduction

Getting the latest version of ESS
=================================

   The latest stable version of ESS is always available on the web at:
ESS web page (http://software.biostat.washington.edu/ess/) or StatLib
(http://lib.stat.cmu.edu/general/ESS/)

   The latest (no more than 24 hours behind the developers) version of
ESS can also be retrieved using anonymous cvs:

   You need a cvs client (that works with your firewall, if any)

   the repository name is
`:pserver:anoncvs@software.biostat.washington.edu:/var/anoncvs'

   using a command-line cvs client (i.e. on Unix or DOS), first type:
`cvs -d :pserver:anoncvs@software.biostat.washington.edu:/var/anoncvs
login'

   password is anoncvs

   then type:    `cvs -d
:pserver:anoncvs@software.biostat.washington.edu:/var/anoncvs co ess'


File: ess.info,  Node: Manual,  Prev: Latest version,  Up: Introduction

How to read this manual
=======================

   If ESS has already been installed on your system, the next chapter
has details on how to get started using S under ESS.

   If you need to install ESS, read *Note Installation:: for details on
what needs to be done before proceeding to the next chapter.

   *Note Customization:: provides details of user variables you can
change to customize ESS to your taste, but it is recommended that you
defer this section until you are more familiar with ESS.

   Don't forget that this manual is not the only source of information
about ESS.  In particular, the mode-based online help (obtained by
pressing `C-h m' when in the process buffer, edit buffer or help
buffer) is quite useful.  However the best source of information is, as
always, experience -- try it out!


File: ess.info,  Node: Starting Up,  Next: Entering commands,  Prev: Introduction,  Up: Top

Starting the ESS process
************************

   To start an S session, simply type `M-x S RET', i.e. press <ESC>,
then <x>, then capital <S> and then the <RETURN> key.

   S will then (by default) ask the question
     S starting data directory?

Enter the name of the directory you wish to start S from (that is, the
directory you would have `cd''d to before starting S from the shell).
This directory should have a `.Data' subdirectory.

   You will then be popped into a buffer with name `*S*' which will be
used for interacting with the ESS process, and you can start entering
commands.

* Menu:

* Multiple ESS processes::
* ESS processes on Remote Computers::
* Customizing startup::         Changing the startup actions


File: ess.info,  Node: Multiple ESS processes,  Next: ESS processes on Remote Computers,  Prev: Starting Up,  Up: Starting Up

Running more than one ESS process
=================================

   ESS allows you to run more than one ESS process simultaneously in the
same session.  Each process has a name and a number; the initial process
(process 1) is simply named (using S-PLUS as an example) `S+3:1'.  The
name of the process is shown in the mode line in square brackets (for
example, `[S+3:2]'); this is useful if the process buffer is renamed.
Without a prefix argument, `M-x S' starts a new ESS process, using the
first available process number.  With a prefix argument (for R), `C-u
M-x R' allows for the specification of command line options for the
size of memory allocated to the R process, for example.

   You can switch to any active ESS process with the command `C-c C-k'
(`ess-request-a-process').  Just enter the name of the process you
require; completion is provided over the names of all running S
processes.  This is a good command to consider binding to a global key.

   For the predecessor to ESS (S-mode 4.8), the initial process was not
visibly numbered, i.e. S instead of S1 was used in the mode-line.  To
obtain this behavior, set the variable `ess-plain-first-buffername' to
`t'.  See `ess-site' for how to set this for all users.


File: ess.info,  Node: ESS processes on Remote Computers,  Next: Customizing startup,  Prev: Multiple ESS processes,  Up: Starting Up

ESS processes on Remote Computers
=================================

   ESS works with processes on remote computers as easily as with
processes on the local machine.  The recommended way to access a
statistical program on remote computer is to start it from a telnet or
ssh buffer and then connect ESS to that buffer.

  1. Start a new telnet or ssh buffer and connect to the remote
     computer.

  2. Start the ESS process on the remote machine, for example with one
     of the commands `Splus', or `R', or `sas -stdio'.

  3. Enter the ESS command `M-x ess-remote'.  You will be prompted for
     a program name.  Enter `sp6' or `r' or `sas' or another valid
     name.  Your telnet process is now known to ESS.  All the usual ESS
     commands (`C-c C-n' and its relatives) now work with the S
     language processes.  For SAS you need to use a different command
     `C-c i' (that is a regular `i', not a `C-i') to send lines from
     your `myfile.sas' to the remote SAS process.  `C-c i' sends lines
     over invisibly and lets SAS display them formatted correctly as in
     a SAS log file.

  4. Graphics (interactive) on the remote machine.  If you run X11
     (*Note X11::, X-windows) on both the local and remote machines
     then you should be able to display the graphs locally by setting
     the `DISPLAY' environment variable appropriately.  Windows users
     can download `xfree86' from cygwin.

  5. Graphics (static) on the remote machine.  If you don't run
     X-windows on the local machine, then you can write graphics to a
     file on the remote machine, and display the file in a graphics
     viewer on the local machine.  Most statistical software can write
     one or more of postscript, GIF, or JPEG files.  Depending on the
     versions of emacs and the operating system that you are running,
     emacs itself may display `.gif' and `.jpg' files.  Otherwise, a
     graphics file viewer will be needed.  Ghostscript/ghostview may be
     downloaded to display `.ps' and `.eps' files.  Viewers for GIF and
     JPEG are usually included with operating systems.  *Note
     ESS(SAS)--Function keys for batch processing::, for more
     information on using the F12 key for displaying graphics files
     with SAS.

   Should you or a colleague inadvertently start a statistical process
in an ordinary `*shell*' buffer, the `ess-remote' command can be used
to convert it to an ESS buffer and allow you to use the ESS commands
with it.

   We have two older commands, now deprecated, for accessing ESS
processes on remote computers.  *Note S+elsewhere and ess-elsewhere::.


File: ess.info,  Node: S+elsewhere and ess-elsewhere,  Prev: ESS processes on Remote Computers,  Up: ESS processes on Remote Computers

S+elsewhere and ess-elsewhere
=============================

   These commands are now deprecated.  We recommend `ess-remote'.

   We have two versions of the elsewhere function.

   `S+elsewhere' is specific for the S-Plus program.  The more general
function `ess-elsewhere' is not as stable.

  1. Enter `M-x S+elsewhere'.  You will be prompted for a starting
     directory.  I usually give it my project directory on the local
     machine, say  `~myname/myproject/'

     Or enter `M-x ess-elsewhere'.  You will be prompted for an ESS
     program and for a starting directory.  I usually give it my project
     directory on the local machine, say `~myname/myproject/'

  2. The `*S+3*' buffer will appear with a prompt from the local
     operating system (the unix prompt on a unix workstation or with
     cygwin bash on a PC, or the msdos prompt on a PC without bash).
     emacs may freeze because the cursor is at the wrong place.
     Unfreeze it with `C-g' then move the cursor to the end with `M->'.
     With `S+elsewhere' the buffer name is based on the name of the ESS
     program.

  3. Enter `telnet myname@other.machine' (or `ssh
     myname@other.machine').  You will be prompted for your password on
     the remote machine.  Use `M-x send-invisible' before typing the
     password itself.

  4. Before starting the ESS process, type `stty -echo nl' at the unix
     prompt.  The `-echo' turns off the echo, the `nl' turns off the
     newline that you see as `^M'.

  5. You are now talking to the unix prompt on the other machine in the
     `*S+3*' buffer.  cd into the directory for the current project and
     start the ESS process by entering `Splus' or `R' or `sas -stdio'
     as appropriate.  If you can login remotely to your Windows 2000,
     then you should be able to run `Sqpe' on the Windows machine.  I
     haven't tested this and noone has reported their tests to me.  You
     will not be able to run the GUI through this text-only connection.

  6. Once you get the S or R or SAS prompt, then you are completely
     connected.  All the `C-c C-n' and related commands work correctly
     in sending commands from `myfile.s' or `myfile.r' on the PC to the
     `*S+3*' buffer running the S or R or SAS program on the remote
     machine.

  7. Graphics on the remote machine works fine.  If you run X-windows
     graphics on the remote unix machine you should be able to display
     them in `xfree86' on your PC.  If you don't run X-windows, then
     you can write graphics to the postscript device and copy it to
     your PC with dired and display it with ghostscript.


File: ess.info,  Node: Customizing startup,  Prev: ESS processes on Remote Computers,  Up: Starting Up

Changing the startup actions
============================

   If you do not wish ESS to prompt for a starting directory when
starting a new process, set the variable `ess-ask-for-ess-directory' to
`nil'.  In this case, the value of the variable `ess-directory' is used
as the starting directory.  The default value for this variable is your
home directory.  If `ess-ask-for-ess-directory' has a non-`nil' value
(as it does by default) then the value of `ess-directory' provides the
default when prompting for the starting directory.  Incidentally,
`ess-directory' is an ideal variable to set in `ess-pre-run-hook'.

   If you like to keep a records of your S sessions, set the variable
`ess-ask-about-transfile' to `t', and you will be asked for a filename
for the transcript before the ESS process starts.

 - User Option: ess-ask-about-transfile
     If non-`nil', as for a file name in which to save the session
     transcript.

   Enter the name of a file in which to save the transcript at the
prompt.  If the file doesn't exist it will be created (and you should
give it a file name ending in `.St'; if the file already exists the
transcript will be appended to the file.  (Note: if you don't set this
variable but you still want to save the transcript, you can still do it
later -- *note Saving transcripts::.)

   Once these questions are answered (if they are asked at all) the S
process itself is started by calling the program name specified in the
variable `inferior-ess-program'.  If you need to pass any arguments to
this program, they may be specified in the variable
`inferior-S_PROGRAM_NAME-args' (e.g. if `inferior-ess-program' is
`"S+"' then the variable to set is `inferior-S+-args'.  It is not
normally necessary to pass arguments to the S program; in particular do
not pass the `-e' option to `Splus', since ESS provides its own command
history mechanism.


File: ess.info,  Node: Entering commands,  Next: Editing,  Prev: Starting Up,  Up: Top

Interacting with the ESS process
********************************

   The primary function of the ESS package is to provide an easy-to-use
front end to the S interpreter.  This is achieved by running the S
process from within an Emacs buffer, so that the Emacs editing commands
are available to correct mistakes in commands, etc.  The features of
Inferior S mode are similar to those provided by the standard Emacs
shell mode (*note Shell Mode: (emacs)Shell Mode.).  Command-line
completion of S objects and a number of `hot keys' for commonly-used S
commands are also provided for ease of typing.

* Menu:

* Command-line editing::        Entering commands and fixing mistakes
* Completion::                  Completion of object names
* Completion details::          Advanced completion concepts
* Transcript::                  Manipulating the transcript
* Command History::             Command History
* History expansion::           References to historical commands
* Hot keys::                    Hot keys for common commands
* Statistical Process running in ESS?::
* Other::                       Other commands provided by inferior-ESS


File: ess.info,  Node: Command-line editing,  Next: Completion,  Prev: Entering commands,  Up: Entering commands

Entering commands and fixing mistakes
=====================================

   Sending a command to the ESS process is as simple as typing it in
and pressing the <RETURN> key:

   * `RET' (`inferior-ess-send-input')
     Send the command on the current line to the ESS process.

   If you make a typing error before pressing `RET' all the usual Emacs
editing commands are available to correct it (*note Basic:
(emacs)Basic.).  Once the command has been corrected you can press
<RETURN> (even if the cursor is not at the end of the line) to send the
corrected command to the ESS process.

   ESS provides some other commands which are useful for fixing
mistakes:

   * `C-c C-w' (`backward-kill-word')
     Deletes the previous word (such as an object name) on the command
     line.

   * `C-c C-u' (`comint-kill-input')
     Deletes everything from the prompt to point.  Use this to abandon a
     command you have not yet sent to the ESS process.

   * `C-c C-a' (`comint-bol')
     Move to the beginning of the line, and then skip forwards past the
     prompt, if any.

   *Note Shell Mode: (emacs)Shell Mode, for other commands relevant to
entering input.


File: ess.info,  Node: Completion,  Next: Completion details,  Prev: Command-line editing,  Up: Entering commands

Completion of object names
==========================

   In the process buffer, the <TAB> key is for completion, similar to
that provided by Shell Mode for filenames.  In Inferior S mode,
pressing the <TAB> key when the cursor is following the first few
characters of an object name _completes_ the object name; if the cursor
is following a file name `TAB' completes the file name.

   * `TAB' (`comint-dynamic-complete')
     Complete the S object name or filename before point.

   When the cursor is just after a partially-completed object name,
pressing <TAB> provides completion in a similar fashion to `tcsh'
except that completion is performed over all known S object names
instead of file names.  ESS maintains a list of all objects known to S
at any given time, which basically consists of all objects (functions
and datasets) in every attached directory listed by the `search()'
command along with the component objects of attached data frames (if
your version of S supports them).

   For example, consider the three functions (available in Splus version
3.0) called `binomplot()', `binom.test()' and `binomial()'.  Typing
`bin TAB' after the S prompt will insert the characters `om',
completing the longest prefix (`binom') which distinguishes these three
commands.  Pressing `TAB' once more provides a list of the three
commands which have this prefix, allowing you to add more characters
(say, `.') which specify the function you desire.  After entering more
characters pressing `TAB' yet again will complete the object name up to
uniqueness, etc.  If you just wish to see what completions exist without
adding any extra characters, type `M-?'.

   * `M-?' (`ess-list-object-name-completions')
     List all possible completions of the object name at point.

   ESS also provides completion over the components of named lists
accessed using the `$' notation, to any level of nested lists.  This
feature is particularly useful for checking what components of a list
object exist while partway through entering a command: simply type the
object name and `$' and press `TAB' to see the names of existing list
components for that object.

   Completion is also provided over file names, which is particularly
useful when using S functions such as `get()' or `scan()' which require
fully expanded file names.  Whenever the cursor is within an S string,
pressing `TAB' completes the file name before point, and also expands
any `~' or environment variable references.

   If the cursor is not in a string and does not follow a (partial)
object name, the <TAB> key has a third use: it expands history
references.  *Note History expansion::.


File: ess.info,  Node: Completion details,  Next: Transcript,  Prev: Completion,  Up: Entering commands

Completion details
==================

   ESS automatically keeps track of any objects added or deleted to the
system (such as new objects created, or directories added to the search
list) to make completion as accurate as possible.  Whenever ESS notices
that search list has changed (1)  when you attach a directory or data
frame, the objects associated with it immediately become available for a
completion; when it is detached completion is no longer available on
those objects.

   To maintain a list of accessible objects for completion, ESS needs to
determine which objects are contained in each directory or data frame on
the search list.  This is done at the start of each S session, by
running the `objects()' command on every element of the search list.
On some systems, however, this can be rather slow; it's doubly
frustrating when you consider that most of the directories on the search
list are the standard S libraries, which never change anyway!  When ESS
was installed, a database of the standard object names should have been
created which should speed up this process at the start of an S
session; if it has not been created you will get a warning like
`S-namedb.el does not exist'.  *Note Installation::, for information on
how to create this database.

   Efficiency in completion is gained by maintaining a cache of objects
currently known to S; when a new object becomes available or is deleted,
only one component of the cache corresponding to the associated
directory needs to be refreshed.  If ESS ever becomes confused about
what objects are available for completion (such as when if refuses to
complete an object you *know* is there), the command `M-x ess-resynch'
forces the _entire_ cache to be refreshed, which should fix the problem.

   ---------- Footnotes ----------

   (1) The variable `ess-change-sp-regex' is a regular expression
matching commands which change the search list.  You will need to
modify this variable if you have defined custom commands (other than
`attach', `detach', `collection' or `library') which modify the search
list.


File: ess.info,  Node: Transcript,  Next: Command History,  Prev: Completion details,  Up: Entering commands

Manipulating the transcript
===========================

   Most of the time, the cursor spends most of its time at the bottom of
the ESS process buffer, entering commands.  However all the input and
output from the current (and previous) ESS sessions is stored in the
process buffer (we call this the transcript) and often we want to move
back up through the buffer, to look at the output from previous
commands for example.

   Within the process buffer, a paragraph is defined as the prompt, the
command after the prompt, and the output from the command.  Thus `M-{'
and `M-}' move you backwards and forwards, respectively, through
commands in the transcript.  A particularly useful command is `M-h'
(`mark-paragraph') which will allow you to mark a command and its
entire output (for deletion, perhaps).  For more information about
paragraph commands, *note Paragraphs: (emacs)Paragraphs..

   If an ESS process finishes and you restart it in the same process
buffer, the output from the new ESS process appears after the output
from the first ESS process separated by a form-feed (`^L') character.
Thus pages in the ESS process buffer correspond to ESS sessions.  Thus,
for example, you may use `C-x [' and `C-x ]' to move backward and
forwards through ESS sessions in a single ESS process buffer.  For more
information about page commands, *note Pages: (emacs)Pages..

* Menu:

* Last command::                Manipulating the output from the last command
* Process buffer motion::       Viewing more historic commands
* Transcript resubmit::         Re-submitting commands from the transcript
* Saving transcripts::          Keeping a record of your S session


File: ess.info,  Node: Last command,  Next: Process buffer motion,  Prev: Transcript,  Up: Transcript

Manipulating the output from the last command
---------------------------------------------

   Viewing the output of the command you have just entered is a common
occurrence and ESS provides a number of facilities for doing this.
Whenever a command produces a longish output, it is possible that the
window will scroll, leaving the next prompt near the middle of the
window.  The first part of the command output may have scrolled off the
top of the window, even though the entire output would fit in the window
if the prompt were near the bottom of the window.  If this happens, you
can use the command

   * `C-c C-e' (`comint-show-maximum-output')
     Move to the end of the buffer, and place cursor on bottom line of
     window.

to make more of the last output visible.  (To make this happen
automatically for all inputs, set the variable
`comint-scroll-to-bottom-on-input' to `t'; for information on this and
other options for handling process input and output *note Shell Mode
Options: (emacs)Shell Options..)

   If the first part of the output is still obscured, use
   * `C-c C-r' (`comint-show-output')
     Moves cursor to the previous command line and and places it at the
     top of the window.

to view it.  Finally, if you want to discard the last command output
altogether, use

   * `C-c C-o' (`comint-kill-output')
     Deletes everything from the last command to the current prompt.

to delete it.  Use this command judiciously to keep your transcript to a
more manageable size.


File: ess.info,  Node: Process buffer motion,  Next: Transcript resubmit,  Prev: Last command,  Up: Transcript

Viewing more historic commands
------------------------------

   If you want to view the output from more historic commands than the
previous command, commands are also provided to move backwards and
forwards through previously entered commands in the process buffer:

   * `C-c C-p' (`comint-previous-input')
     Moves point to the preceding command in the process buffer.

   * `C-c C-n' (`comint-next-input')
     Moves point to the next command in the process buffer.

Note that these two commands are analogous to `C-p' and `C-n' but apply
to command lines rather than text lines.  And just like `C-p' and
`C-n', passing a prefix argument to these commands means to move to the
ARG'th next (or previous) command.  (These commands are also discussed
in *Note Shell History Copying: (emacs)Shell History Copying.)

   There are also two similar commands (not bound to any keys by
default) which move to preceding or succeeding commands, but which
first prompt for a regular expression (*note Syntax of Regular
Expression: (emacs)Regexps.), and then moves to the next (previous)
command matching the pattern.

 - Command: comint-backward-matching-input regexp arg
 - Command: comint-forward-matching-input regexp arg
     Search backward (forward) through the transcript buffer for the
     ARG'th previous (next) command matching REGEXP.  ARG is the prefix
     argument; REGEXP is prompted for in the minibuffer.


File: ess.info,  Node: Transcript resubmit,  Next: Saving transcripts,  Prev: Process buffer motion,  Up: Transcript

Re-submitting commands from the transcript
------------------------------------------

   When moving through the transcript, you may wish to re-execute some
of the commands you find there.  ESS provides three commands to do this;
these commands may be used whenever the cursor is within a command line
in the transcript (if the cursor is within some command _output_, an
error is signaled).  Note all three commands involve the <RETURN> key.

   * `RET' (`inferior-ess-send-input')
     Copy the command under the cursor to the current command line, and
     execute it.

   * `C-c RET' (`comint-copy-old-input')
     Copy the command under the cursor to the current command line, but
     don't execute it.  Leaves the cursor on the command line so that
     the copied command may be edited.

   * `M-RET' (`ess-transcript-send-command-and-move')
     Copy the command under the cursor to the current command line, and
     execute it.  Moves the cursor to the following command.

   When the cursor is not after the current prompt, the <RETURN> key
has a slightly different behavior than usual.  Pressing `RET' on any
line containing a command that you entered (i.e. a line beginning with a
prompt) sends that command to the ESS process once again.  If you wish
to edit the command before executing it, use `C-c RET' instead; it
copies the command to the current prompt but does not execute it,
allowing you to edit it before submitting it.

   These two commands leave the cursor at the new command line, allowing
you to continue with interactive use of S.  If you wish to resubmit a
series of commands from the transcript, consider using `M-RET' instead,
which leaves the cursor at the command line following the one you
re-submitted.  Thus by using `M-RET' repeatedly, you can re-submit a
whole series of commands.

   These commands work even if if the current line is a continuation
line (i.e. the prompt is `+' instead of `>') -- in this case all the
lines that form the multi-line command are concatenated together and
the resulting command is sent to the ESS process (currently this is the
only way to resubmit a multi-line command to the ESS process in one
go).  If the current line does not begin with a prompt, an error is
signaled.  This feature, coupled with the command-based motion commands
described above, could be used as a primitive history mechanism.  ESS
provides a more sophisticated mechanism, however, which is described in
*Note Command History::.

