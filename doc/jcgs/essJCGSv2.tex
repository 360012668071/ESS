\documentclass{article}

\newif\ifdraft
% During writing: a draft:
%\drafttrue
% FINAL:
\draftfalse

\ifdraft  %% generate tableofcontents down to the \paragraph
\setcounter{tocdepth}{5}
\fi
%1. introduction
%        a) a statistician's needs
%        b) statistical analysis packages supported by ESS
%2. emacs 
%        a) buffers
%        b) key sequences
%        c) modes
%                1) font-lock
%                2) shell/comint
%                3) ange-ftp/EFS/tramp
%                4) vc/pcl-cvs
%3. ESS
%        a) interactive
%           1) S family
%           2) SAS
%        b) batch
%           1) SAS
%           2) BUGS
%           3) S family
%4. ESS as an open-source project
%        a) origins
%                1)S-mode
%                2)SAS-mode
%        b) unification
%                1)ESS-mode
%                2)Emacs/XEmacs
%                3)Unix/Windows/Mac
%5. conclusion
%        a) summary
%        b) what's next for ESS
%   ESS internet resources
%        a) home page
%        b) ess-help
%        c) anonymous cvs
%   References
%
\ifdraft
 \addtolength{\topmargin}{-1cm}
 \addtolength{\textheight}{+1cm}
\else%FINAL:
 \renewcommand{\baselinestretch}{1.5}
\fi
\addtolength{\oddsidemargin}{-0.5in}
\addtolength{\textheight}{0.2in}
\addtolength{\textwidth}{1in}

%%%
\usepackage[authoryear,round]{natbib}
%or (if you have an unshiny latex installation)
%\newcommand{\citep}[1]{{\{\sf#1\}}}
%%%
\usepackage{alltt}

%% Postscript fonts
\usepackage{times}
\usepackage{graphicx}
%\usepackage{psfig}

\ifx\pdfoutput\undefined
  %% Stuff wout hyperref
  \def\url#1{\stexttt{#1}} % To help fit in lines ?AJR: stextsf?
\else
  %% Stuff with hyperref
  \usepackage{hyperref}
  %%\hypersetup{backref,colorlinks=true,pagebackref=true,hyperindex=true}
  \hypersetup{backref,colorlinks=false,pagebackref=true,hyperindex=true}
\fi
%%---End of package requiring ---------- Own Definitions -------------

\newcommand*{\regstrd}{$^{\mbox{\scriptsize{\textregistered}}}$}
\newcommand*{\tm}{$^{\mbox{\scriptsize\sc tm}}$}
\newcommand*{\SAS}{\textsc{SAS}}
\newcommand*{\Splus}{\textsc{S-Plus}}
\newcommand*{\XLispStat}{\textsc{XLispStat}}
\newcommand*{\Stata}{\textsc{Stata}}
\newcommand*{\Rgui}{\textsc{Rgui}}
\newcommand*{\Perl}{\textsc{Perl}}
\newcommand*{\Fortran}{\textsc{Fortran}}
\newcommand*{\Scmt}[1]{\hbox{\qquad {\footnotesize \#\#} \textsl{#1}}}
\newtheorem{defn}{Definition}[section]
\newtheorem{ex}{Example}[section]

\newcommand{\stexttt}[1]{{\small\texttt{#1}}}
\newcommand{\ssf}[1]{{\small\sf{#1}}}
\newcommand{\elcode}[1]{\\{\stexttt{\hspace*{2em} #1}}\\}
\newcommand{\file}[1]{`\stexttt{#1}'}
\newcommand{\US}{{\char'137}}        % \tt _
\newcommand{\marpar}[1]{\marginpar{\raggedright#1}}
\newenvironment{Salltt}{\small\begin{alltt}}{\end{alltt}}

\newcommand{\emptyfig}{
\hspace*{42pt}\rule{324pt}{.25pt}\\
\hspace*{42pt}\rule{.25pt}{10pc}
\rule{316pt}{.25pt}
\rule{.25pt}{10pc}}

%% Use \begin{Comment} .. \end{Comment} for internal comments
\ifdraft
\newenvironment{Comment}{\begin{quote}\small\itshape }{\end{quote}}
%
\else  %% this requires
  \usepackage{verbatim}
  \let\Comment=\comment
  \let\endComment=\endcomment
\fi


%%--------------------------------------------------------------- Start Text

\title{Emacs Speaks Statistics (ESS): A multi-platform, multi-package
intelligent environment for statistical analysis}

\author{A.J. Rossini \and Martin M{\"a}chler \and Kurt Hornik \and Richard
  M. Heiberger \and Rodney Sparapani \footnote{%
%%
    A.J. Rossini is Research Assistant Professor in the Department of
    Biostatistics, University of Washington and Joint Assistant Member at
    the Fred Hutchinson Cancer Research Center, Seattle, WA, USA
    (E-mail: rossini@u.washington.edu);
%%
    Martin M{\"a}chler is Senior Scientist and Lecturer in the Seminar for
    Statistics, ETH Zurich, Zurich, Switzerland
    (E-mail: maechler@stat.math.ethz.ch);
%%
    Kurt Hornik is Professor in the Institut f{\"u}r Statistik,
    Wirtschaftsuniversit{\"a}t Wien and the Institut f{\"u}r
    Wahrscheinlichkeitstheorie und Statistik, Technische Universit{\"a}t
    Wien, Vienna, Austria (E-mail: Kurt.Hornik@r-project.org);
%%
    Richard M. Heiberger is Professor in the Department of Statistics at
    Temple University, Philadelphia, PA, USA (E-mail: rmh@temple.edu);
%%
    Rodney Sparapani is Senior Biostatistician in the Center for Patient
    Care and Outcomes Research at the Medical College of Wisconsin, 
    Milwaukee, WI, USA (E-mail: rsparapa@mcw.edu)}}

%%S\date{\today}
\date{$ $Date: 2002/02/20 18:57:32 $ - $Revision: 1.218 $ $\tiny printed \today}

\begin{document}

%%\ifpdf
%%  \DeclareGraphicsExtensions{.jpg,.pdf,.png,.mps}
%%\fi
%%%% To cite everything
%%\nocite{*} 

\ifdraft
\setcounter{page}{0}
%%\newpage
\tableofcontents
\fi

\maketitle

\ifdraft{}%% large line skip -- please not yet (MM)
\else%FINAL:
 \renewcommand{\baselinestretch}{1.5}
 %%- \baselineskip=2pc
\fi

\begin{abstract}
  Computer programming is an important component of statistics
  research and data analysis.  This skill is necessary for using
  sophisticated statistical packages as well as for writing custom
  software for data analysis.  Emacs Speaks Statistics (ESS) provides
  an intelligent, consistent interface between the user and software.
  ESS interfaces with SAS, S-PLUS, R, and other statistics packages
  under the Unix, Microsoft Windows, and Apple Macintosh operating
  systems.  ESS extends the Emacs text editor and uses its many
  features to streamline the creation and use of statistical software.
  ESS understands the syntax for each data analysis language it works
  with and provides consistent display and editing features across
  packages.  ESS assists in the interactive or batch execution by the
  statistics packages of statements written in their languages.  Some
  statistics packages can be run as a subprocess of Emacs, allowing
  the user to work directly from the editor and thereby retain a
  consistent and constant look-and-feel.  We discuss how ESS works and
  how it increases statistical programming efficiency.
\end{abstract}

\noindent Keywords: Data Analysis, Programming, 
S, \SAS, \Splus, R, \XLispStat, \Stata, BUGS, open source software,
cross-platform user interface.

\section{Introduction}
\label{sec:introduction}

Most statistical research activities, particularly data analysis and
communication, involve some form of computing.  The computer user
interface is thus placed in the central role of facilitating
statistical tasks.  While presentation of character and graphical
information is the most visual component of a user interface,
perhaps a more critical component is how the computer interprets user
input.  A familiar, well-understood set of input behaviors can provide
large gains in efficiency.  This paper introduces Emacs Speaks
Statistics (ESS) \citep{ESS}, a software package which provides a
common interface to a variety of statistical packages on the most
common computing platforms.

ESS is a statistical package interface which provides, through Emacs,
tools which facilitate both statistical software development and data
analysis.  ESS provides assistance with both writing and evaluation of
analysis code for both interactive and batch statistical packages.
ESS currently supports the S family of languages (including S
\citep{BecRCW88,ChaJH92,ChaJ98}, \Splus\regstrd\ \citep{Splus}, and R
\citep{ihak:gent:1996}); \SAS\regstrd\ \citep{SAS:8}; \XLispStat\ 
\citep{Tier90} and its extensions Arc \citep{Cook:Weisberg:1999} and
ViSta \citep{youn:fald:mcfa:1992}; \Stata\ \citep{Stata:7.0}; Omegahat
\citep{DTLang:2000}; and BUGS \citep{BUGS}.  ESS can be extended to
accommodate most statistical packages which provide either an
interactive command-line or process batch files for instructions.

We start by describing the Emacs text editor, the underlying platform
on which ESS is built.  Next, we discuss how ESS enhances a
statistician's daily activities by presenting its features and showing
how it facilitates statistical computing.  We give a short history of
the development of ESS and conclude with future extensions and related
work.

\section{Emacs}
\label{sec:emacs}

Emacs is a mature, powerful, and extensible text editing system which
is freely available under the GNU General Public License (GPL) for a
large number of platforms, including most distributions of
Unix\regstrd, Microsoft Windows\regstrd\ and Apple Mac\tm\ OS.  There
are two open-source implementations of Emacs released under the GPL:
GNU Emacs \citep{GNU-Emacs} and XEmacs \citep{XEmacs}.  Emacs shares
many features with word processors, and some characteristics with
operating systems, including many facilities which go beyond ordinary
text editing.  More important to our goals, Emacs can control and
interact with other programs.

\paragraph{Keyboard and Mouse Input.}
When Emacs was originally written, character-based terminals were the
most advanced method of computer access.  Common Emacs commands were
mapped to key sequences, creating keyboard shortcuts for convenience.
Over the last decade, Emacs has been extended to use graphical
windowing systems, such as X11\tm, Microsoft Windows, and Apple Mac
OS, which allow additional forms of input, for example using a mouse,
and which encourage multiple applications to share a single display.
Presently, Emacs is more often used with a GUI, with commands bound to
mouse actions, but having commands also associated with key sequences
is an important ergonomic and time-saving feature.  Emacs menus and
toolbars on the display screen allow mouse access to frequently used
actions and provide a graphical alternative when the user does not
know or can not recall a key sequence; these are also subject to
user-customization.

\paragraph{Buffers give Emacs control.}
Emacs buffers are the interface between the user and computer.  They
can be considered to be a collection of scratch pads that both the
user and computer can read, write, and respond to.  The user can
simultaneously edit many files and control numerous programs by
opening multiple buffers.  With disk files, the working copy of the
opened file is placed in an Emacs buffer where it can be viewed and
edited either by the user or automatically by Emacs or another program
under the control of Emacs.  Emacs can save a backup of the contents
to disk at specified intervals.  Emacs presents buffer contents in
ways which optimize reading and navigation activities.  One example of
program control is the embedding of the interactive operating system
command line interpreter, called a shell, within Emacs.  Variations on
this theme are used to control programs such as statistical packages
which take input from and provide output to the command-line.  The
resulting buffers provide a copy of the entire transcript of the
interaction, which can be edited and searched while the program
executes.

\paragraph{Major and Minor Modes.}
Emacs capabilities are extended by loading text or byte-compiled files
containing commands and functions written in Emacs Lisp (elisp)
\citep{RChassell1999}, which is a dialect of Lisp
\citep{PGraham:1996}.  Emacs commands can be called interactively by
pressing a key sequence mapped to the command.
%% AJR: this is actually true for M-x long-command-not-bound-to-keys,
%% but I'm not telling anyone this!
The most important extensions to Emacs take the form of modes, which
provide specific enhancements to the editing behavior.

Major modes provide a customized environment consisting of mapped key
sequences and associated commands for performing tasks such as file
editing, reading mail, or browsing disk directories.  Only one major
mode can be active for a given buffer at any time.  Major modes for
file editing are often determined by the file name extension, i.e.
the characters at the end of the file name that follow a period like
\stexttt{txt}, \stexttt{R} or \stexttt{sas}.  Examples of this kind of
major mode are \stexttt{ESS[S]} and \stexttt{ESS[SAS]}.  Major modes
understand filetype's syntax and grammer and therefore provide
intelligent actions such as automatic indentation; navigation in units
of characters, words, lines, sentences, paragraphs, function
definitions, and pages; syntax-based fontification and colorization;
and reformatting based on programmed conventions.  Major modes also
can be written to intelligently control other programs such as
statistics packages.

Minor modes provide complementary services that that are applicable
across major modes.  Many minor modes can be active at once.  For
example, \stexttt{font-lock-mode} allows Emacs to highlight, with
fonts or colors, the syntax of a programming language whose
characteristics are described within a major mode like
\stexttt{ESS[S]}.  The \stexttt{overwrite-mode} determines whether
typed characters replace the existing text or are inserted at the
cursor.  Minor modes can emulate the key sequences used by another
editor such as \stexttt{vi}.  In addition, they can be used to perform
version control operations and many other operations which are nearly
identical across file types.

\paragraph{Network Support.}
Emacs allows transparent access to remote files over a network.  This
means that the user views, edits, and saves files on a remote machine
exactly as if they were on the local machine.  Mechanisms for both
open (\stexttt{ange-ftp} and \stexttt{EFS} use ftp) and secure
(\stexttt{tramp} uses scp or ssh) access are available.  Emacs can
also monitor and control remote processes running in a shell buffer.

\paragraph{Editing Extensions.}
Most programming and documentation tasks consist of editing text.
These tasks can be enhanced by contextual highlighting and recognition
of special reserved words appropriate to the programming language in
use.  In addition, Emacs also supports folding, outlining, tags, and
bookmarks, all of which assist with maneuvering around a file.  Emacs
shares many features with word processing programs and cooperates with
markup-language document preparation systems such as \LaTeX,
\textsc{html}, or \textsc{xml}.

Tracking changes to a text file made by multiple users, potentially in 
different locations, is the job of source-code control programs.
Emacs interacts with standard source-code control programs such as CVS, RCS,
and SCCS through minor modes such as \stexttt{vc-mode}.  These
source-code control systems facilitate documenting and tracking edits and
changes to a file.  More importantly, they allow for branching and
merging of versions so that material present in an older version of
the file can be recovered and inserted into a newer version in a
fairly easy manner.

Comparison of files, two or three drafts of a paper for example, is
simplified by \stexttt{ediff}.  An example is shown in Figure
\ref{f.ediff}.  The lines that are similar are highlighted in the two
buffers, one for each file, and the specific words that mismatch are
highlighted in a contrasting color.  \stexttt{ediff} has many tools
for working with the differences in files and in entire directories.
When combined with the patch utility or a source-code control system,
it provides the user with the ability to insert, delete or modify only
the differing portions of text files.

\begin{figure}[tbp]
  \centering
  \ifdraft
     \emptyfig
  \else
     \includegraphics[angle=270,width=\textwidth]{ediff-sas}
  \fi
  \caption{Ediff of two versions of a file.}
  \label{f.ediff}
\end{figure}

% Rodney: You can't just mention complex functionality like etags and 
% speedbar.  We would need to introduce these packages.  Since they 
% aren't critical to ESS at this time, let's ignore them.
Emacs has many other important features.  Emacs provides file-manager
capabilities, such as \stexttt{dired} (discussed in Major and Minor
Modes above) and \stexttt{speedbar}, both of which interface to the
computer's directory structure.  Emacs stores the complete history of
commands issued in an editing session, allowing a flexible and fairly
complete undo capability.  More importantly, for modes which control
processes, the process input history is stored for recall as well as
for later editing for printing or re-use.  Emacs also includes web
browsers, mail and news readers, and spell checking.

In addition to being an an extremely powerful editor, Emacs also
includes capabilities usually found in an operating system.  Thus it
provides a strong foundation for constructing an integrated
development environment focused on the needs of statisticians.  Emacs'
power, flexibility, portability, and extensibility make it a solid
platform on which to construct a statistical analysis user interface.

\section{ESS extends Emacs}
\label{sec:ess-extends-emacs}

Statistical programming is the writing of computer programs for data
analysis and processing.  These programs might be written in a
computer language that requires a compiler, such as \Fortran\ or C.
But, more likely, they are written in a statistical analysis language
that only requires an interpreter such as R, \SAS, \Stata, or \XLispStat.
General purpose languages such as \Fortran, C/C++, Java, and PERL
have integrated development environments which facilitate writing and
debugging code.  ESS is an extension package for the Emacs editor
which provides features commonly found in such environments but which
are customized for statistical languages.  It provides a single
interface for a variety of statistical computing tasks including
interactive data analysis and statistical programming.

ESS supports the S family (S, \Splus, and R) interactively.  \SAS\ and
BUGS are also well supported for batch processing.  \Stata\ and
\XLispStat\ (including ARC and ViSta) are supported through
highlighting and process-interfacing.

ESS extends Emacs to provide a functional and extensible interface
which is uniform and consistent across multiple statistical packages.
This is done by adding shortcuts and features for accelerated editing
of files as well as by interacting with the particular statistical
packages to provide, for example, control of input/output, assistance
with evaluation, and specialized parsing of help files.

\subsection{Features and capabilities}
\label{sec:ESS:features}

\paragraph{Syntactic highlighting and indentation of source code.}
The programmers task is eased when language constructs (such as
reserved words, function calls, strings, and comments) are visually
identifiable and when lines of code are automatically indented to a
depth appropriate to their context (e.g., if--then clauses, loops).
ESS provides both of these to the programmer by including a
description of the syntax of each supported statistical language in
the form used by \stexttt{font-lock-mode}.

Figure \ref{f.font} shows an example of font-locking a complicated S
statement.  The top panel shows an \stexttt{if} statement with a long
expression in the condition and a multi-line consequence.  The keyword
\stexttt{if} is shown in purple, the string \stexttt{"deltat"} in
RosyBrown.  The comments are in red.  Everything else is in the
standard font.  The consequence is indented and the continuations of
the consequence are further indented.  The matching parentheses are
shown in green.  The cursor is indicated by a solid box.  In the
bottom panel we replaced the matching parenthesis with an unbalanced
bracket.  Emacs immediately marks that with the paren-mismatch font,
bright purple in this example.  On a black and white terminal we would
use bold, underline, italic, and reverse-video, rather than colors, to
distinguish the fonts.

% Figure \ref{f.font} shows a black-and-white example of font-locking a
% complicated S statement.  The top panel shows an \stexttt{if}
% statement with a long expression in the condition and a multi-line
% consequence.  The keyword \stexttt{if} is shown in an underlined font,
% the string \stexttt{"deltat"} in an italic underlined font.  The
% comments are in an italic font.  Everything else is in the standard
% font.  The consequence is indented and the continuations of the
% consequence are further indented.  The matching parentheses are marked
% by a bold foreground and a shaded background.  The cursor is indicated
% by a solid box.  In the bottom panel we replaced the matching
% parenthesis with an unbalanced bracket.  Emacs immediately marks that
% with the paren-mismatch font, bright purple on
% a color terminal.

The font selection and the indentation depth are automatically
supplied by Emacs as the lines are typed.  The user has several
options for mapping of colors or fonts to each of the syntactic types.
We selected
%black-and-white font-mapping for display here.  On a color terminal we might use 
purple for the keywords, red for comments, green for matching parens,
and inverse-video purple for mismatched parens.  Emacs makes default
choices of colors and ESS provides several other optional schemes.

\begin{figure}[tbp]%h
  \centering
\ifdraft
  \emptyfig
\else
  \includegraphics[angle=270,width=\textwidth]{font-cor-s}
  \includegraphics[angle=270,width=\textwidth]{font-incor-s}
\fi
  \caption{We illustrate here with fonts and colors appropriate for a
    color display.  On a black and white terminal we would use bold,
    underline, italic, and reverse-video.  On a color terminal we
    would use a selection of colors.}
  \label{f.font}
\end{figure}

For example, syntax highlighting can help enforce company coding
standards.  Figure \ref{f.hilock} shows how to enforce a standard for
\SAS\ programming that says all \stexttt{PROC} statements must use the
\stexttt{DATA=datasetname} option.

ESS has a similar capability for formatting code when programming for
S.  S syntax is similar to that of C, and ESS provides tools for
reformatting code to match particular styles.  Common C format styles
as well as locally customized versions can be specified by indentation
level for nesting statements, braces placed at the end or beginning of
a line, offsets for if-then-else constructs, and similar
characteristics.

%\begin{Comment} Rodney: I agree that this is possible, however, I 
% have never seen a company attempt to enforce such standards.  In fact,
% I don't think it would be a good idea.  It would waste valuable time 
% checking SAS code that would be better spent verifying that the results 
% generated are correct (you have hit one of my pet peeves :o).
% I'd like to drop this controversial subject.  It makes us look like
% a bunch of auditors, rather than statisticians.

%Rich: This example was designed in response to an explicit request
%from the program chair of the Philadelphia SAS Users Group.  He felt
%that industrial SAS users were looking for this type of capability.
%The impression I got from him was that enforcement of standards was
%something that was wanted but that no one knew how to do.  The fact
%the Emacs can do it was a selling point.  It was very well received
%when I presented it at the meeting.

%Rodney: Having been a pharmaceutical SAS user from '93-'00, I can say
%that this is an improper use of auditing.  An auditors time is very 
%valuable and there are never enough auditors when you need them.  
%I'll give you an example.  We had to audit the CRFs of 2500 patients 
%in Europe and the auditors were embarking.  I wrote an undocumented, 
%not-following-the-standards SAS program to generate the audit sheets.  
%Instead of having them look at the code to see if it was compliant, 
%I sent them 50 audit sheets for patients that they already had the 
%source documents for.  As luck would have it, we had one patient that's 
%CRF did not match the audit sheet.  Further digging showed that the 
%Oracle database was not reporting the actual value that was in
%it's table due to a bug introduced in an upgrade 3 months earlier.
%Several hundred audit sheets that were already printed off were
%recycled and two people responsible for the Oracle database lost 
%their jobs.  This is the proper role of the auditor IMHO.  I think
%ESS should stay out of it, at least as far as the paper goes.
%\end{Comment}

\begin{figure}[tbp]
  \centering
  \ifdraft
     \emptyfig
  \else
     \includegraphics[angle=270,width=\textwidth]{hilock-sas}
  \fi
  \caption{Enforce company coding standards.  The standard here is
    that all \stexttt{PROC} statements must use the
    \stexttt{DATA=datasetname} option.  Lines that satisfy the
    standard turn green, lines that don't turn red.
    Ambiguous ones turn yellow.}
  \label{f.hilock}
\end{figure}

\paragraph{Process interaction.}
Emacs has historically referred to processes under its control as
``inferior'', accounting for the name inferior ESS (\stexttt{iESS}) to
denote the mode for interfacing with the statistical package.  Figure
\ref{f.ess-demo} shows the S language program \stexttt{ess-demo.s} in
the top buffer in \stexttt{ESS[S]} mode and the executing R process in
the bottom buffer \stexttt{*R*}.  The
\stexttt{iESS} major mode of the \stexttt{*R*} buffer is crafted for
command-line editing.  This mode remembers and uses the command
history, allowing for the recall and searching of previously entered
commands.  Filename completion for local directories is also
available.

\begin{figure}[tb] %p
  \centering
  \ifdraft
     \emptyfig
  \else
     \includegraphics[angle=270,width=\textwidth]{ess-demo}
  \fi
  \caption{Line-by-line execution of a command file. The cursor is
    placed on a line in the \stexttt{ESS[S]} buffer and then with a single
    key sequence
    the line is sent to the \stexttt{*R*} buffer for
    execution.  The output of the package goes directly to the
    editable \stexttt{*R*} buffer.}
  \label{f.ess-demo}
\end{figure}

\paragraph{Source-level Debugging}
ESS facilitates the editing of source code files, sets of commands
written for a statistical analysis package, and allows the user to
load and error-check small sections of source code into the package.
This is done through several mechanisms.  First, the presence of
unbalanced parentheses or mismatched/unterminated quotes is
immediately evident with syntactic highlighting of the source code.
Second, functions are provided for simple and consistent execution of
user-specified or natural units of the code (function definitions in S
or \XLispStat, \stexttt{PROC \dots RUN;} sections in \SAS).  An
error-free evaluation lets the user execute the next section of code;
if errors arise, the user edits the current unit and re-evaluates.
Once the code is verified, an entire buffer, or file, of code can be
sent to the package as a unit.  This file can also be used as a batch
file for routine analysis at a later time.  Finally, output from the
statistics package is normally captured directly by Emacs and placed
into a buffer from where it can be edited and searched.  Particular
forms of output such as requests for help pages and log-file output
can be diverted into special buffers with modes crafted to facilitate
reading.  These modes include tools for automatically placing the
cursor on the first \stexttt{ERROR}, for example in \SAS\ and S.

\paragraph{Interactive transcripts.}
A transcript records all commands entered by the analyst and the
corresponding text-based responses such as tables and comments
generated by the statistics package during an interactive statistical
analysis session.  Once a transcript file is generated, for example by
saving an \stexttt{iESS} buffer, \stexttt{transcript-mode} assists
with reuse of part or all of the entered commands.  ESS understands
the transcript's syntax, for both the underlying language and the
prompt patterns used during the interactive analysis.  ESS provides
tools to facilitate editing and re-evaluating the commands directly
from the saved transcript.  This is useful both for demonstration of
techniques and for reconstruction and auditing of data analyses.
Special ESS functions can ``clean'' S language transcripts by
isolating all input lines and placing them in a new S language source
file.  Transcript cleaning facilitates the use of an exploratory
interactive analysis session to construct functions and batch files
for routine analysis of similar data sets.

\paragraph{Remote access to statistics packages}
ESS provides reasonably transparent facilities for editing files and
running programs which might reside on numerous remote machines during the
same session.  The remote machine could be a very different platform
than the local machine.

\paragraph{Manipulating and Editing Objects (S).}
For languages in the S family, ESS provides object-name completion of
both user- and system-defined functions and data.  ESS can dump and
save objects (user- and system-generated) into formatted text files,
and reload them (possibly after editing).

\paragraph{Help File Editing (R).}
ESS provides R documentation mode (\stexttt{Rd-mode}), an interface
for writing help files for R functions, objects, and other topics
worth documenting.  \stexttt{Rd-mode} provides the ability to view and
execute S language code embedded in the help file in the same manner
as ESS handles code from an S language source file.  It provides
syntax highlighting and the ability to submit code directly to a
running ESS process, either R or \Splus.

\paragraph{Cooperation across Multiple Tools.}
Statistical packages are intended for either general statistical
analyses or for specialized forms of statistical analyses.  The
specialized statistical packages can be far more efficient for their
intended activities, but this is balanced by their inability to
perform a wide range of general statistical functions.  Tightly
coupled inter-operability between general and specialized packages
rarely exists, but such a facility is often desired.  For example, a
general purpose package such as R does not perform Bayesian analyses
as easily as BUGS does.  On the other hand, BUGS lacks breadth in the
range of analyses and results it can generate.  For this reason, BUGS
is often distributed with R packages, like CODA and BOA, for importing
and analyzing the results in R.  Another point of contention is the
difference in the interfaces between general packages and specialized
packages.  For example, the interfaces for BUGS and R are somewhat
similar, but there are enough differences to create confusion.  ESS
helps by providing a single point of contact to both tools, though the
interfaces (interactive for R, batch for BUGS) are slightly different.

%\begin{Comment}
%\begin{description}
% \item[Rodney:]  I think I see where we were going with this.  We would go on to
%say that ESS is here to help people solve this problem.  However,
%we can't say that ESS provides a uniform interface to BUGS and R because
%it doesn't.  I didn't know what the R interface was supposed to look like
%when I created \stexttt{ESS[BUGS]} so I modeled it on \stexttt{ESS[SAS]}.  Furthermore,
%\stexttt{ESS[SAS]} and \stexttt{ESS[R]} are very different by design, i.e. \stexttt{ESS[SAS]} was not
%designed like Emacs, but rather Display Manager.  I'm not sure how we can tell
%people that this is such a big advantage.  Maybe the above paragraph
%should talk about SAS and BUGS?  Comments welcome.

%\item[Martin:] I see. Actually, I think this is \textbf{really bad} to hear.
%  I thought people using BUGS would rather come from an S background
%  (R or S-Plus) rather than SAS, and I---as Tony seemed---naturally
%  assumed the BUGS interface would be close to the S one.

%  Wouldn't this even be something we should change?  Maybe we should find
%  out who is currently using ESS[BUGS] at all. It could be only very
%  people; since I know that most BUGS users use WinBUGS...

%\item[Rodney:]  I can't speak for everyone, but the BUGS users I know are
%pretty evenly divided between SAS and S.  OTOH, they are almost 
%unanimously opposed to WinBUGS and use batch BUGS nearly exclusively.
%I think it's because of their aversion to Windows since nearly all of
%them are Unix fanatics.  
%Having thought some more about this...  The reason that BUGS batch file
%processing is based on SAS batch file processing is \textbf{batch file processing}.
%In other words, BUGS and SAS probably have more in common operationally
%than BUGS and R/S do.  Of course, BUGS has an interactive mode, but that
%would only be of use in rare circumstances.  Maybe we should just have an 
%option to make the key sequence be SAS-like or R/S-like (what would that be 
%by the way?).  That way everyone should be happy and the above illustration
%will make sense.  Besides, the most pressing need for me is to get 
%ESS-elsewhere to work with ESS[BUGS] rather than creating inferior-BUGS.

%\item[Rich:] How does making ``ESS-elsewhere work with ESS[BUGS]'' differ
%from ``creating inferior-BUGS''?  My question is predicated on the assumption
%that ESS-elsewhere is a (generalized) minor-mode that makes the location
%of the program irrelevant.
%See my ESS-elsewhere quibble below.

%\item[Rodney:] It's the whole batch BUGS vs. interactive BUGS thing.  Batch 
%BUGS with ESS-elsewhere; interactive BUGS with inferior-BUGS which does not 
%and will never exist.  If you want to call ``inferior-ESS'' ``ESS-elsewhere'' 
%why do you need two different names?  ``inferior-ESS'' is a terrible name
%so the change would be fine with me, but you can't have it both ways?  Is
%this why you keep saying that ESS-elsewhere works for SAS?  See 
%response to quibble below.

%\item[Rich:]
%\stexttt{iESS[SAS]} was designed to mimic as well as possible \stexttt{iESS[S]}.
%I need to read doc/README.SAS to make sure all of its options are represented
%here. --- Not yet done.
%\end{description}
%\end{Comment}

\paragraph{Simplifying Keymap Differences.}
Simple conflicts between interfaces are exemplified by different
key sequences for editing tasks such as cut, copy, paste, beginning of
line, end of line, etc.  These may be the most aggravating because our
fingers are typing ``instinctively'', 
%without our brains having to specifically think about it, 
but differences in interfaces circumvent this learned
behavior.  ESS solves this problem by providing a uniform interface to
keyboard actions across the variety of statistical packages that
might be used.  That is, the same key sequences are used for cursor movement, 
evaluation, and basic tasks such as loading files for editing.


\paragraph{Concurrent Use of Multiple Machines and Operating Systems.}
It can be useful to have multiple statistical processes running
simultaneously, either on a single machine or a variety of machines.
This capability assists with large-scale numerical simulations 
as well as code design and testing across multiple
versions of statistical software packages.  
%For example, one might want to be connected to
%multiple R processes of different versions in order to verify behavior
%on different versions of the same software; multiple processes of the
%same version to perform test-and-run scenarios with a mix of long-term
%computation and short-run testing; simulation studies and extensions
%which distribute the load over a variety of remote machines.
%
% Rodney: I find these scenarios to be too obscure to be of much interest.
% the most relevant were already mentioned in the second sentence.

\subsection{Interactive Processing.}
\label{sec:interactive}

The increased popularity of exploratory data analysis as well as the
advent of simple GUIs has made interactive data analysis an important
component to statistical practices.  

\paragraph{S, \Splus, and R.}
The ESS mode for S language statistical processes, \stexttt{iESS[S]},
replaces the \Splus\ Commands window or the R GUI window.  In addition
to running the S language process, \stexttt{iESS[S]} mode provides the
same editing features, including syntactic highlighting and
string-search, as the editing mode \stexttt{ESS[S]}.  It also provides
an interactive history mechanism; transcript recording and editing;
and the ability to resubmit the contents of a multi-line command to
the executing process with a single keystroke.
% The statistical processes S and R are started by using the Emacs
% function call \stexttt{M-x~S} or \stexttt{M-x~R} on Unix or Windows
% and the call \stexttt{M-x~Sqpe} on Windows.

ESS uses two different approaches for communicating with the S
language program.  ESS runs packages that use the command-line interface
as an inferior process in an Emacs buffer,
%For S, \Splus, and R on Unix and for R and \stexttt{Sqpe} on Windows 
%(see below for more on \Splus\ for Windows and \stexttt{Sqpe}),
redirecting and controlling the standard input and output of the
package to the buffer.
% in the
%\stexttt{iESS[S]} buffer.  In 
%these cases the ESS commands \stexttt{M-x~S} on Unix,
%\stexttt{M-x~Sqpe} on Windows, and \stexttt{M-x~R} on both create a
%new \stexttt{iESS[S]} buffer and start the S language process inside
%that buffer.
%\begin{Comment} Rich: Martin, what do we do with R on Macintosh?\end{Comment}
%\begin{Comment} Rodney: If it is R for X11, then it's just like Unix.  
%Carbonized R is problematic at this time, so we should discourage it in 
%README.R  When things change, we can change with them.\end{Comment}
%\paragraph{\Splus\ for Windows.}
The GUI for \Splus\ 4 and 6 on Windows only runs independently of
Emacs and can not be cast in the role of an inferior process with
redirected input and output.
%Full GUI capability is available by
%switching to the \Splus\ window.  
ESS uses the Windows DDE (Dynamic Data Exchange) protocol to provide 
%, through a
%buffer in \stexttt{ddeESS} mode, for
one-way communication to the \Splus\ GUI process.  ESS sends commands
to the GUI process but can not capture
the results directly.
%  ESS can send commands to the GUI, but the printed output
%does not come back to an Emacs
%buffer.  Instead the output appears in the \Splus\ Commands Window.
Transcripts must be physically copied to an Emacs buffer to get the
transcript editing features.

There are two %strong 
advantages to using even this limited communication with the \Splus\ 
GUI through ESS.  First, the user gets the full editing capabilities
of Emacs.  Second, S language commands are sent from the Emacs buffer
directly to the GUI Commands window with the familiar Emacs
key sequences.  Hence the user can work in a powerful editing environment
and is protected from the delay and ergonomic challenges of using the
mouse for copy and paste operations across windows.

%In \Splus\ for Windows, the GUI
%talks to the computing engine and the user accesses the computing
%engine indirectly by interacting with the GUI.  ESS uses
%\stexttt{ddeESS} mode to send commands to the GUI but can't receive
%results back.

One useful extension in ESS is relaxation of the requirement that the
statistics program be available on the local machine.  ESS provides
both transparent editing of files and execution of statistics packages
on the remote machine, using the command \stexttt{S+elsewhere}.
% We open a remote
%connection to another machine (using telnet, rsh, or ssh) and then run
%S on the other machine with the output appearing in the local buffer.
%We use the command \stexttt{S+elsewhere} to place the buffer into
%\stexttt{iESS} mode.
%\begin{Comment}
%This isn't quite precise.  We currently create the S+elsewhere buffer
%first and then run telnet inside it.
%I want to write a new command \stexttt{ESS-remote} that does what
%I just described.  My timing sense suggests for ESS-5.1.21.
%\end{Comment}
All the editing and interaction features described for the local
machine work equally well on the remote machine.  The interaction,
including all the unique features of working with ESS, appears to the
user exactly the same as if the program were running on the local
machine.  If the X11 Windowing system is running on the local machine,
it is even possible to bring up visual displays and graphics from
remote Unix systems onto a local Microsoft Windows display.

%With \Splus\ on Unix, and with R on all platforms, the ESS buffer in
%\stexttt{iESS} mode talks directly to the computing engine, the
%program that does the statistical work.  Printed results appear in the
%\stexttt{iESS} buffer and interactive graphics appear in secondary
%windows controlled by the S language process.

%On Windows the ESS buffer in \stexttt{iESS} mode talks directly to
%\stexttt{Sqpe} for text input and output.  Interactive graphics and
%other GUI features are not available when we use \stexttt{iESS} mode
%(see the next section for interactive graphics on Windows).
%Static graphics, for instance by PostScript, are available.  In the
%near future, we anticipate that \Splus\ 6 will overcome the design
%limitations of Windows by using the \stexttt{connections} class of the
%new S4 engine.  We will then have both interactive graphics and transcript
%recording and editing on the Windows platform.

\paragraph{\SAS---Interactive in Emacs buffers.}

\stexttt{iESS[SAS]} is a mode that allows text-based \stexttt{PROC} by
\stexttt{PROC} interaction with an inferior buffer running an
interactive \SAS\ session on either the local or 
a remote computer.  \stexttt{iESS[SAS]} mode works by
redirecting standard input and output from \SAS\ to ESS.
%sending the \stexttt{-stdio} command-line option to the \stexttt{sas}
%command.
As of this writing, the \stexttt{iESS[SAS]} mode can run on any computer,
but the \SAS\ process it is controlling must be running  on a Unix machine.
%The user highlights a region (normally a \stexttt{PROC \dots\ RUN;}
%section) in the command file (\stexttt{myfile.sas} for convenience)
%and sends it over to \SAS\ with mapped key sequences.  The
%\stexttt{*SAS:1.log*} and \stexttt{*SAS:1.lst*} buffers immediately
%display the log and listing results from the commands.
%Graphics commands can be sent to a file, in PostScript for example,
%and viewed outside of this interaction. 
This process is very efficient for dial-up network connections to
a remote computer with \SAS\ installed.


%%%% AJR: WHY IS THIS SUBSTANTIALLY DIFFERENT THAN BATCH?  I KNOW ITS
%%%% SLIGHTLY DIFFERENT, BUT SUBSTANTIALLY?
%%%% rmh: this is a form of interaction, not batch.  I restored the
%%%% first paragraph with some expansion.
\paragraph{\SAS---Interactive cooperation with the \SAS\ Display Manager.}
ESS users who write data analysis code in \stexttt{ESS[SAS]} mode in Emacs
often need to work with the \SAS\ Display Manager's
mouse-based interface to the graphical
routines, the help system, and other non-text-based features.
%The authors of ESS prefer the Emacs environment for
%the text-file interaction with \SAS, that is with editing and
%managing input command files and output listing and log files,
%even on computer systems which run
%the \SAS\ Display Manager environment.
In this situation, the user
designs the command file in \stexttt{ESS[SAS]} mode and highlights
regions to be forwarded to \SAS\ for processing.
%
% Rodney: I don't see this as a feature of either ESS or emacs.  And,
% what the authors prefer is certainly not germane.
%
%
% rmh: This is my preferred mode for interacting with SAS.  I tried another
% rephrasing.  It {\it is} a feature of ESS.  ESS is able to provide ESS[SAS]
% mode for the text processing (.sas .lst. log files) and simultaneously
% let the user have interactive graphical access.

%This can be done by either:
%\begin{enumerate}
%\item copying and pasting the marked regions to the \SAS\ Editor window
%  and then pressing the \stexttt{RUN} button.  Highlighted sections of
%  the \SAS\ Listing window are brought back to Emacs to be read in the
%  \stexttt{ESSlst} mode editing environment.
%\item submitting the marked region for Batch File Processing (see the
%  next section) but using the mapped key sequences to append to the log
%  and listing files instead of replacing them.
%\end{enumerate}

\subsection{Batch File Processing.}
\label{sec:batch-file}

Exploratory data analysis is most often accomplished interactively.
But other situations exist for which interactive analyses are not
ideal. % processing with statistical analysis packages is very
%useful for .  However, there are situations
%for which it is not ideal.
Batch file processing with statistical analysis packages is a better
choice when the execution times are longer than the user is willing to
wait as well as for regularly updated reports and graphs based on 
statistical analyses.

\paragraph{\SAS.}
\label{sec:sas-batch}

\SAS\ is a popular choice for processing and analyzing large amounts
of data.  However, interactive \SAS\ is rarely used in these situations
due to the length of time involved.  Instead, a file containing \SAS\ 
commands is created and \SAS\ executes these commands in the background, 
or batch, while the user moves on to other activities.

ESS facilitates \SAS\ batch with \stexttt{ESS[SAS]}, the mode for files
with the \stexttt{sas} extension.  ESS defines \SAS\ syntax so that
\stexttt{font-lock-mode} can highlight statements, procedures,
functions, macros, datasets, comments and character string literals in
\SAS\ programs.  Optionally, the same language features are
highlighted in the \SAS\ log with the addition of log notes, warnings
and error messages.

For files with the \stexttt{sas} extension, ESS binds the function
keys in \stexttt{ESS[SAS]} mode to match the definitions used by \SAS\ 
Display Manager.  These definitions are optionally available in all
modes.   They are particularly useful when viewing \SAS\ log and \SAS\ listing
files (with extensions of \stexttt{log} and \stexttt{lst}
respectively).

Only one function key press is needed to submit a \SAS\ batch process.
Other function keys open the \SAS\ program, the \SAS\ log and the
\SAS\ listing buffers.  When accessed in this manner, the \SAS\ log and 
\SAS\ listing buffers are automatically updated since they may have 
been appended or over-written
%if they are being appended 
by the \SAS\ batch process.  In addition, the \SAS\ log is searched for error
messages and the error messages, if any, are sequentially displayed
with consecutive key presses.

Another function key opens a \SAS\ permanent dataset for editing or
viewing.  An option is provided so that the tab and return keys
operate in typewriter fashion like they do in \SAS\ Display Manager.
This option also defines a key to move the cursor to a previous
tab-stop and delete any characters between its present position and
the tab-stop.  This is a \SAS\ Display Manager feature that is not
typically available in Emacs.

The \SAS\ batch process runs on the computer where the \SAS\ program
resides.  If the \SAS\ program resides on a remote computer, then the
program, log and output are also accessed remotely.
%with one of the remote file modes.
%(\stexttt{ange-ftp}, \stexttt{EFS} and \stexttt{tramp}) or Kermit.
This is important because any \SAS\ permanent datasets referenced in a
\SAS\ program only exist on the computer running \SAS.
%\ program resides.  The 
%\SAS\ batch processes are submitted to the remote computer via ssh or
%telnet running in a \stexttt{shell-mode} buffer.  
Running \SAS\ batch on remote computers is nearly transparent to the
ESS user.

%\begin{Comment}
%Rich's version:
%\end{Comment}
%The \SAS\ batch process can run on the same computer on which the
%emacs session is running or it can run on a remote computer.  For
%remote jobs, files are transparently saved (with ftp or scp or kermit)
%and the batch process is transparently submitted through a telnet or
%ssh connection.

%\begin{Comment}
%Rich: I have some terminology quibbles here with how the term
%``ESS-elsewhere'' is used with SAS BATCH.  I think of S-elsewhere or
%ESS-elsewhere as a trick to make a \stexttt{telnet-mode} buffer think
%it is \stexttt{iESS-mode} buffer.

%I don't think of file saving, editing, and retrieval as an example
%of ESS-elsewhere.   Neither is submission of the remote job;
%that is just an ordinary shell command in an ordinary shell buffer.
%M-x SAS probably is an example of ESS-elsewhere, but I
%designed it before I thought of the ESS-elsewhere concept.

%The initial idea behind S-elsewhere was to run an interactive S or S-Plus
%session on a remote computer in telnet (or equivalent) buffer.  The trick
%was to make the \stexttt{telnet-mode} buffer accept C-c C-n and
%related commands from the \stexttt{S-mode} buffers.  Hence I had to
%make the \stexttt{telnet-mode} buffer think it is \stexttt{iESS-mode}
%buffer.  The ``elsewhere'' part of the name is entirely related to a
%different start up procedure.  Once the connection is made, there is
%{\em no} difference visible to the user.  The buffer shows itself to
%be an ordinary \stexttt{iESS} buffer.  Tony generalized S-elsewhere
%to ESS-elsewhere to allow other languages than S to be used
%interactively.

%I have been using ESS for SAS remote BATCH for years, ever since you
%and I started working on this together.  We initially defined
%ess-sas-submit-method to encapsulate the location of the sas process.
%Except for a few lines of elisp to get the connection started, the user
%behavior has been identical whether the SAS process is on the same or
%different machine.  Since we are not interactively talking to the SAS
%process in an inferior-ESS buffer I don't see this as ESS-elsewhere.

%Rodney: Remote submissions of SAS batch jobs never worked.  I only got
%it to work a couple of weeks ago.  The problem was with the cd command.
%You need to ignore the beginning and end of the expanded buffer name
%that are the ange-ftp/EFS/tramp stubs which tell Emacs what the remote
%username and hostname are.  I find the batch usage of ESS-elsewhere
%entirely consistent with the interactive behavior.  OTOH, I don't find 
%the terminology particularly illuminating.  I think ESS-remote or 
%ESS-net would be more meaningful. 
%\end{Comment}
 
\paragraph{BUGS.}
\label{sec:bugs-batch}
  
BUGS software performs Markov Chain Monte Carlo integration.  There is
an interactive capability, but it is not often used since the analyses
can take a long time.  Most BUGS programs are executed as batch
processes.

%Emacs and 
ESS facilitates BUGS %by \stexttt{ESS[BUGS]}, the mode in
%which files with the \stexttt{bug} extension are opened.  There are 
through 4 features.
% which ESS provides.  
First, BUGS syntax is described to allow for proper fontification
% so that \stexttt{font-lock-mode} can highlight 
of statements, distributions, functions, commands and comments in BUGS
model files, command files and log files.  Second, ESS creates
templates for the command file from the model file so that a BUGS
batch process can be defined by a single file.  Third, ESS provides
a BUGS batch script that allows ESS to set BUGS batch parameters.
Finally, key sequences are defined to create a command file and submit 
a BUGS batch process.

\paragraph{S, \Splus, and R.}
ESS provides 2 facilities for batch processing of S files.  The first
is to execute the contents of a file using buffer-evaluation.  This
differs from interactive processing only by the number of commands
being evaluated; errors can be found by examining the resulting
transcript.  The second is the load-source mechanism, which provides a
means of jumping to errors in the source file, but doesn't display the
evaluated commands in the transcript.  These mechanisms provide
different tools for debugging the source files.  Once the files are
debugged, all S implementations have a standard feature for batch
evaluation independent of ESS, \stexttt{S BATCH}.

\section{History of ESS}
\label{sec:ESS:history}

%(Emacs Speaks Statistics)
ESS is built on Emacs, the editing system for which Richard Stallman 
won a MacArthur Foundation Fellowship in 1990.  Emacs has a long history 
of being a programmer's editor.  Many statisticians got their first taste 
of the power of Emacs with \Fortran\ mode which was introduced in 1986.  
As statisticians' preferences changed from generalist compiled 
languages such as \Fortran\ to specialist interactive statistical analysis 
packages like S and \SAS, Emacs modes for them soon followed.

Doug Bates and Ed Kademan wrote S-mode in 1989 to edit S and \Splus\ files 
in GNU Emacs.  Frank Ritter and Mike Meyer added features, creating version 2.
Meyer and David Smith made further contributions, creating version 3.  David 
Smith provided process interaction changes for version 4.
%%David Smith was the next primary maintainer, and his most
%%important contribution was to enhance the \Splus\
%%command-line interface and allow for control of multiple processes
%%simultaneously.  

In 1990, John Sall authored GNU Emacs macros for \SAS\ source code 
editing.  Tom Cook wrote SAS-mode in 1994, partially basing it on 
Sall's earlier work.  

In 1994, A.J. Rossini extended S-mode to support XEmacs.  
Together with extensions written by Martin M{\"a}chler, this
became version 4.5.  In 1995, Rossini extended SAS-mode to work with XEmacs.
By 1996, S-mode was available for both GNU Emacs and XEmacs and supported 
S, \Splus, and R.  

In 1997, Rossini merged S-mode and SAS-mode into a single Emacs package 
for statistical programming; the product of this marriage was called ESS 
version 5.
%, along with additional changes to accommodate 
%multiple languages in a flexible way, 
%%Kurt Hornik was instrumental in enhancing support for R,
%%in particular, providing \stexttt{Rd-mode}.
Richard M. Heiberger designed the inferior mode for interactive \SAS\
and SAS-mode was 
further integrated into ESS.  More changes were made to support
additional statistical languages such as \Stata\ and \XLispStat.
% which were added to ESS's capabilitities.

ESS initially worked only with Unix statistics packages that
used standard-input and standard-output for both the command-line 
interface and batch processing.  ESS could not communicate with 
%Windows versions of 
statistical packages that did not use this protocol.  This changed in 1998 when
Brian Ripley demonstrated use of the Windows Dynamic Data Exchange (DDE)
protocol with ESS.
Heiberger then used DDE to provide interactive interfaces for Windows 
versions of \Splus.
In 1999, Rodney Sparapani and Heiberger implemented an ESS batch
system, which relies on files rather than
standard-input/standard-output, for \SAS\ on Unix, Windows and Mac.
In 2001, Sparapani added BUGS batch file processing to ESS for Unix
and Windows.

\begin{table}[tbp]
  \centering
  \begin{tabular}{c ll c ll}
\hline
    Year  \\ 
\hline
         & \multicolumn{2}{c}{S-mode}       && \multicolumn{2}{c}{SAS-mode} \\ 
\cline{2-3} \cline{5-6}
    1989 & v.1 & (GNU Emacs, Unix, S/S+)        &&  \\
    1990 &     &                            &&     & (GNU Emacs, Unix, SAS editing) \\
    1991 & v.2 & (GNU Emacs, Unix, S/S+)        && \\
    1993 & v.3 & (GNU Emacs, Unix, S/S+)        && \\
    1994 & v.4 & (GNU Emacs/XEmacs, Unix, S/S+) && v.1  & (GNU Emacs, Unix, SAS batch) \\
    1995 & v.4.7 & (GNU Emacs/XEmacs, Unix, S/S+/R) && v.2 & (GNU Emacs/XEmacs, Unix, SAS batch) \\
    \cline{2-6}\\[-3.5ex]
    \cline{2-6}
         & \multicolumn{5}{c}{ESS (Emacs Speaks Statistics)} \\
    \cline{2-6} 
         &\multicolumn{2}{c}{Emacs, Operating Systems} &&\multicolumn{2}{c}{Additional Functionality}\\
\cline{2-3} \cline{5-6}
    1997 & v.5.0 & (GNU Emacs/XEmacs, Unix)         &&&  Stata, XLispStat, SAS interactive \\
    1998 & v.5.1.1 & (GNU Emacs/XEmacs, Unix/Windows) &&&  S+elsewhere; Windows: S+/R\\
    1999 & v.5.1.10 & (GNU Emacs/XEmacs, Unix/Windows/Mac) &&& SAS batch; Omegahat \\
    2001 & v.5.1.19 & (GNU Emacs/XEmacs, Unix/Windows/Mac) &&& Unix/DOS: BUGS batch; Mac: R \\
%%    2002 & v.5.1.20 & (Emacs/XEmacs, Unix/Windows/Mac) &&& Unix/DOS: BUGS batch, Mac: R \\
%%    2002 & v.5.2 & (Emacs/XEmacs, Unix/Windows/Mac) &&& ? \\
\hline
  \end{tabular}
  \caption{History and Ancestors of ESS}
  \label{tab:timeline}
\end{table}

%  Based on this work, Heiberger provided interactive
%interfaces for Windows versions of \Splus.

%In 1998, Rodney Sparapani designed \SAS\ batch file processing for ESS
%on Unix, Windows and Mac.  In 1999 and 2000, Sparapani and Heiberger
%continually enhanced \SAS\ support. 
%In 2001 and 2002, they designed and implemented ESS-elsewhere for \SAS.  


This history is summarized in Table \ref{tab:timeline}.


\section{Future Work}

%%There are two active areas of extensions for user environments.  One
%%is to enhance the capabilities of the IDE for statistical practice;
%%this includes implementing such common IDE features as object
%%browsers, tool-tips, and interfacing cleaning.  The other is to target
%%appropriate potentially useful programming methodologies for transfer
%%to statistical practice.
%%
%%Literate Programming methodologies \citep{Knuth:1992,NRamsey:1994} are
%%a natural fit for statistical practice.  We refer to the application
%%to statistical analysis as Literate Statistical Practice
%%\citep{rossini:dsc:2001}.  The tools used are Noweb
%%\citep{NRamsey:1994} and either \LaTeX, \textsc{html}, or \textsc{xml}
%%for documenting and explaining the analysis.  This approach to
%%programming encourages the use of a literary documentation style to
%%explain the programming code for the data analysis.  The program can
%%then be extracted from the documentation text for realizing the
%%statistical analysis.

%future enhancement perhaps
%ESS provides the same ESS-elsewhere support for BUGS batch
%that it does for \SAS\ batch (see above).

Important extensions which should be implemented in future
versions include class browsers, analysis templates, tool-tips, and
similar features.  Class browsers can be thought of as a tree or
outline for presenting datasets, variables and functions in the
context of what they represent; this allows for rapid and appropriate
inspection.  Analysis templates would allow statistics centers and
groups to provide standardized templates for initiating an analysis.

Additional statistical packages can easily be added to ESS.

%%While most IDE features have been developed for object-oriented
%%languages, the above also can apply to non-object oriented
%%programming.

%ESS is one of the first  Rapid Application Development (RAD)
%environments intended for statisticians.  It provides


\section{Conclusion}
\label{sec:concl}

ESS provides an enhanced, powerful interface for efficient interactive
data analysis and statistical programming.  It allows the user
complete control over the communications among the files in which the
analysis is specified, the statistical process doing the computation,
and the output.  Because all are within the same programming
environment, and therefore are accessed with the same editing and
searching concepts and the same key sequences, user efficiency is
increased.  It is completely customizable to satisfy individual
desires for interface styles as well as being extensible to additional
statistical languages and analysis packages.

%\begin{Comment}
%Rich: see my discussion of ESS-elsewhere terminology.

%What is the behavior for remote SAS that is new for 2002?

%Rodney: SAS batch now works and Kermit was added as a method of transfer.
%\end{Comment}
%ESS-elsewhere provides interactive and batch processing
%with \SAS\ running on a remote machine that is accessed over a
%network.  This provides a powerful development environment for \SAS.

%%This
%%includes support for syntax highlighting and template-based source file
%%generation that provides the capability of specifying all the necessary
%%parameters for a BUGS batch run in a single file.

\bibliographystyle{plainnat}
%\pdfbookmark[1]{References}{section.7}
\addcontentsline {toc}{section}{\numberline {}References}
\bibliography{essJCGSv2}

\clearpage

\appendix 
\section{Appendix: ESS Resources on the Internet}
\addcontentsline {toc}{section}{\numberline {}ESS Resources on the Internet}
\label{sec:access}

\paragraph{Latest Version.}

ESS is constantly in flux.  New versions of statistical
packages, Emacs and operating systems require new releases of ESS to
support them.  The latest stable version of ESS can be found on the web at
\url{http://software.biostat.washington.edu/statsoft/ess/}.  To get help
with problems, send e-mail to \url{ess-help@stat.math.ethz.ch}.
The latest development, hence unstable, version can be obtained by
anonymous CVS.  First type:

\stexttt{cvs -d
  :pserver:anoncvs@software.biostat.washington.edu:/var/anoncvs login}
  
You will be prompted for a password which is ``\stexttt{anoncvs}''.
Then type:

\stexttt{cvs -d
  :pserver:anoncvs@software.biostat.washington.edu:/var/anoncvs co
  ess}

\paragraph{Additional documentation.} 

An expanded version of the present paper is in \citep{RMHHS:2001}.  A
general introduction and usage instructions can be found in
\citep{heiberger:dsc:2001}; in addition, one which is more focused on
\SAS\ can be found in \citep{heiberger:philasugi:2001}.  The
documentation that comes with ESS provides details of its
implementation as well as examples of its use.


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
