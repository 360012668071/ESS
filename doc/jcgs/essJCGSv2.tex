\documentclass{article}

\newif\ifdraft
% During writing: a draft:
%\drafttrue
% FINAL:
\draftfalse

\ifdraft  %% generate tableofcontents down to the \paragraph
\setcounter{tocdepth}{5}
\fi
%1. introduction
%        a) a statistician's needs
%        b) statistical analysis packages supported by ESS
%2. emacs -- a software developer's RAD
%        a) buffers
%        b) key-binding
%        c) modes
%                1) font-lock
%                2) shell/comint
%                3) ange-ftp/EFS/tramp
%                4) vc/pcl-cvs
%3. ESS -- a statistician's RAD 
%        a) interactive
%           1) S family
%           2) SAS
%        b) batch
%           1) SAS
%           2) BUGS
%           3) S family
%4. ESS as an open source project
%        a) origins
%                1)S-mode
%                2)SAS-mode
%        b) unification
%                1)ESS-mode
%                2)Emacs/XEmacs
%                3)Unix/Windows/Mac
%5. conclusion
%        a) summary
%        b) what's next for ESS
%   ESS internet resources
%        a) home page
%        b) ess-help
%        c) anonymous cvs
%   References
%
\ifdraft
 \addtolength{\topmargin}{-1cm}
 \addtolength{\textheight}{+1cm}
\else%FINAL:
 \renewcommand{\baselinestretch}{1.5}
\fi
\addtolength{\oddsidemargin}{-0.5in}
\addtolength{\textheight}{0.2in}
\addtolength{\textwidth}{1in}

%%%
\usepackage[authoryear,round]{natbib}
%or (if you have an unshiny latex installation)
%\newcommand{\citep}[1]{{\{\sf#1\}}}
%%%
\usepackage{alltt}

%% Postscript fonts
%\usepackage{times}
\usepackage{graphicx}

\ifx\pdfoutput\undefined
  %% Stuff wout hyperref
  \def\url#1{\stexttt{#1}} % To help fit in lines ?AJR: stextsf?
\else
  %% Stuff with hyperref
  \usepackage{hyperref}
  %%\hypersetup{backref,colorlinks=true,pagebackref=true,hyperindex=true}
  \hypersetup{backref,colorlinks=false,pagebackref=true,hyperindex=true}
\fi
%%---End of package requiring ---------- Own Definitions -------------

\newcommand*{\regstrd}{$^{\mbox{\scriptsize{\textregistered}}}$}
\newcommand*{\tm}{$^{\mbox{\scriptsize\sc tm}}$}
\newcommand*{\SAS}{\textsc{SAS}}
\newcommand*{\Splus}{\textsc{S-Plus}}
\newcommand*{\XLispStat}{\textsc{XLispStat}}
\newcommand*{\Stata}{\textsc{Stata}}
\newcommand*{\Rgui}{\textsc{Rgui}}
\newcommand*{\Perl}{\textsc{Perl}}
\newcommand*{\Fortran}{\textsc{Fortran}}
\newcommand*{\Scmt}[1]{\hbox{\qquad {\footnotesize \#\#} \textsl{#1}}}
\newtheorem{defn}{Definition}[section]
\newtheorem{ex}{Example}[section]

\newcommand{\stexttt}[1]{{\small\texttt{#1}}}
\newcommand{\ssf}[1]{{\small\sf{#1}}}
\newcommand{\elcode}[1]{\\{\stexttt{\hspace*{2em} #1}}\\}
\newcommand{\file}[1]{`\stexttt{#1}'}
\newcommand{\US}{{\char'137}}        % \tt _
\newcommand{\marpar}[1]{\marginpar{\raggedright#1}}
\newenvironment{Salltt}{\small\begin{alltt}}{\end{alltt}}

\newcommand{\emptyfig}{
\hspace*{42pt}\rule{324pt}{.25pt}\\
\hspace*{42pt}\rule{.25pt}{10pc}
\rule{316pt}{.25pt}
\rule{.25pt}{10pc}}

%% Use \begin{Comment} .. \end{Comment} for internal comments
\ifdraft
\newenvironment{Comment}{\begin{quote}\small\itshape }{\end{quote}}
%
\else  %% this requires
  \usepackage{verbatim}
  \let\Comment=\comment
  \let\endComment=\endcomment
\fi


%%--------------------------------------------------------------- Start Text

\title{Emacs Speaks Statistics (ESS): A multi-platform, multi-package
intelligent environment for statistical analysis}

\author{A.J. Rossini \and Martin M{\"a}chler \and Kurt Hornik \and Richard
  M. Heiberger \and Rodney Sparapani \footnote{%
%%
    A.J. Rossini is Research Assistant Professor in the Department of
    Biostatistics, University of Washington and Joint Assistant Member at
    the Fred Hutchinson Cancer Research Center, Seattle, WA, USA
    (E-mail: rossini@u.washington.edu);
%%
    Martin M{\"a}chler is Senior Scientist and Lecturer in the Seminar for
    Statistics, ETH Zurich, Zurich, Switzerland
    (E-mail: maechler@stat.math.ethz.ch);
%%
    Kurt Hornik is Professor in the Institut f{\"u}r Statistik,
    Wirtschaftsuniversit{\"a}t Wien and the Institut f{\"u}r
    Wahrscheinlichkeitstheorie und Statistik, Technische Universit{\"a}t
    Wien, Vienna, Austria (E-mail: Kurt.Hornik@r-project.org);
%%
    Richard M. Heiberger is Professor in the Department of Statistics at
    Temple University, Philadelphia, PA, USA (E-mail: rmh@temple.edu);
%%
    Rodney Sparapani is Senior Biostatistician in the Center for Patient
    Care and Outcomes Research at the Medical College of Wisconsin, 
    Milwaukee, WI, USA (E-mail: rsparapa@mcw.edu)}}

%%S\date{\today}
\date{$ $Date: 2002/01/31 03:54:02 $ - $Revision: 1.83 $ $\tiny printed \today}

\begin{document}

\ifdraft
\setcounter{page}{0}
%%\newpage
\tableofcontents
\fi

\maketitle

\ifdraft{}%% large line skip -- please not yet (MM)
\else%FINAL:
 \renewcommand{\baselinestretch}{1.5}
 %%- \baselineskip=2pc
\fi

\begin{abstract}
  Emacs Speaks Statistics (ESS) provides an intelligent user
  interface for statistical programming and data analysis that works
  the same way for a variety of statistical analysis packages on a
  variety of computer operating systems.  ESS is based on the Emacs
  text editor and programming environment and uses
% and provides a programming tool known as a Rapid
% Application Development (RAD) environment,
  many of its features to streamline the development and use of
  software applications.  We discuss how ESS works and how
% its advantages, and extensions for increasing
  it is used to increase statistical programming efficiency.
\end{abstract}

\noindent Keywords: Data Analysis, Programming, ESS, Emacs, S, \SAS,
\Splus, R, \XLispStat, \Stata, BUGS, free-software, open-source,
multi-platform, cross-platform


\section{Introduction}
\label{sec:introduction}

Statistical research activities, particularly data analysis and
communication, are complex processes that have many tasks in
common with software development.
%Software developers rely on Rapid Application Development (RAD)
%environments to assist them in the complex process of software
%development. 
These tasks include writing computer
code, project management and software reliability testing.  Most
contemporary statistical practice involves some form of computer use;
the daily tasks performed by an applied statistician are not
operationally different than those performed by software developers.
%Statistical research activities, particularly data analysis and
%communication, are enhanced by computers.
This puts the user
interface, which acts as a buffer between the statistician and
computer, in the critical role of facilitating or hindering these
tasks.  This paper introduces Emacs Speaks Statistics (ESS)
\citep{ESS}, a package designed to provide a common, intelligent
% of extensions to the Emacs text editor
% which provides a common interface across a variety of
% statistical analysis packages.  ESS
set of consistent shortcuts for frequent as well as complex tasks.

ESS is an interface to statistical packages, and provides,
through Emacs, additional tools which facilitate both statistical
software development and data analysis.  ESS currently supports
the S family of languages (which include
S \citep{BecRCW88,ChaJH92,ChaJ98}, \Splus\regstrd\ \citep{Splus}, and R
\citep{ihak:gent:1996}); \SAS\regstrd\ \citep{SAS:8}; \XLispStat\
\citep{Tier90} and its extensions Arc \citep{Cook:Weisberg:1999} and
ViSta \citep{youn:fald:mcfa:1992}; \Stata\ \citep{Stata:6.0}; Omegahat
\citep{DTLang:2000}; and BUGS \citep{BUGS}.  ESS can be
extended to accommodate most statistical packages which provide either
an interactive command-line or batch file processing.

The rest of the paper is as follows; we first describe the Emacs text
editor, the platform on which ESS is built.  Next, we discuss the
details of ESS and how it facilitates common statistical computing
activities.  The history ESS follows; ESS is unique as an open-source,
free-software project that has been passed down by multiple
generations of developers and has united various Emacs extensions
which support statistical language programming.  Finally, we conclude
with future extensions.

\section{Emacs}
\label{sec:emacs}

Emacs is a mature, powerful, and extensible text editing system which
is freely available under the GNU General Public License for a large
number of platforms, including most distributions of Unix\regstrd, Microsoft
Windows\regstrd\ and Apple Mac\tm\ OS.  There are two open-source
implementations of Emacs which are released for use under the GNU
General Public License: GNU Emacs \citep{GNU-Emacs} and XEmacs
\citep{XEmacs}.  Emacs shares many features with word processors, and
some characteristics with operating systems.  Most importantly, Emacs
can interact with and control other programs.

\paragraph{Keyboard and Mouse Interaction.}
When Emacs was originally written, character-based terminals with
keyboard entry were the most advanced method of computer access.
Common Emacs commands were mapped (or bound) to control-key sequences
for ease of use.  Over the last decade, Emacs has been extended to use
graphics-based windowing systems such as X11\tm, Microsoft Windows,
and Apple Mac OS.  These windowing systems provide a graphical user
interface (GUI) which allows the user to interact with either a
keyboard or a mouse, and encourage multiple applications to share a
single display.  Presently, Emacs is more often used in a windowing
environment within its own window, but command keymapping is still an
important time-saving feature.  Emacs menus and toolbars on the
display screen allow mouse access to frequently used actions and
provide a graphical alternative when the user does not know or can not
recall a keymap.  User-defined menus and toolbars can be constructed
as needed.

\paragraph{Buffers for Editing and for Program Control.}
Emacs provides facilities which go beyond ordinary text editing.  When
opening a file, Emacs can complete partially-typed file names by
referring to the operating system file directory.  The working copy of
the opened file is placed in an Emacs buffer where it can be viewed
and/or edited.  Buffers can be used for more than just editing text
files; for instance, they can be used for controlling other programs
or viewing the contents of a directory.  Buffers allow the user to simultaneously
edit multiple files and control multiple
programs simply by switching between buffers.  Frequently an operating
system interactive command line interpreter, called a shell,
is run inside a buffer; hence most programs can be run from a buffer
since most programs can be run from a command line.  When a command line
interpreter is run inside a buffer, the entire
transcript of the interaction is immediately editable and searchable while the
program is still running.

\paragraph{Major and Minor Modes.}
Emacs capabilities are extended by loading text files containing code
written in Emacs Lisp (elisp) \citep{RChassell1999}, a dialect of Lisp
\citep{PGraham:1996}.  Emacs commands, written in elisp,
can be called interactively either by name or by pressing their mapped key.
Emacs functions are also written in elisp, but they can only be called
by Emacs commands or other Emacs functions rather than by
name or mapped keys.  The most important extensions to Emacs are called
modes.

Major-modes provide two kinds of support.
First, they provide a customized environment (mapped keys and associated
commands) for specific file types.  Only one major-mode can be active
for a given buffer at any time.  The major-mode is often determined by
the file name extension, i.e. the characters at the end of the file
name that follow a period like \stexttt{txt}, \stexttt{R} or
\stexttt{sas}.
Examples of this kind of major-mode are \stexttt{ESS[S]} and \stexttt{ESS[SAS]}
(technically, both are special cases of \stexttt{ess-mode}).
Major-modes of this
kind provide automatic indentation and navigation in units of characters,
words, lines, sentences, paragraphs, and pages as well as many other
features.

Second, major modes provide the ability to run other programs.  In
this case, the other program's standard-input can be drawn from a
buffer or a file and its standard-output can be directed to a buffer
or a file.  Buffers of this kind can control programs that transfer
files over a network, perform version control operations or many other
tasks.  An important example of this kind of major-mode is
\stexttt{shell-mode} in which an ordinary command shell is run inside
a buffer.  ESS uses this type of major-mode to control statistical
packages.  Other major modes are \stexttt{telnet} mode for logging in
to a remote machine, either securely by running \stexttt{ssh} or
non-securely by running \stexttt{telnet}, and a directory editor mode
\stexttt{dired} that permits access to files (for viewing, editing,
and saving back) on the local or remote machine with equal ease.

Minor-modes, by contrast, provide services that are not mutually
exclusive.  For example, the minor-mode \stexttt{font-lock-mode}
allows Emacs to highlight, with fonts or colors, the syntax of a
programming language whose characteristics are described by a
major-mode like ESS.  \stexttt{overwrite-mode}, usually mapped to the
\ssf{Insert} key, determines whether typed characters replace the
existing text or push it to the right.  Minor modes can be used to
change the key mapping, for example to emulate the keys used by
another editor.  This is often used by people who want the power of
Emacs without having to retrain their fingers to use the standard
Emacs key mappings.


\paragraph{System Support.}
Emacs allows transparent access to remote files over a network.  
Transparent access means the user views, edits, and saves files on
a remote machine exactly as if they were on the local machine.
\stexttt{ange-ftp} and \stexttt{EFS} are used
for file transfers using the non-secure ftp protocol.
\stexttt{tramp} is used for file transfers using the secure scp protocol.
\stexttt{tramp} can also be used to transfer files without ftp or scp
via ssh for secure connections and telnet for non-secure connections.

Interacting with revision control programs is provided by the
minor-mode \stexttt{vc-mode} for packages like CVS, RCS, and SCCS (or
the more specialized \stexttt{pcl-cvs-mode} for CVS only).

Comparison of two files, for example successive drafts of a paper
by multiple authors, is simplified by \stexttt{ediff}, a visual 
way to browse simultaneously through
the differences between a pair (or a triple) of files or buffers.
An example is shown in Figure \ref{f.ediff}.  The lines that are similar
are highlighted in the two buffers, one for each file, and the specific
words that mismatch are highlighted in a contrasting color.
\stexttt{ediff} has many tools for working with the differences in
files and in entire directories.

\begin{figure}
\emptyfig
\caption[place holder for a long caption]{Ediff of two versions of a file.\\
{\it ediff-sas.gif}
\label{f.ediff}}
\end{figure}

\paragraph{Editing Extensions.}
Most programming and documentation tasks are basically text editing.
These tasks can be enhanced by %modes which provide features such as
contextual highlighting and recognition of special reserved words
appropriate to the programming language in use.  In addition, Emacs
also supports folding, outlining, and bookmarks which can assist with
maneuvering around a file.  Emacs shares many features with word
processing programs and cooperates with markup language based document
preparation systems such as \LaTeX, \textsc{html}, or \textsc{xml}.

\begin{Comment}
  AJR: Should we put these back in? i.e.   
  \begin{itemize}
  \item insertion and deletion;
  \item viewing two or more files at once;
  \item editing formatted text;
  \item visual comparison of two similar files;
  \item navigation in units of characters, words, lines, sentences,
    paragraphs, and pages.
  \end{itemize}

Rodney:  Let's see. 
\begin{itemize}  
\item viewing 2+ files:  handled in Buffers for Editing...
\item visual comparison of 2+ files:  handled in System Support
\item navigation in ...:  handled in Major and Minor Modes
\end{itemize}
Editing formatted text is what is alluded to by the last sentence 
in Editing Extensions, but a little clarification is warranted.  And,
insertion/deletion is superfluous since I don't know of any text
editors that don't provide that :o)

\end{Comment}

Emacs interfaces to the computer's directory structure to provide a
file-manager capability, and stores the command-history of editing
tasks.  Other extensions to Emacs allow it to act as a web browser, a
mail and news reader, and as an interface to other common text-based
tools such as spell checking programs.  The Emacs keyboard and mouse
interface can be re-mapped to resemble that of other text-editors,
such as vi, wordstar, and brief.  Emacs can also interface with speech
generation and recognition devices \textbf{(Cite: EmacSpeaks, AJR
  needs to add the reference)}.

For example, we can use syntax highlighting to help enforce company
coding standards.  Figure \ref{f.hilock} shows how to enforce a
standard for \SAS\ programming that says all \stexttt{PROC} statements
must use the \stexttt{DATA=datasetname} option.

\begin{figure}
\emptyfig
\caption[Enforce company coding standards.]{Enforce company coding
standards.  The standard here is that all \stexttt{PROC} statements must use
the \stexttt{DATA=datasetname} option.  Lines that satisfy the standard
turn green, lines that don't turn red.  Ambiguous ones turn yellow.\\
{\it hilock-sas.gif}
\label{f.hilock}}
\end{figure}


\section{ESS extends Emacs}
\label{sec:ess-extends-emacs}

Emacs' power and flexibility make it a sensible starting point for
building a statistical analysis interface.  ESS extends Emacs to
provide a functional, easily extensible and uniform interface for
multiple statistical packages.  This is done by first, adding
shortcuts and features for accelerated editing of files, and second,
by interacting with the statistical language through a number of
activities, both general input/output handling as well as specialized
parsing of help and evaluation assistance.

\begin{Comment}
AJR: THIS NEEDS WORK.\\
Rich: I now think the work has been done.
\end{Comment}

%This is done by extending the editor to provide
%additional useful features, and in the case of interactive statistical
%programs, sitting ``in front of'' their CLI and intercepting and
%modifying I/O as needed.  We describe the exact features more in this
%section.

%% change/edit
%Figure~\ref{fig:1} provides an example of how it looks when being used
%with XEmacs.  This screen-shot shows both SAS and R code being examined
%at the same time, with an R interactive process being controlled from
%within XEmacs.

%Figure~\ref{fig:2} shows ESS running in NTemacs 21.0 on Microsoft
%Windows 2000.  We are currently displaying 6 buffers.
%\stexttt{highlight.s} illustrates several uses of syntactic
%highlighting.  The most glaring one is the bright purple indicator for
%the unbalanced parentheses.  We also see color choices for keywords
%(\stexttt{if}), comments, and quoted strings.  The string on the last
%line was not properly terminated and we are immediately warned by the
%string color staying on through (what we think is) the end of the
%line.

%The two buffers \stexttt{transcript-before.st} and
%\stexttt{transcript-after.st} show transcript editing.  A single ESS
%command converted the before buffer into the after buffer by removing
%all lines that do not begin with a prompt character.

%The last three buffers show that a single S language source file can
%be used with two (or more) executing processes.  In this example we
%sent over first a subset of the line in \stexttt{tmps.s} and then the
%entire line to the instance of S+4 running in an inferior
%\stexttt{iESS(Sqpe)} buffer.  Then we switched the connection to send
%the same line to the instance of R running in the \stexttt{iESS(R)}
%buffer.  The dialog about the process switch appears in the message
%line.

\subsection{Features and capabilities}
\label{sec:ESS:features}

ESS strongly supports the S family (S, \Splus, and R).
\SAS\ is also well supported.  \Stata\
and \XLispStat\ (and the extensions, ARC and ViSta) are
supported with the basic functionality of syntax highlighting and
process-interfacing.  ESS and its interface are fully discussed in the
next section.

\paragraph{Syntactic highlighting and indentation of source code.}
The programmers task is eased when language constructs (such as
reserved words, function calls, strings, and comments) are visually
identifiable and when lines of code are automatically indented to a
depth appropriate to their context (e.g., if--then clauses, loops).
ESS provides both of these supports to the programmer by
including a description of the syntax of each
supported statistical language in the form used by the standard Emacs
\stexttt{font-lock-mode}.  

Figure \ref{f.font} shows a black-and-white example of font-locking a
complicated S statement.  Figure \ref{f.font}a shows an \stexttt{if}
statement with a long expression in the condition and a multi-line
consequence.  The keyword \stexttt{if} is shown in an underlined font,
the string \stexttt{"deltat"} in an italic underlined font.  The
comments are in an italic font.  Everything else is in the standard
font.  The consequence is indented and the continuations of the
consequence are further indented.  The matching parentheses are marked
by a bold foreground and a shaded background.  The cursor is indicated
by a solid box.  In Figure \ref{f.font}b we replaced the matching
parenthesis with an unbalanced bracket.  Emacs immediately marks that
with the paren-mismatch font, inverse-video here and bright purple on
a color terminal.

The font selection and the indentation depth are automatically
supplied by Emacs as the lines are typed.  The user has several
options for mapping of colors or fonts to each of the syntactic types.
We selected a black-and-white font-mapping for display here.  On a
terminal we might use blue for the keywords, red for comments, green
for matching parens.  Emacs makes default choices of colors and ESS
provides several other optional schemes.

\begin{figure}
a: balanced parentheses\\
\emptyfig

b: unbalanced parentheses\\
\emptyfig
\caption[Syntactic highlighting and indentation of source code.]
{We illustrate here with fonts and colors appropriate for a color display.
On a black and white terminal we would use bold, underline, italic,
and reverse-video.
% On a color terminal we would use a selection of colors.
\\
{\it a: font-cor-s.jpg; b: font-incor-s.jpg}
\label{f.font}}
\end{figure}

\paragraph{Source Code Checking and Partial Code Evaluation.}

ESS facilitates the editing of source code files, sets of commands
written in the package's language by the statistical analyst, by
providing a means for loading and error-checking small sections of
code.  This allows for source-level debugging of batch files.

ESS does this in several ways.
\begin{enumerate}
\item The simplest is by displaying the code with syntactic highlighting.
Unbalanced parentheses and mismatched or unterminated quotes are immediately
evident.

\item Next is by providing a simple and consistent way to submit
natural units of the code (function definitions in S or \XLispStat,
\stexttt{PROC \dots RUN;} sections in \SAS) for execution.
The relevant lines of the code are highlighted and sent over to the
executing statistical program by mapped key commands (saving the wrists
and elbows from the ergonomic strain of perpetually moving a mouse from
one window to another).  If they execute correctly, the user goes to the
next section of code.  If not, the user edits the current section and resends
the revised lines.

Emacs can send individual lines, entire function definitions, marked
regions, and whole buffers to the statistical analysis package for
execution.  Emacs sends the code directly to
the statistical package and receives the resulting output, if any,
immediately in an editable Emacs buffer.
This is a major improvement over cut-and-paste as it does
not require switching between buffers or windows.

\item
Output from the package is normally sent directly to an Emacs buffer.
There are several advantages to this destination.
There is no need to copy output from a static window into an
editable buffer; it is already there.
We can look for the
small section of output that is of immediate interest by using the
string-search key commands; there is no need to page through the
output until we see something we recognize.
If there are errors we
can use the search and edit facilities to investigate the cause of the
error.  When we are sending over a few lines at a time, we find
it very easy to localize the probable location of the error.
With \SAS\ log files, we automatically place the cursor
on the first \stexttt{ERROR}.

\item
An entire buffer, or file, of code can be sent to the package as a unit
once the code is clean.  The file can also be used as a batch file for
routine analysis at a later time.

\end{enumerate}


\paragraph{Process interaction.}
Emacs has historically referred to processes under its control as
``inferior'', accounting for the name inferior ESS (\stexttt{iESS}) to
denote the mode for interfacing with the statistical package.  The
output of the package goes directly to an editable text buffer in Emacs.
This mode allows for command-line editing and saving history, as well as
recalling and searching for previously entered commands.  Filename
completion is available.  In addition (currently only for S languages),
there exists object-name and function-name completion.

\paragraph{Interactive transcripts.}
A transcript is a complete record of all commands entered by the
analyst and all textual responses (tables and comments) produced by
the statistical program during an interactive statistical analysis
session.  ESS knows the structure of transcripts and therefore
provides tools, including syntactic highlighting, for interacting with
them.  Once a transcript file is generated, perhaps by saving an
\stexttt{iESS} buffer, \stexttt{transcript-mode} assists with reuse of
part or all of the entered commands.  It permits editing and
re-evaluating the commands directly from the saved transcript.  This
is useful both for demonstration of techniques and for reconstruction
and auditing of data analyses.  Special functions within ESS can
``clean'' S languages transcripts by finding all input lines and
isolating them into an S language source file.  Transcript cleaning
simplifies the use of an exploratory interactive analysis session for
the construction of an idealized source file, perhaps to be used
routinely in batch analyses of similar data sets.

\paragraph{Interacting with statistical programs on remote computers.}
ESS provides the facility to edit and run programs on remote machines
in the same session and with the same simplicity as if they were
running on the local machine.  The remote machine could be a very
different platform than the local machine.

\paragraph{Object name completion.}
For languages in the S family,
ESS provides object-name completion of both user- and
system-defined functions and data.  ESS can dump and save objects
(user- and system-generated) into formatted text files,
and reload them (possibly after editing).
%% back into the statistical language/program.

\paragraph{Help File Editing (R).}
ESS provides R documentation mode (\stexttt{Rd-mode}), an interface
for writing help files for R functions and packages.
\stexttt{Rd-mode} provides the ability to view and execute S language
code embedded in the help file in the same manner as ESS handles code
from an S language source file.  It provides syntax highlighting and
the ability to submit code directly to a running ESS process, either R or
\Splus.


%\subsection{ESS Facilitates Common Tasks}
%\label{sec:ess-facil-comm}

\paragraph{Cooperation across Multiple Tools.}
\label{sec:multiple-tools}

Statistical packages are intended for either general
statistical analyses or for specialized forms of statistical analyses.
The specialized statistical packages can be far more efficient for
specialized statistical analyses, but this is balanced by their inability
to perform a wide range of general statistical analyses.  Tightly coupled
inter-operability between general and specialized packages rarely exists,
but such a facility is often desired.  For example, a general purpose
package such as R does not perform Bayesian analyses as easily as BUGS does.
On the other hand, BUGS lacks breadth in the range of analyses and results
it can generate.  For this reason, BUGS is often distributed with R packages,
like CODA and BOA, for importing and analyzing the results in R.  Another
point of contention is the difference in the interfaces between general
packages and specialized packages.  For example, the interfaces for BUGS
and R are somewhat similar, but there are enough differences to create confusion.

\begin{Comment}
\begin{description}
 \item[Rodney:]  I think I see where we were going with this.  We would go on to
say that ESS is here to help people solve this problem.  However,
we can't say that ESS provides a uniform interface to BUGS and R because
it doesn't.  I didn't know what the R interface was supposed to look like
when I created \stexttt{ESS[BUGS]} so I modeled it on \stexttt{ESS[SAS]}.  Furthermore,
\stexttt{ESS[SAS]} and \stexttt{ESS[R]} are very different by design, i.e. \stexttt{ESS[SAS]} was not
designed like Emacs, but rather Display Manager.  I'm not sure how we can tell
people that this is such a big advantage.  Maybe the above paragraph
should talk about SAS and BUGS?  Comments welcome.

\item[Martin:] I see. Actually, I think this is \textbf{really bad} to hear.
  I thought people using BUGS would rather come from an S background
  (R or S-Plus) rather than SAS, and I---as Tony seemed---naturally
  assumed the BUGS interface would be close to the S one.

  Wouldn't this even be something we should change?  Maybe we should find
  out who is currently using ESS[BUGS] at all. It could be only very
  people; since I know that most BUGS users use WinBUGS...

\item[Rodney:]  I can't speak for everyone, but the BUGS users I know are
pretty evenly divided between SAS and S.  OTOH, they are almost 
unanimously opposed to WinBUGS and use batch BUGS nearly exclusively.
I think it's because of their aversion to Windows since nearly all of
them are Unix fanatics.  
Having thought some more about this...  The reason that BUGS batch file
processing is based on SAS batch file processing is \textbf{batch file processing}.
In other words, BUGS and SAS probably have more in common operationally
than BUGS and R/S do.  Of course, BUGS has an interactive mode, but that
would only be of use in rare circumstances.  Maybe we should just have an 
option to make the key-binding be SAS-like or R/S-like (what would that be 
by the way?).  That way everyone should be happy and the above illustration
will make sense.  Besides, the most pressing need for me is to get 
ESS-elsewhere to work with ESS[BUGS] rather than creating inferior-BUGS.

\item[Rich:] How does making ``ESS-elsewhere work with ESS[BUGS]'' differ
from ``creating inferior-BUGS''?  My question is predicated on the assumption
that ESS-elsewhere is a (generalized) minor-mode that makes the location
of the program irrelevant.
See my ESS-elsewhere quibble below.

\item[Rodney:] It's the whole batch BUGS vs. interactive BUGS thing.  Batch 
BUGS with ESS-elsewhere; interactive BUGS with inferior-BUGS which does not 
and will never exist.  If you want to call ``inferior-ESS'' ``ESS-elsewhere'' 
why do you need two different names?  ``inferior-ESS'' is a terrible name
so the change would be fine with me, but you can't have it both ways?  Is
this why you keep saying that ESS-elsewhere works for SAS?  See 
response to quibble below.

\item[Rich:]
\stexttt{iESS[SAS]} was designed to mimic as well as possible \stexttt{iESS[S]}.
I need to read doc/README.SAS to make sure all of its options are represented
here. --- Not yet done.
\end{description}
\end{Comment}

ESS is an extension package for
the Emacs editor which provides a single interface for a variety of
statistical computing tasks.  ESS is optimized for statistical programming
and interactive data analysis.  Statistical programming is the writing of
computer programs for data analysis and processing.  These programs might be
written in a computer language that requires as a compiler such as C or
\Fortran.  But, more likely, they are written in a  computer
language that only requires an interpreter such as R, \SAS\ or \XLispStat.
%%An interpreted language is executed by an interpreter, but a compiled language
%%must be processed by a compiler which creates an executable form of the
%%program that can be executed.  There is a trade-off in time between interpreted and compiled
%%programs.  For interpreted languages you save time by not having to compile
%%the program, but the program will not run as fast as if it had been compiled.
%%Another advantage of interpreted languages is the support they provide for
%%specialized tasks.  For example, C and \Fortran don't provide you with
%%the statistical analysis capabilities that R, \SAS\ or \XLispStat
%%do.  Compiled programs and interpreted programs can be used in conjunction.
%%For instance, a compiled C function could be called from an interpreted
%%language like R to speed up the calculations.
Entering commands for interactive data analysis is a similar activity.
In either case, text is written in a computer language and sent to a
computer program for evaluation.
%%The primary difference is that the
%%results of a small set of commands are of critical interest for review
%%in the analysis phase, but the results of all commands are of interest
%%in the coding phase.

\paragraph{Conflicts in keymappings.}
\label{sec:confl-keym}

Simple conflicts between interfaces are exemplified by different
keystrokes for editing tasks such as cut, copy, paste, beginning of
line, end of line, etc.  These may be the most aggravating
because our fingers are acting without our brains having to
specifically think about it, but differences in interfaces
circumvent this learned behavior.  ESS solves this problem by
providing a uniform keyboard interface.

Complex conflicts between interfaces can involve the coordination of
several data files, multiple statistical software packages, and the
corresponding source code in each of these languages, combined for a
single analysis.  ESS, as part of Emacs, has tools which assist in
this, including support for version and source code control systems,
tools for accessing programs or files on remote machines, and
interfaces to documentation systems including \LaTeX\ and
\textsc{xml}.  In addition, Emacs can assist with, or be programmed to
perform, many tasks related to data cleaning, management, and editing.


\paragraph{Concurrent Use of Multiple Machines and Operating Systems.}
\label{sec:conc-use-mult}

It can be useful to have multiple statistical processes running
simultaneously, either on a single machine or a variety of machines.
This capability assists with code design and testing across multiple
versions of statistical software packages, as well as large scale
numerical simulations.  For example, one might want to be connected to
multiple R processes of different versions in order to verify behavior
on different versions of the same software; multiple processes of the
same version to perform test-and-run scenarios where one process is
doing long-term processing while the other is doing short-term
testing; simulations; and to distribute the load over a variety of
remote machines.

\subsection{Interactive Processing.}
\label{sec:interactive}
\paragraph{S, \Splus, and R.}
\label{sec:S:inf}

The ESS interface with active S language statistical processes,
\stexttt{iESS[S]} mode, replaces the \Splus\ Commands window or the R
GUI window.
% is based on the Emacs shell-mode.
In addition to running the S language process, \stexttt{iESS[S]} mode
provides the same editing features, including syntactic highlighting
and string-search, as the editing mode \stexttt{ESS[S]}.  It also
provides an interactive history mechanism; transcript recording and
editing; and the ability to resubmit the contents of a multi-line
command to the executing process with a single keystroke.  The
statistical processes S and R are started by using the Emacs function
call \stexttt{M-x~S} or \stexttt{M-x~R} on Unix or Windows and the
call \stexttt{Sqpe} on Windows.

ESS uses two different protocols for communicating with the S language
program.  For S, \Splus, and R on Unix and for R and \stexttt{Sqpe} on Windows
(see below for more on \Splus\ for Windows and \stexttt{Sqpe}), ESS uses
standard-input/standard-output in the \stexttt{iESS[S]} buffer.  In
these cases the ESS commands \stexttt{M-x~S} on Unix,
\stexttt{M-x~Sqpe} on Windows, and \stexttt{M-x~R} on both create a
new \stexttt{iESS[S]} buffer and start the S language process inside
that buffer.

\begin{Comment} Rich: Martin, what do we do with R on Macintosh?\end{Comment}
\begin{Comment} Rodney: If it is R for X11, then it's just like Unix.  
Carbonized R is problematic at this time, so we should discourage it in 
README.R  When things change, we can change with them.\end{Comment}

One useful extension in ESS is relaxation of the requirement that the
statistics program be available on the local machine.  ESS provides
transparent execution of a statistics package on a remote machine from
within the local Emacs.  We open a telnet,
rlogin, or ssh connection to another machine
and then run S on the other machine in that buffer.  
We use the command \stexttt{S+elsewhere} to place the buffer into
\stexttt{iESS} mode.
\begin{Comment}
This isn't quite precise.  We currently create the S+elsewhere buffer
first and then run telnet inside it.
I want to write a new command \stexttt{ESS-remote} that does what
I just described.  My timing sense suggests for ESS-5.1.21.
\end{Comment}
All the editing and interaction features described for
the local machine work equally well on the remote machine.
The interaction,
including all the unique features of working with ESS, appears to the
user exactly the same as if the program were running on the local
machine.  With X-windows running on the local machine, it is even
possible to bring up visual displays from remote Unix systems on a
Windows local machine.

With \Splus\ on Unix and with R on all platforms the ESS buffer in
\stexttt{iESS} mode talks directly to the computing engine, the
program that does the statistical work.  Printed results appear in the
\stexttt{iESS} buffer and interactive graphics appear in secondary
windows controlled by the S language process.

On Windows the ESS buffer in \stexttt{iESS} mode talks directly to
\stexttt{Sqpe} for text input and output.  Interactive graphics and
other GUI features are not available when we use \stexttt{iESS} mode
(see the next section for interactive graphics on Windows).
Static graphics, for instance by PostScript, are available.  In the
near future, we anticipate that \Splus\ 6 will overcome the design
limitations of Windows by using the \stexttt{connections} class of the
new S4 engine.  We will then have both interactive graphics and transcript
recording and editing on the Windows platform.



\paragraph{\Splus\ for Windows.}
The GUI for \Splus\ 4 and 6 on Windows is independent of Emacs; it is not
an inferior process.  Full GUI
capability is available by switching to the \Splus\ window.
ESS uses the Windows DDE (Dynamic Data Exchange) protocol,
through a buffer in \stexttt{ddeESS} mode, for one-way communication with
the \Splus\ GUI.
ESS can send commands to the GUI, but the printed
output does not come back to an Emacs buffer.  Instead the output appears in
the \Splus\ Commands Window.  Transcripts must be physically copied to
an Emacs buffer to get the transcript editing features.

There are two strong advantages to using this limited communication
with the \Splus\ GUI through ESS.  First, the user gets the full
editing capabilities of Emacs.  Second, S language commands are sent
from the Emacs buffer directly to the GUI Commands window with the
familiar Emacs keystrokes.  Hence the user can work in a powerful
editing environment and is protected from the delay and ergonomic
challenges of using the mouse for copy and paste operations across
windows.

In \Splus\ for Windows, the GUI
talks to the computing engine and the user accesses the computing
engine indirectly by interacting with the GUI.  ESS uses
\stexttt{ddeESS} mode to send commands to the GUI but can't receive
results back.


\paragraph{\SAS---Interactive in Emacs buffers.}

\stexttt{iESS[SAS]} is a mode that allows text-based \stexttt{PROC} by
\stexttt{PROC} interaction with an inferior buffer running an
interactive \SAS\ session.  The \SAS\ session can be on either the
same computer or a remote computer.  \stexttt{iESS[SAS]} mode works by
sending the \stexttt{-stdio} command-line option to the \stexttt{sas}
command.  At this writing \SAS\ accepts the \stexttt{-stdio} option
only on Unix machines.

The user highlights a region (normally a \stexttt{PROC ... RUN;}
section) in the command file (\stexttt{myfile.sas} for convenience)
and sends it over to \SAS\ with mapped key commands.  The
\stexttt{*SAS:1.log*} and \stexttt{*SAS:1.lst*} buffers immediately
display the log and listing results from the commands.
Graphics commands can be sent to a file, in PostScript for example,
and viewed outside of this interaction.  This process is very efficient
for slow text-based telephone connections to a remote \SAS.


\paragraph{\SAS---Interactive cooperation with the \SAS\ Display Manager.}

The authors of ESS prefer the Emacs environment for editing and
managing input and output files, even on computer systems which run
the \SAS\ Display Manager environment.  In this situation, the user
designs the command file
and highlights regions to be forwarded to \SAS\ for processing.

This can be done by either:

a. copying and pasting the marked regions to
the \SAS\ Editor window and then pressing the \stexttt{RUN} key.
Highlighted sections of the \SAS\ Listing window are brought back
to Emacs to be read in the \stexttt{ESSlst} mode editing environment.

b. submitting the marked region for Batch File Processing (see the next
section) but using the mapped command keys to append to the log and listing
file instead of replacing them.

\subsection{Batch File Processing.}
\label{sec:batch-file}

Interactive processing with statistical analysis packages is very
useful for data analysis with descriptive statistics and graphics.
However, there are statistical programming situations for which it
is not ideal.  Batch file processing with statistical analysis
packages is a better choice when the time necessary for execution
is more than a few seconds such as processing and analyzing a
large amount of data.


\paragraph{\SAS.}
\label{sec:sas-batch}

For processing and analyzing large amounts of data, \SAS\ is a popular
choice.  However, interactive \SAS\ is rarely used in these situations.
Instead, a file containing \SAS\ commands is created and \SAS\ executes
these commands in the background, or batch, while the user moves on to 
other activities.

Emacs and ESS facilitate \SAS\ batch usage beginning
with \stexttt{ESS[SAS]},
the mode in which files with the \stexttt{sas} extension are opened.
ESS defines \SAS\ syntax so that \stexttt{font-lock-mode} can highlight
statements, procedures, functions, macros, datasets, comments and character 
string literals in \SAS\ programs.  Optionally, the same language features 
are highlighted in the \SAS\ log with the addition of log notes, warnings 
and error messages.

ESS maps the function keys in \stexttt{ESS[SAS]} mode, for files with the
\stexttt{sas} extension, to match the definitions used by \SAS\
Display Manager.  These definitions are optionally
available in all modes, which is particularly useful
while viewing \SAS\ log and \SAS\ listing files (with extensions of
\stexttt{log} and \stexttt{lst} respectively).

With one function key, you submit a \SAS\ batch process.  With others,
you move between the \SAS\ program, the \SAS\ log and the \SAS\
listing.  When accessed in this manner, the \SAS\ log and \SAS\
listing in the Emacs buffer are automatically updated to match the
files concurrently being appended by the \SAS\ batch process.  In
addition, the \SAS\ log is searched for error messages and the error
messages, if any, are sequentially displayed with consecutive key
presses.

Another function key opens a \SAS\ permanent dataset for editing or viewing.  
An option is provided so that the tab and return keys operate in typewriter 
fashion like they do in \SAS\ Display Manager.  This option also defines a 
key to move the cursor to a previous tab-stop and delete any 
characters between its present position and the tab-stop.  This is a \SAS\
Display Manager feature that is not available in Emacs otherwise. 

The \SAS\ batch process runs on the computer where the \SAS\ program
resides.  If the \SAS\ program resides on a remote computer, then the
program, log and output are accessed with one of the remote file modes
(\stexttt{ange-ftp}, \stexttt{EFS} and \stexttt{tramp}) or Kermit.
This is important because any \SAS\ permanent datasets referenced in a
\SAS\ program only exist on the computer where the \SAS\ program
resides.  The \SAS\ batch processes are submitted to the remote
computer via ssh or telnet running in a \stexttt{shell-mode} buffer.
Running \SAS\ batch on remote computers is nearly transparent to the user.

%\begin{Comment}
%Rich's version:
%\end{Comment}
%The \SAS\ batch process can run on the same computer on which the
%emacs session is running or it can run on a remote computer.  For
%remote jobs, files are transparently saved (with ftp or scp or kermit)
%and the batch process is transparently submitted through a telnet or
%ssh connection.

\begin{Comment}
Rich: I have some terminology quibbles here with how the term
``ESS-elsewhere'' is used with SAS BATCH.  I think of S-elsewhere or
ESS-elsewhere as a trick to make a \stexttt{telnet-mode} buffer think
it is \stexttt{iESS-mode} buffer.

I don't think of file saving, editing, and retrieval as an example
of ESS-elsewhere.   Neither is submission of the remote job;
that is just an ordinary shell command in an ordinary shell buffer.
M-x SAS probably is an example of ESS-elsewhere, but I
designed it before I thought of the ESS-elsewhere concept.

The initial idea behind S-elsewhere was to run an interactive S or S-Plus
session on a remote computer in telnet (or equivalent) buffer.  The trick
was to make the \stexttt{telnet-mode} buffer accept C-c C-n and
related commands from the \stexttt{S-mode} buffers.  Hence I had to
make the \stexttt{telnet-mode} buffer think it is \stexttt{iESS-mode}
buffer.  The ``elsewhere'' part of the name is entirely related to a
different start up procedure.  Once the connection is made, there is
{\em no} difference visible to the user.  The buffer shows itself to
be an ordinary \stexttt{iESS} buffer.  Tony generalized S-elsewhere
to ESS-elsewhere to allow other languages than S to be used
interactively.

I have been using ESS for SAS remote BATCH for years, ever since you
and I started working on this together.  We initially defined
ess-sas-submit-method to encapsulate the location of the sas process.
Except for a few lines of elisp to get the connection started, the user
behavior has been identical whether the SAS process is on the same or
different machine.  Since we are not interactively talking to the SAS
process in an inferior-ESS buffer I don't see this as ESS-elsewhere.

Rodney: Remote submissions of SAS batch jobs never worked.  I only got
it to work a couple of weeks ago.  The problem was with the cd command.
You need to ignore the beginning and end of the expanded buffer name
that are the ange-ftp/EFS/tramp stubs which tell Emacs what the remote
username and hostname are.  I find the batch usage of ESS-elsewhere
entirely consistent with the interactive behavior.  OTOH, I don't find 
the terminology particularly illuminating.  I think ESS-remote or 
ESS-net would be more meaningful. 
\end{Comment}
 
\paragraph{BUGS.}
\label{sec:bugs-batch}
  
BUGS software performs Markov Chain Monte Carlo simulations.  There is an 
interactive capability, but it is not often used since the number of iterations
in a typical analysis is large.
% and can be very time-consuming.
Most BUGS programs are executed as batch processes.

Emacs and ESS facilitate BUGS batch 
beginning with \stexttt{ESS[BUGS]},
% This RAD environment starts when you open a file with the 
the mode in which files with the \stexttt{bug} extension are opened.
ESS defines BUGS syntax so that \stexttt{font-lock-mode} can highlight
statements, distributions, functions, commands and comments in BUGS
model files, command files and log files.  ESS creates templates
for the command file from the model file so that a BUGS batch process
can be defined by a single file.
ESS provides a BUGS batch script that allows ESS to set BUGS batch 
parameters.  ESS also supplies key-mappings to submit a BUGS batch
process.  
%future enhancement perhaps
%ESS provides the same ESS-elsewhere support for BUGS batch
%that it does for \SAS\ batch (see above).

\paragraph{S, \Splus, and R.}
There are two ways to look at S Batch.  One is the traditional batch
approach in which a file of commands is submitted to \Splus\ or R from
the command line and the results are sent directly to a file.  For
this usage, the commands file is edited as usual in an \stexttt{ESS[S]}
buffer.  When it is ready, the batch job is submitted by switching to a
shell buffer and issuing a command.

The other approach is to use the ESS keys to send the entire buffer
(or the corresponding saved file) over to the interactive S process
running in either \stexttt{iESS[S]} or \stexttt{ddeESS[S]} mode and
letting the results appear in the \stexttt{ESS[S]} buffer or the
Commands Window.


\section{History of ESS}
\label{sec:ESS:history}

ESS is an example of how open-source projects can develop beyond what 
their initial authors planned.  To date, there have been 3 generations 
of developers.
%%and hopefully, there will be many more to come.
%%and the genealogy is more tree-like than linear.
There were 2 modes from which ESS descended:  S-mode and SAS-mode.

%% ESS originated as S-mode, which provided an interface for
%% programming and process control under GNU Emacs for \Splus\ version 3,
ESS began in 1989 as S-mode to provide extensions to GNU Emacs for editing 
S and \Splus\ files.  Version 1 was written by Doug Bates and Ed Kademan.  
This was extended by Frank Ritter and Mike Meyer to become version 2.  Meyer 
and David Smith made further contributions which was version 3.
%%This was written by Doug Bates, Ed Kademan, Frank Ritter, and
%%Mike Meyer.  David Smith was the next primary maintainer, and his most
%%important contribution was to enhance the \Splus\
%%command-line interface and allow for control of multiple processes
%%simultaneously.  
In 1995, A.J. Rossini extended S-mode to support XEmacs.  At the same time, 
extensions written by Martin M{\"a}chler, were incorporated into what became
version 4.  By 1996, S-mode was available for GNU Emacs and XEmacs and supported S, 
\Splus, and to some extent R.  Kurt Hornik was instrumental in enhancing support
for R.
%%, in particular, providing \stexttt{Rd-mode}.

The other ancestor of ESS is SAS-mode, written by Tom Cook, which began in 1994 
and was partially based on GNU Emacs macros written by John Sall.
%%\textbf{NEED TO GET DATES FROM AJR's ARCHIVE!?}.
Rossini extended SAS-mode to work with XEmacs in 1995, and this provided the
impetus for a single mode for statistical programming.
%%The extension to a language-independent, generic interface was further prompted
%%by the success of R and the desire for more complete R support.
This led to a merger of SAS-mode and S-mode along with changes
to accommodate multiple languages in a flexible way.  The product of this
marriage was called ESS version 5.

During 1996 and 1997, Richard M. Heiberger designed ``inferior'' ESS for \SAS.
At the same time, SAS-mode was further incorporated into ESS.

In 1997, more changes were made to facilitate
%% the grand redesign of the internals occurred, where by a generic
%% means for
support for additional statistical languages like \Stata\ and \XLispStat.

Most of the work, until 1998, was for Unix statistics
packages that used the standard-input/standard-output model of inter-process
communication for both the command-line interface and batch file
processing.  ESS could not communicate
with Windows versions of statistical packages that did not
use the standard-input/standard-output model.  This hurdle
fell in 1998 when Brian Ripley designed a way for ESS to use
the Windows technology of dynamic data exchange (DDE).
Based on this work, Heiberger provided interactive interfaces
for Windows versions of \Splus.

In 1998, Rodney Sparapani designed \SAS\ batch file processing for ESS
on Unix, Windows and Mac.  In 1999 and 2000, Sparapani and Heiberger
continually enhanced \SAS\ support. 
In 2001 and 2002, they designed and implemented ESS-elsewhere for \SAS.  

In 2001, Sparapani added BUGS batch file processing for ESS.

\begin{Comment}
Rich: see my discussion of ESS-elsewhere terminology.

What is the behavior for remote SAS that is new for 2002?

Rodney: SAS batch now works and Kermit was added as a method of transfer.
\end{Comment}
%ESS-elsewhere provides interactive and batch processing
%with \SAS\ running on a remote machine that is accessed over a
%network.  This provides a powerful development environment for \SAS.

%%This
%%includes support for syntax highlighting and template-based source file
%%generation that provides the capability of specifying all the necessary
%%parameters for a BUGS batch run in a single file.

\section{Extensions}
\label{sec:extensions}

%%There are two active areas of extensions for user environments.  One
%%is to enhance the capabilities of the IDE for statistical practice;
%%this includes implementing such common IDE features as object
%%browsers, tool-tips, and interfacing cleaning.  The other is to target
%%appropriate potentially useful programming methodologies for transfer
%%to statistical practice.
%%
%%Literate Programming methodologies \citep{Knuth:1992,NRamsey:1994} are
%%a natural fit for statistical practice.  We refer to the application
%%to statistical analysis as Literate Statistical Practice
%%\citep{rossini:dsc:2001}.  The tools used are Noweb
%%\citep{NRamsey:1994} and either \LaTeX, \textsc{html}, or \textsc{xml}
%%for documenting and explaining the analysis.  This approach to
%%programming encourages the use of a literary documentation style to
%%explain the programming code for the data analysis.  The program can
%%then be extracted from the documentation text for realizing the
%%statistical analysis.

Important extensions which should be implemented in future
versions include class browsers, analysis templates, tool-tips, and
similar features.  Class browsers can be thought of as a tree or
outline for presenting datasets, variables and functions in the
context of what they represent; this allows for rapid and appropriate
inspection.  Analysis templates would allow statistics centers and
groups to provide standardized templates for initiating an analysis.
%%While most IDE features have been developed for object-oriented
%%languages, the above also can apply to non-object oriented
%%programming.

ESS is one of the first  Rapid Application Development (RAD)
environments intended for statisticians.  It provides
an enhanced, powerful interface for efficient interactive data
analysis and statistical programming.  
It allows the user complete control over the communications among the
files in which the analysis is specified, the statistical process doing
the computation, and the output.  Because all are within the same programming
environment, and therefore are accessed with the same
editing and searching concepts and keystrokes, user efficiency is increased.
It is completely customizable
to satisfy individual desires for interface styles as well as being
extensible to additional statistical languages and analysis packages.


\section*{ESS Resources on the Internet}
\addcontentsline {toc}{section}{\numberline {}ESS Resources on the Internet}
\label{sec:access}
\paragraph{Latest Version.}
ESS is constantly in flux.  New versions of statistical
packages, Emacs and operating systems require new releases of ESS to
support them.  The latest stable version of ESS can be found on the web at
\url{http://software.biostat.washington.edu/statsoft/ess/}.  To get help
with problems, send e-mail to \url{ess-help@stat.math.ethz.ch}.
The latest development, hence unstable, version can be obtained by
anonymous CVS.  First type:

  \stexttt{cvs -d :pserver:anoncvs@software.biostat.washington.edu:/var/anoncvs login}

  You will be prompted for a password which is ``\stexttt{anoncvs}''.  Then type: 

  \stexttt{cvs -d :pserver:anoncvs@software.biostat.washington.edu:/var/anoncvs co ess}
  

\paragraph{Additional documentation.} An expanded version of
the present paper is in
\citep{RMHHS:2001}.  A general introduction and usage instructions can
be found in \citep{heiberger:dsc:2001}; in addition, one which is more
focused on SAS can be found in \citep{heiberger:philasugi:2001}.  The
documentation that comes with ESS provides details of its
implementation as well as examples of its use.


\bibliographystyle{plainnat}
%\pdfbookmark[1]{References}{section.7}
\addcontentsline {toc}{section}{\numberline {}References}
\bibliography{essJCGSv2}


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
