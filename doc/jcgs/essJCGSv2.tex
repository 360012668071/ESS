\documentclass{article}

\newif\ifdraft
% During writing: a draft:
\drafttrue
% FINAL:
%\draftfalse

%1.  a statistician's dream environment
%2.  what emacs has to offer
%        a) buffers
%        b) key-binding
%        c) other packages
%                1) font-lock
%                2) shell/comint
%                3) ange-ftp/EFS/Tramp
%3. what ESS has to offer
%        1) font-lock/key-binding/other packages revisited
%        2) statistical process interaction
%                a) interactive
%                        1) R/S
%                        2) SAS
%                b) batch
%                        1) SAS
%                        2) BUGS
%4. ESS as an open source project
%        1) early days
%                a)S-mode
%                b)SAS-mode
%        2) transition
%                a)ESS-mode
%                b)Emacs/XEmacs
%        3) modern era
%                a)GPL, cvs, ssh
%                 b)ESS 6, the next generation?

\ifdraft
 \addtolength{\topmargin}{-1cm}
 \addtolength{\textheight}{+1cm}
\else%FINAL:
 \renewcommand{\baselinestretch}{1.5}
\fi
\addtolength{\oddsidemargin}{-0.5in}
\addtolength{\textheight}{0.2in}
\addtolength{\textwidth}{1in}

%%%
\usepackage[authoryear,round]{natbib}
%or (if you have an unshiny latex installation)
%\newcommand{\citep}[1]{{\{\sf#1\}}}
%%%
\usepackage{alltt}

%% Postscript fonts
%\usepackage{times}
\usepackage{graphicx}

\ifx\pdfoutput\undefined
  %% Stuff wout hyperref
  \def\url#1{\textsf{#1}} % To help fit in lines
\else
  %% Stuff with hyperref
  \usepackage{hyperref}
  %%\hypersetup{backref,colorlinks=true,pagebackref=true,hyperindex=true}
  \hypersetup{backref,colorlinks=false,pagebackref=true,hyperindex=true}
\fi
%%---End of package requiring ---------- Own Definitions -------------

\newcommand*{\SAS}{\textsc{SAS}$^{\mbox{\scriptsize{\textregistered}}}$}
\newcommand*{\Splus}{\textsc{S-Plus}}
\newcommand*{\XLispStat}{\textsc{XLispStat}}
\newcommand*{\Stata}{\textsc{Stata}}
\newcommand*{\Rgui}{\textsc{Rgui}}
\newcommand*{\Perl}{\textsc{Perl}}
\newcommand*{\Fortran}{\textsc{Fortran}}
\newcommand*{\Scmt}[1]{\hbox{\qquad {\footnotesize \#\#} \textsl{#1}}}
\newtheorem{defn}{Definition}[section]
\newtheorem{ex}{Example}[section]

\newcommand{\stexttt}[1]{{\small\texttt{#1}}}
\newcommand{\ssf}[1]{{\small\sf{#1}}}
\newcommand{\elcode}[1]{\\{\stexttt{\hspace*{2em} #1}}\\}
\newcommand{\file}[1]{`\stexttt{#1}'}
\newcommand{\US}{{\char'137}}        % \tt _
\newcommand{\marpar}[1]{\marginpar{\raggedright#1}}
\newenvironment{Salltt}{\small\begin{alltt}}{\end{alltt}}

\newcommand{\emptyfig}{
\hspace*{42pt}\rule{324pt}{.25pt}\\
\hspace*{42pt}\rule{.25pt}{10pc}
\rule{316pt}{.25pt}
\rule{.25pt}{10pc}}

%% Use \begin{Comment} .. \end{Comment} for internal comments
\ifdraft
\newenvironment{Comment}{\begin{quote}\small\itshape }{\end{quote}}
%
\else  %% this requires
  \usepackage{verbatim}
  \let\Comment=\comment
  \let\endComment=\endcomment
\fi

%%--------------------------------------------------------------- Start Text

\title{Emacs Speaks Statistics:  A Rapid Application Development (RAD)
  Environment for Statistical Analysis Packages}

\author{A.J. Rossini \and Martin M{\"a}chler \and Kurt Hornik \and Richard
  M. Heiberger \and Rodney Sparapani \footnote{%
%%
    A.J. Rossini is Research Assistant Professor in the Department of
    Biostatistics, University of Washington and Joint Assistant Member at
    the Fred Hutchinson Cancer Research Center, Seattle, WA, USA
    (E-mail: rossini@u.washington.edu);
%%
    Martin M{\"a}chler is Senior Scientist and Lecturer in the Seminar for
    Statistics, ETH Zurich, Zurich, Switzerland
    (E-mail: maechler@stat.math.ethz.ch);
%%
    Kurt Hornik is Professor in the Institut f{\"u}r Statistik,
    Wirtschaftsuniversit{\"a}t Wien and the Institut f{\"u}r
    Wahrscheinlichkeitstheorie und Statistik, Technische Universit{\"a}t
    Wien, Vienna, Austria (E-mail: Kurt.Hornik@r-project.org);
%%
    Richard M. Heiberger is Professor in the Department of Statistics at
    Temple University, Philadelphia, PA, USA (E-mail: rmh@temple.edu);
%%
    and Rodney Sparapani is Senior Biostatistician at the Medical College
    of Wisconsin, Milwaukee, WI, USA (E-mail: rsparapa@mcw.edu)}}

%%S\date{\today}
\date{$ $Date: 2002/01/10 22:22:22 $ - $Revision: 1.44 $ $\tiny printed \today}

\begin{document}

\maketitle

\ifdraft{}%% large line skip -- please not yet (MM)
\else%FINAL:
 \renewcommand{\baselinestretch}{1.5}
 %%- \baselineskip=2pc
\fi

\begin{abstract}
  Emacs Speaks Statistics (ESS) provides a user interface for
  statistical programming and data analysis for a variety
  of statistical analysis packages.  ESS
  is based on the Emacs text editing environment and is a member of
  the programming tools category of Rapid Application
  Development (RAD) environments, which aid in developing
  computer applications.  We discuss how it works, why one
  would use it, and additional extensions for increasing
  statistical programming efficiency.
\end{abstract}

\noindent Keywords: Data Analysis, Programming, Emacs, S, \SAS,
\Splus, R, \XLispStat, \Stata, BUGS


\section{Introduction}
\label{sec:introduction}

Software developers rely on Rapid Application Development (RAD)
environments to assist them in the complex process of software
development which includes the varied tasks of computer
programming, project management and software testing.
Common tasks faced by a statistician are not much different from those
faced by software developers, since much statistical
activity involves some form of computer use.  Many
statistical research activities, particularly data analysis and
communication, are enhanced by computers.  This puts the user
interface, which acts as a buffer between the statistician and
computer, in the critical role of facilitating or hindering these
tasks.  This paper introduces Emacs Speaks Statistics (ESS) \citep{ESS},
an interface to a variety of statistical analysis packages that
provides consistent shortcuts for frequently performed, possibly complex, tasks.
ESS is %% constructed as 
a package of extensions to the Emacs text editing system.

\begin{Comment}
AJR:
 Does it make sense to add an additional paragraph on "history of
statistical interfaces from programming it yourself to command line
(SPSS/SAS/BDMP in the 80s), to spreadsheet-style interfaces
(spreadsheets, AND minitab, spss now, etc), etc?  This would be the
2nd paragraph, if so.

Rodney:
I don't think so.
AFAIC, anyone who wants to use ESS will not need to know
that per se.  They will just need to know what works today.

Rich: I think we don't want to get caught in the commandline vs spreadsheet
vs GUI discussion.  ESS can work with any of them.

Rich: Also the reference to (Rossini et al., 2001b) talks about that.

AJR: Settled, as far as I am concerned.
\end{Comment}

ESS provides an interface to statistical packages, and provides,
through Emacs, additional tools which facilitate both statistical
software development and data analysis.  ESS currently supports
the S family of languages (which include
S \citep{BecRCW88,ChaJH92,ChaJ98}, \Splus{} \citep{Splus}, and R
\citep{ihak:gent:1996}); \SAS\ \citep{SAS:8}; \XLispStat\
\citep{Tier90} and its extensions Arc \citep{Cook:Weisberg:1999} and
ViSta \citep{youn:fald:mcfa:1992}; \Stata\ \citep{Stata:6.0}; Omegahat
\citep{DTLang:2000}; and BUGS \citep{BUGS}.  ESS can be
extended to accommodate most statistical packages which provide either
an interactive command-line or batch file processing.

\begin{Comment}
  Rich: What is going on with the underlining?  Any reference that spans
two lines in the dvi file has no underlining in the first line, and then the
entire second line is underlined as a unit.

AJR: what tools are you using?  I don't see this, currently (I suspect
it was related in the past to the use of the hyperref package, but I
still don't recall seeing this in DVI files, just PS/PDF stuff).
\end{Comment}

The present paper summarizes historical and non-technical information on
Emacs and ESS.  A more complete version is in \citep{RMHHS:2001}.
A general introduction and usage instructions can be
found in \citep{heiberger:dsc:2001}.
An introduction for a SAS-oriented audience is in
\citep{heiberger:philasugi:2001}.  The documentation that comes with
ESS provides details of its implementation and examples of its use.
We first describe the Emacs text editor, the platform on which ESS is
built.  That is followed by the details of ESS and how it facilitates
common statistical computing activities.  We then describe the unique
history that ESS has had as an open-source, free-software project.
It has been passed down by generations of developers and has
united various Emacs packages which support
statistical languages and programming.  Finally, we conclude with
future tasks and extensions.

\section{Emacs}
\label{sec:emacs}

Emacs is a mature, powerful, and extensible text editing system which
is freely available under the GNU General Public License for a large
number of platforms, including most flavors of Unix, Microsoft Windows
and Apple Macintosh.  There are two open-source, free-software
implementations of Emacs:  GNU Emacs \citep{GNU-Emacs} and XEmacs
\citep{XEmacs}.  Emacs shares many features with
word processors, and some characteristics with operating systems.
Most importantly, Emacs can interact with and control other programs.

\paragraph{Keyboard and Mouse Interaction.}
When Emacs was originally written, character-based terminals with only
a keyboard for input were the most advanced method of access to
computers.  Common Emacs commands were mapped (or bound) to control-key
sequences for ease of use.  These days, Emacs is
rarely used within a terminal or terminal-emulator, but key-mapping of
commands is still an important time-saving feature.  Over the last
decade, Emacs has been extended to use graphics-based windowing
systems such as X11, Microsoft Windows, and Apple Macintosh.  These
windowing systems provide a graphical user interface (GUI) which
allows the user to interact with either a keyboard or a mouse, and encourage
multiple applications to share a single display.  Emacs menus and
toolbars on the display screen allow mouse access to frequently used
actions and provide a graphical alternative
when the user doesn't know or can't remember a key-mapping.  User-defined
menus and toolbars can be constructed as needed.

\paragraph{Buffers for Editing and for Program Control.}
Emacs provides facilities which go beyond ordinary text editing.  When
opening a file, Emacs can complete partially-typed file names by
referring to the operating system file directory.  The working copy of
the opened file is placed in an Emacs buffer where it can be viewed
and/or edited.  Buffers can be used for more than just editing text
files; for instance, they can be used for controlling other programs
or viewing the contents of a directory.  Buffers allow the user to simultaneously
edit multiple files and control multiple
programs simply by switching between buffers.  Frequently an operating
system interactive command line interpreter, called a shell,
is run inside a buffer; hence most programs can be run from a buffer
since most programs can be run from a command line.  When a command line
interpreter is run inside a buffer, the entire
transcript of the interaction is immediately editable and searchable while the
program is still running.

\paragraph{Major and Minor Modes.}
Emacs capabilities are extended by loading text files containing code
written in Emacs Lisp (elisp) \citep{RChassell1999}, a dialect of Lisp
\citep{PGraham:1996}.  Emacs commands, written in elisp,
can be called interactively either by name or by pressing their mapped key.
Emacs functions are also written in elisp, but they can only be called
by Emacs commands or other Emacs functions rather than by
name or mapped keys.  The most important extensions to Emacs are called
modes.

Major-modes provide two kinds of support.
First, they provide a customized environment (mapped keys and associated
commands) for specific file types.  Only one major-mode can be active
for a given buffer at any time.  The major-mode is often determined by
the file name extension, i.e. the characters at the end of the file
name that follow a period like \stexttt{txt}, \stexttt{R} or
\stexttt{sas}.
Examples of this kind of major-mode are \stexttt{ESS[S]} and \stexttt{ESS[SAS]}
(technically, both are special cases of \stexttt{ess-mode}).
Major-modes of this
kind provide automatic indentation and navigation in units of characters,
words, lines, sentences, paragraphs, and pages as well as many other
features.

Second, major modes provide the ability to run other programs.  In
this case, the other program's standard input can be drawn from a
buffer or a file and its standard output can be directed to a buffer
or a file.  Buffers of this kind can control programs that transfer
files over a network, perform version control operations or many other
tasks.  An important example of this kind of major-mode is
\stexttt{shell-mode} in which an ordinary command shell is run inside
a buffer.  ESS uses this type of major-mode to control statistical
packages.  Other major modes are \stexttt{telnet} mode for logging in
to a remote machine, either securely by running \stexttt{ssh} or
non-securely by running \stexttt{telnet}, and a directory editor mode
\stexttt{dired} that permits access to files (for viewing, editing,
and saving back) on the local or remote machine with equal ease.

Minor-modes, by contrast, provide services that are not mutually
exclusive.  For example, the minor-mode \stexttt{font-lock-mode}
allows Emacs to highlight, with fonts or colors, the syntax of a
programming language whose characteristics are described by a
major-mode like ESS.  \stexttt{overwrite-mode}, usually mapped to the
\ssf{Insert} key, determines whether typed characters replace the
existing text or push it to the right.  Minor modes can be used to
change the key mapping, for example to emulate the keys used by
another editor.  This is often used by people who want the power of
emacs without having to retrain their fingers to use the standard
emacs key mappings.


\paragraph{System Support.}
Emacs allows transparent access to remote files and
shells over a network.  \stexttt{ange-ftp} or \stexttt{EFS} are used
for non-secure file transfers between machines using ftp.
\stexttt{tramp} is used for secure file transfers using scp.
Transparent access means the user views, edits, and saves any file on
a remote machine exactly as if it were on the local machine.
\stexttt{tramp} is also used for logging in to a remote shell, both
for secure connections via ssh and non-secure connections via telnet.

Interacting with revision control
programs is provided by the minor-mode \stexttt{vc-mode} for packages
like CVS, RCS and SCCS (or the more
specialized \stexttt{pcl-cvs-mode} for CVS only).

Comparison of two files, for example successive drafts of a paper
by multiple authors, is simplified by \stexttt{ediff}, a visual 
way to browse simultaneously through
the differences between a pair (or a triple) of files or buffers.
An example is shown in Figure \ref{f.ediff}.  The lines that are similar
are highlighted in the two buffers, one for each file, and the specific
words that mismatch are highlighted in a contrasting color.
\stexttt{ediff} has many tools for working with the differences in
files and in entire directories.

\begin{figure}
\emptyfig
\caption[place holder for a long caption]{Ediff of two versions of a file.\\
{\it ediff-sas.gif}
\label{f.ediff}}
\end{figure}





\paragraph{Extensions to Editing.}
Most programming and documentation tasks fall under the realm of text
editing.  This work can be enhanced by modes which provide features
such as contextual highlighting and recognition of special reserved
words appropriate to the programming language in use.  Emacs supports
folding, outlining, and bookmarks which can assist with maneuvering
around a file.  Emacs shares many features with word processing
programs and cooperates with document preparation systems which use
markup languages such as \LaTeX\ , \textsc{html}, or \textsc{xml}.
%for hypertext markup.
%XSLT, and Noweb.  and Typesetting word processing, which
%focus on the presentation of a document, are tasks that are not pure
%text-editing.

%insertion and deletion: viewing two or more files at once; editing formatted text;
%visual comparison of two similar files; and navigation
%in units of characters, words, lines, sentences, paragraphs, and pages.

Emacs handles the interface to both source code and transcripts
contextually, providing syntax highlighting, bookmarking features,
interfaces to directory structure, and command-history.  Other
extensions to Emacs allow it to act as a World-Wide-Web browser, a
mail and news reader, and as an interface to other common text-based
tools such as spell checking programs.  The Emacs keyboard and mouse
interface can be re-mapped to resemble that of other text-editors,
such as vi, wordstar, and brief.

We can use syntax highlighting to help enforce company coding
standards.  Figure \ref{f.hilock} shows how to enforce a standard for
\SAS\ programming that says all \stexttt{PROC} statements must have a
\stexttt{DATA=datasetname} statement attached.

\begin{figure}
\emptyfig
\caption[place holder for a long caption]{Enforce company coding
standards.  The standard here is that all \stexttt{PROC} statements must have
a \stexttt{DATA=datasetname} statement attached.  Lines that satisfy the standard
turn green, lines that don't turn red.  Ambiguous ones turn yellow.\\
{\it hilock-sas.gif}
\label{f.hilock}}
\end{figure}


\section{ESS extends Emacs}
\label{sec:ess-extends-emacs}

Emacs' power and flexibility make it a sensible starting choice to
build an interface for statistical analysis packages.  ESS extends
Emacs to provide a functional, easily extensible and uniform interface
for multiple statistical packages.  This is done in two ways.  First,
shortcuts and features for accelerated editing of files have been
implemented.  Second, interaction with the statistical
language is split by function; general, obtaining help, programming.

\begin{Comment}
AJR: THIS NEEDS WORK.
\end{Comment}

%This is done by extending the editor to provide
%additional useful features, and in the case of interactive statistical
%programs, sitting ``in front of'' their CLI and intercepting and
%modifying I/O as needed.  We describe the exact features more in this
%section.

%% change/edit
%Figure~\ref{fig:1} provides an example of how it looks when being used
%with XEmacs.  This screen-shot shows both SAS and R code being examined
%at the same time, with an R interactive process being controlled from
%within XEmacs.

%Figure~\ref{fig:2} shows ESS running in NTemacs 21.0 on Microsoft
%Windows 2000.  We are currently displaying 6 buffers.
%\stexttt{highlight.s} illustrates several uses of syntactic
%highlighting.  The most glaring one is the bright purple indicator for
%the unbalanced parentheses.  We also see color choices for keywords
%(\stexttt{if}), comments, and quoted strings.  The string on the last
%line was not properly terminated and we are immediately warned by the
%string color staying on through (what we think is) the end of the
%line.

%The two buffers \stexttt{transcript-before.st} and
%\stexttt{transcript-after.st} show transcript editing.  A single ESS
%command converted the before buffer into the after buffer by removing
%all lines that do not begin with a prompt character.

%The last three buffers show that a single S language source file can
%be used with two (or more) executing processes.  In this example we
%sent over first a subset of the line in \stexttt{tmps.s} and then the
%entire line to the instance of S+4 running in an inferior
%\stexttt{iESS(Sqpe)} buffer.  Then we switched the connection to send
%the same line to the instance of R running in the \stexttt{iESS(R)}
%buffer.  The dialog about the process switch appears in the message
%line.

\subsection{Features and capabilities}
\label{sec:ESS:features}

ESS strongly supports the S family (S, \Splus, and R).
\SAS\ is also well supported.  \Stata\
and \XLispStat\ (and the \XLispStat\ extensions, ARC and ViSta) are
supported with the basic functionality of syntax highlighting and
process-interfacing.  ESS and its interface are fully discussed in the
next section.

\paragraph{Syntactic highlighting and indentation of source code.}
The programmers task is eased when language constructs (such as
reserved words, function calls, strings, and comments) are visually
identifiable and when lines of code are automatically indented to a
depth appropriate to their context (e.g., if--then clauses, loops).
ESS provides both of these supports to the programmer by
including a description of the syntax of each
supported statistical language in the form used by the standard Emacs
\stexttt{font-lock-mode}.  

Figure \ref{f.font} shows a black-and-white example of font-locking a
complicated S statement.  Figure \ref{f.font}a shows an \stexttt{if}
statement with a long expression in the condition and a multi-line
consequence.  The keyword \stexttt{if} is shown in an underlined font,
the string \stexttt{"deltat"} in an italic underlined font.  The
comments are in an italic font.  Everything else is in the standard
font.  The consequence is indented and the continuations of the
consequence are further indented.  The matching parentheses are marked
by a bold foreground and a shaded background.  The cursor is indicated
by a solid box.  In Figure \ref{f.font}b we replaced the matching
parenthesis with an unbalanced bracket.  Emacs immediately marks that
with the paren-mismatch font, inverse-video here and bright purple on
a color terminal.

The font selection and the indentation depth are automatically
supplied by Emacs as the lines are typed.  The user has several
options for mapping of colors or fonts to each of the syntactic types.
We selected a black-and-white font-mapping for display here.  On a
terminal we might use blue for the keywords, red for comments, green
for matching parens.  Emacs makes default choices of colors and ESS
provides several other optional schemes.

\begin{figure}
a: balanced parentheses\\
\emptyfig

b: unbalanced parentheses\\
\emptyfig
\caption[place holder for a long caption]{Syntactic highlighting and
indentation of source code.  We illustrate here with fonts and colors
appropriate for black and white display.  On a color terminal we would
use a selection of colors.\\
{\it a: font-cor-s.gif; b: font-incor-s.gif}
\label{f.font}}
\end{figure}

\paragraph{Source Code Checking and Partial Code Evaluation.}

ESS facilitates the editing of source code files, sets of commands
written in the package's language by the statistical analyst, by
providing a means for loading and error-checking small sections of
code.  This allows for source-level debugging of batch files.

ESS does this in several ways.
\begin{enumerate}
\item The simplest is by displaying the code with syntactic highlighting.
Unbalanced parentheses and mismatched or unterminated quotes are immediately
evident.

\item Next is by providing a simple and consistent way to submit
natural units of the code (function definitions in S or \XLispStat,
\stexttt{PROC \dots RUN;} sections in \SAS) for execution.
The relevant lines of the code are highlighted and sent over to the
executing statistical program by keystroke commands (saving the wrists
and elbows from the ergonomic strain of perpetually moving a mouse from
one window to another).  If they execute correctly, the user goes to the
next section of code.  If not, the user edits the current section and resends
the revised lines.

Emacs can send individual lines, entire function definitions, marked
regions, and whole buffers to the statistical analysis package for
execution.  Emacs sends the code directly to
the statistical package and receives the output, if any, which is
the result.  The response is received immediately in an editable Emacs buffer.
This is a major improvement over cut-and-paste as it does
not require switching between buffers or windows.

\item
Output from the package normally sent directly to an Emacs buffer.
There are several advantages to this destination.  We can look for the
small section of output that is of immediate interest by using the
string-search key commands; there is no need to page through the
output until we see something we recognize.  If there are errors we
can use the search and edit facilities to investigate the cause of the
error.  When we are sending over a few lines at a time, we find
it very easy to localize the probably location of the error.
There is no need to copy output from a static window into an
editable buffer; it is already there.

\item
An entire buffer, or file, of code can be sent to the package as a unit
once the code is clean.  The file can also be used as a batch file for
routine analysis at a later time.

\end{enumerate}


\paragraph{Process interaction.}
Emacs has historically referred to processes under its control as
``inferior'', accounting for the name inferior ESS (\stexttt{iESS}) to
denote the mode for interfacing with the statistical package.  The
output of the package goes directly to an editable text buffer in Emacs.
This mode allows for command-line editing and saving history, as well as
recalling and searching for previously entered commands.  Filename
completion is available.  In addition (currently only for S languages),
there exists object-name and function-name completion.


\paragraph{Interactive transcripts.}

%% AJR: removed since it's ``solved''.
%%\begin{Comment}
%% Rodney:  we need a short description of transcript-mode

%% \begin{trivlist}\item
%%   \emph{\small outcommented -- made visible (by MM) here}\\
%%   Transcripts are easily recorded and can be edited into an ideal activity
%%   log which can then be saved.
%% \end{trivlist}

%% Martin: I don't understand what you mean. Is the paragraph below too long
%% and you want to shorten it?

%% Rodney: I think it's fine now.  Thanks.
%%\end{Comment}

ESS can create transcripts, a recording of the commands issued in an
interactive session with a statistical analysis package.
%%ESS interacts well with the
%%executing statistics language/program and
ESS provides means for searching
the command-line history for previous commands and editing them for
reuse.  ESS knows the structure of transcripts and provides
syntactic highlighting for them.
Once a transcript file is generated, perhaps by saving an \stexttt{iESS}
buffer, transcript-mode assists with reuse of part or all of the
entered commands.  It permits editing and re-evaluating the commands
directly from the saved transcript.  This is useful for
demonstration of techniques as well as for reconstruction of data
analyses.  There currently exist functions within ESS for cleaning
transcripts from S languages back to source code by finding all input
lines and isolating them into an input file.



\paragraph{Interacting with statistical programs on remote computers.}
ESS provides the facility to edit and run programs on remote machines
in the same session and with the same simplicity as if they were
running on the local machine.  The remote machine could be a very
different platform than the local machine.

\paragraph{Object name completion.}
For languages in the S family,
ESS provides object-name completion of both user- and
system-defined functions and data.  ESS can dump and save objects
(user- and system-generated) into text files in a formatted manner for
editing, and reload them (possibly after editing).
%% back into the statistical language/program.

\paragraph{Help File Editing (R).}
ESS provides an interface for writing help files for R functions
and packages.  It provides the ability to view and execute embedded R
source code directly from the help file in the same manner as ESS
normally handles code from a source file.  \stexttt{Rd} mode provides
syntax highlighting and the ability to submit code to a running ESS
process, either R or \Splus.


\subsection{ESS Facilitates Common Tasks}
\label{sec:ess-facil-comm}

\paragraph{Multiple Tools.}
\label{sec:multiple-tools}

Basically, statistical packages are either intended for general
statistical analyses or more specialized forms of statistical analyses.
The specialized statistical packages can be far more efficient for
specialized statistical analyses, but this is balanced by their inability
to perform a wide range of general statistical analyses.  Tightly coupled
inter-operability between general and specialized packages rarely exists,
but such a facility is often desired.  For example, a general purpose
package such as R does not perform Bayesian analyses as easily as BUGS does.
On the other hand, BUGS lacks breadth in the range of analyses and results
it can generate.  For this reason, BUGS is often distributed with R packages,
like CODA and BOA, for importing and analyzing the results in R.  Another
point of contention is the difference in the interfaces between general
packages and specialized packages.  For example, the interfaces for BUGS
and R are somewhat similar, but there are enough differences to create confusion.

\begin{Comment}
\begin{description}
 \item[Rodney:]  I think I see where we were going with this.  We would go on to
say that ESS is here to help people solve this problem.  However,
we can't say that ESS provides a uniform interface to BUGS and R because
it doesn't.  I didn't know what the R interface was supposed to look like
when I created ESS[BUGS] so I modeled it on ESS[SAS].  Furthermore,
ESS[SAS] and ESS[R] are very different by design, i.e. ESS[SAS] was not
designed like emacs, but rather Display Manager.  I'm not sure how we can tell
people that this is such a big advantage.  Maybe the above paragraph
should talk about SAS and BUGS?  Comments welcome.

\item[Martin:] I see. Actually, I think this is \textbf{really bad} to hear.
  I thought people using BUGS would rather come from an S background
  (R or S-plus) rather than SAS, and I -- as Tony seemed -- naturally
  assumed the BUGS interface would be close to the S one.

  Wouldn't this even be something we should change?  Maybe we should find
  out who is currently using ESS[BUGS] at all. It could be only very
  people; since I know that most BUGS users use WinBUGS...

\item[Rodney:]  I can't speak for everyone, but the BUGS users I know are
pretty evenly divided between SAS and S.  OTOH, they are almost 
unanimously opposed to WinBUGS and use batch BUGS nearly exclusively.
I think it's because of their aversion to Windows since nearly all of
them are Unix fanatics.  
Having thought some more about this...  The reason that BUGS batch file
processing is based on SAS batch file processing is \textbf{batch file processing}.
In other words, BUGS and SAS probably have more in common operationally
than BUGS and R/S do.  Of course, BUGS has an interactive mode, but that
would only be of use in rare circumstances.  Maybe we should just have an 
option to make the key-binding be SAS-like or R/S-like (what would that be 
by the way?).  That way everyone should be happy and the above illustration
will make sense.  Besides, the most pressing need for me is to get 
ESS-elsewhere to work with ESS[BUGS] rather than creating inferior-BUGS.
\end{description}
\end{Comment}

ESS is an extension package for
the Emacs editor which provides a single interface for a variety of
statistical computing tasks.  ESS is optimized for statistical programming
and interactive data analysis.  Statistical programming is the writing of
computer programs for data analysis and processing.  These programs might be
written in a computer language that requires as a compiler such as C or
\Fortran.  But, more likely, they are written in a  computer
language that only requires an interpreter such as R, \SAS\ or \XLispStat.
%%An interpreted language is executed by an interpreter, but a compiled language
%%must be processed by a compiler which creates an executable form of the
%%program that can be executed.  There is a trade-off in time between interpreted and compiled
%%programs.  For interpreted languages you save time by not having to compile
%%the program, but the program will not run as fast as if it had been compiled.
%%Another advantage of interpreted languages is the support they provide for
%%specialized tasks.  For example, C and \Fortran don't provide you with
%%the statistical analysis capabilities that R, \SAS\ or \XLispStat
%%do.  Compiled programs and interpreted programs can be used in conjunction.
%%For instance, a compiled C function could be called from an interpreted
%%language like R to speed up the calculations.
Entering commands for interactive data analysis is a similar activity.
In either case, text is written in a computer language and sent to a
computer program for evaluation.
%%The primary difference is that the
%%results of a small set of commands are of critical interest for review
%%in the analysis phase, but the results of all commands are of interest
%%in the coding phase.

\paragraph{Conflicts in keymappings.}
\label{sec:confl-keym}

Simple conflicts between interfaces are exemplified by different
keystrokes for editing tasks such as cut, copy, paste, beginning of
line, end of line, etc.  These may be the most aggravating
because our fingers are acting without our brains having to
specifically think about it, but differences in interfaces
circumvent this learned behavior.  ESS solves this problem by
providing a uniform keyboard interface.

Complex conflicts between interfaces can involve the coordination of
several data files, multiple statistical software packages, and the
corresponding source code in each of these languages, combined for a
single analysis.  ESS, as part of Emacs, has tools which assist in
this, including support for version and source code control systems,
tools for accessing programs or files on remote machines, and
interfaces to documentation systems including \LaTeX\ and
\textsc{xml}.  In addition, Emacs can assist with, or be programmed to
perform, many tasks related to data cleaning, management, and editing.


\paragraph{Concurrent Use of Multiple Machines and Operating Systems.}
\label{sec:conc-use-mult}

It can be useful to have multiple statistical processes running
simultaneously, either on a single machine or a variety of machines.
This capability assists with code design and testing across multiple
versions of statistical software packages, as well as large scale
numerical simulations.  For example, one might want to be connected to
multiple R processes of different versions in order to verify behavior
on different versions of the same software; multiple processes of the
same version to perform test-and-run scenarios where one process is
doing long-term processing while the other is doing short-term
testing; simulations; and to distribute the load over a variety of
remote machines.

\section{History of ESS}
\label{sec:ESS:history}

ESS is an example of how open-source products can continue to
develop beyond what their initial authors planned.  To date, there have been 3
generations of developers and hopefully, there will be many more to come.
%%and the genealogy is more tree-like than linear.
There were 2 modes from which ESS descended:  S-mode and SAS-mode.

%% ESS originated as S-mode, which provided an interface for
%% programming and process control under GNU Emacs for \Splus\ version 3,
ESS began in 1989 as S-mode to
provide extensions to GNU Emacs for editing S and \Splus{} files.  This
was written by Doug Bates, Ed Kademan, Frank Ritter, and
Mike Meyer.  David Smith was the next primary maintainer, and his most
important contribution was to enhance the \Splus{}
command-line interface and allow for control of multiple processes
simultaneously.  In 1995, A.J. Rossini extended S-mode to support
XEmacs.  At the same time, extensions written by Martin M{\"a}chler, were incorporated.
By 1996, S-mode was available for GNU Emacs and XEmacs and supported S, \Splus, and
to some extent R.  Kurt Hornik was instrumental in enhancing support
for R, in particular, providing Rd mode.

The other ancestor of ESS is SAS-mode,
written by Tom Cook, which began in 1994 and was partially based on
GNU Emacs macros written by John Sall.
%%\textbf{NEED TO GET DATES FROM AJR's ARCHIVE!?}.
Rossini extended SAS-mode to work with
XEmacs in 1995, and this provided the
impetus for a single mode for statistical programming.
%%The extension to a language-independent,
%%generic interface was further prompted
%%by the success of R and the desire for more complete R support.
This led to a merger of SAS-mode and S-mode along with changes
to accommodate multiple languages in a flexible way.

During 1996 and 1997, Richard M. Heiberger designed ``inferior'' ESS
for \SAS, a mode that allows text-based \stexttt{PROC} by
\stexttt{PROC} interaction with an inferior buffer running an interactive SAS
session either on the same computer or a remote computer over a network.
At the same time, SAS-mode was further incorporated into ESS.

In 1997, more changes were made to facilitate
%% the grand redesign of the internals occurred, where by a generic
%% means for
adding support for additional statistical languages like \Stata\ and
\XLispStat.

Most of the work, until 1998, was for Unix statistics
packages that used the standard-input/standard-output model of inter-process
communication for both the command-line interface and batch file
processing.  ESS could not communicate
with Windows versions of statistical packages that did not
use the standard-input/standard-output model.  This hurdle
fell in 1998 when Brian Ripley designed a way for ESS to use
the Windows technology of dynamic data exchange (DDE).
Based on this work, Heiberger provided interactive interfaces
for Windows versions of \Splus.

In 1998, Rodney Sparapani designed \SAS\ batch file processing for ESS
on Unix, Windows and Macintosh.
Sparapani and Heiberger developed \SAS\ batch support including function
key behavior which mimics the \SAS\ Display Manager,
a more comprehensive and efficient syntax highlighting scheme for \SAS\
programs and logs, and automated and intelligent error message searching
of the log.  In 2001 and 2002, they designed and implemented ESS-elsewhere
for \SAS.  ESS-elsewhere provides interactive and batch processing
with \SAS\ running on a remote machine that is accessed over a
network.
% This provides a powerful development environment for \SAS.

In 2001, Sparapani added BUGS batch file processing for ESS.  This
includes support for syntax highlighting and template-based source file
generation that provides the capability of specifying all the necessary
parameters for a BUGS batch run in a single file.

\section{Discussion}
\label{sec:discussion}


%%There are two active areas of extensions for user environments.  One
%%is to enhance the capabilities of the IDE for statistical practice;
%%this includes implementing such common IDE features as object
%%browsers, tool-tips, and interfacing cleaning.  The other is to target
%%appropriate potentially useful programming methodologies for transfer
%%to statistical practice.
%%
%%Literate Programming methodologies \citep{Knuth:1992,NRamsey:1994} are
%%a natural fit for statistical practice.  We refer to the application
%%to statistical analysis as Literate Statistical Practice
%%\citep{rossini:dsc:2001}.  The tools used are Noweb
%%\citep{NRamsey:1994} and either \LaTeX, \textsc{html}, or \textsc{xml}
%%for documenting and explaining the analysis.  This approach to
%%programming encourages the use of a literary documentation style to
%%explain the programming code for the data analysis.  The program can
%%then be extracted from the documentation text for realizing the
%%statistical analysis.

Important extensions which should be implemented in future
versions include class browsers, analysis templates, tool-tips, and
similar features.  Class browsers can be thought of as a tree or
outline for presenting datasets, variables and functions in the
context of what they represent; this allows for rapid and appropriate
inspection.  Analysis templates would allow statistics centers and
groups to provide standardized templates for initiating an analysis.
%%While most IDE features have been developed for object-oriented
%%languages, the above also can apply to non-object oriented
%%programming.

ESS is one of the first RADs intended for statisticians.  It provides
an enhanced, powerful interface for efficient interactive data
analysis and statistical programming.  It is completely customizable
to satisfy individual desires for interface styles as well as being
extensible to additional statistical languages and analysis packages.


\bibliographystyle{plainnat}
%\pdfbookmark[1]{References}{section.7}
\bibliography{essJCGSv2}


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
