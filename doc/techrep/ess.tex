\documentclass{article}

%\usepackage{2up}

%%% 
\usepackage[authoryear,round]{natbib}
%or (if you have an unshiny latex installation)
%\newcommand{\citep}[1]{{\{\sf#1\}}}
%%%
\usepackage{alltt}

%% Postscript fonts
%\usepackage{palatcm}
\usepackage{times}
%%% \usepackage{amsmath}

%% The folowing is for creating PDF.
\newif\ifpdf
\ifx\pdfoutput\undefined
  \pdffalse     % not running PDFLaTeX
\else
  \pdfoutput=1  % running PDFLaTeX
  \pdftrue
\fi

\ifpdf
  \usepackage{thumbpdf}
\fi
%\usepackage{html,heqn,htmllist}
%\usepackage[latex2html]{hyperref} 
\ifpdf
  \usepackage[pdftex]{graphicx}
  \usepackage[pdftex]{hyperref} 
\else
  \usepackage[dvips]{graphicx}
  \usepackage[dvips]{hyperref} 
\fi

%%---End of package requiring ---------- Own Definitions ------------- 

\hypersetup{backref,colorlinks=true,pagebackref=true,
  hyperindex=true}%pdfpagemode=FullScreen,

\newcommand*{\Splus}{\textsc{S-Plus}}
%\newcommand*{\Scmt}[1]{\hfill \#\# \textsl{#1}}
\newcommand*{\Scmt}[1]{\hbox{\qquad {\footnotesize \#\#} \textsl{#1}}}
\newtheorem{defn}{Definition}[section]
\newtheorem{ex}{Example}[section]

\newenvironment{Salltt}{\small\begin{alltt}}{\end{alltt}}

%%--------------------------------------------------------------- Start Text

\title{Emacs Speaks Statistics: A Universal Interface for
  Statistical Analysis}  

\author{A.J. Rossini\footnote{Department of Biostatistics, University
    of Washington and Fred Hutchinson Cancer Research Center, Seattle,
    WA, USA} \and Martin M{\"a}chler\footnote{Seminar for Statistics;
    ETH Zurich; Zurich, Switzerland} \and Kurt
  Hornik\footnote{Technische Universit{\"a}t Wien, Vienna, Austria}
  \and Richard M. Heiberger\footnote{Temple University; Philadelphia,
    PA, USA} \and Rodney Sparapani\footnote{Medical College of
    Wisconsin, WI, USA}}

\date{\today}

\begin{document}

\ifpdf
  \DeclareGraphicsExtensions{.jpg,.pdf,.png,.mps}
\fi

%%%% To cite everything
%%\nocite{*} 

\maketitle

Keywords: Statistical Analysis, Programming, User Interfaces, SAS,
S-PLUS, R, XLispStat, Stata

\begin{abstract}
  We discuss Emacs Speaks Statistics (ESS), a user interface for
  statistical programming based on Emacs, intended for many
  statistical programming languages.  It falls in the programming
  tools category of Integrated Development Environments (IDEs).  We
  discuss how it works, why one would consider using it, and
  extensions which increase the programming efficiency for statistical
  programming.
\end{abstract}

\section{Introduction}
\label{sec:intro}

Integrated Development Environments (IDEs) combine features and tools
in a single interface in the attempt to increase programmer
productivity and efficiency.  The increased speed in software
development time over the last decade can be partially attributed to
the use of IDEs and similar Rapid Application Development (RAD) tools
and methodologies.  In the field of statistics, programming is an
important skill which can be augmented and enhanced by the right tools
and environment.  This is especially important with the rise of
computational tools such as resampling methods such as the bootstrap
and jackknife, as well as simulation methods such as Markov chain
monte carlo (MCMC).  

One issue that quickly arises is that different tools have different
strengths, and optimal use can require switching back and forth
between tools for data analysis.  For example, general purpose tools
such as R \citep{ihak:gent:1996} and \Splus\ are limited in scope for
Bayesian analyses, which tools such as BUGS are useful for.  From
another point of view, specialized tools such as BUGS are not as easy
to construct more general analyses and graphics as \Splus\ and R.  This
leads to an efficiency gain when using multiple tools for both
theoretical and applied statistical research.

The Emacs Speaks Statistics (ESS) project's primary goal is to provide
a single point of interface for text-based input and output for
statistical computing.  The primary tasks which are focused on for
optimization and efficiency are statistical coding and interactive
data analysis.  Statistical coding is the writing of computer code for
data analysis.  This code might be compiled into an object file using
a compiler, for example C or Fortran; or it might be run by an
interpreter, for example, SAS, \Splus\, R, or Python.  The task of
entering of commands for interactive data analysis is similar.  The
primary difference is that the results of a small set of commands are
of critical interest for review in the latter, but the results of all
commands are of interest in the former.  Both of these tasks can be
present at the same time, for example in the use of compiled Fortran
code for optimization, which is being called from an interpreted
language, such as \Splus, R, or XLispStat, containing the objective
function to optimize.

One natural issue that follows is that not all of the languages or
statistical packages have similar interfaces.  This means that it
might be necessary for a statistical analyst to learn 2 or 3 different
text-interfaces for editing and executing code.  Furthermore, it might
be necessary for the analyst to consider dialects of a language, for
example under the S family of languages, there is R, \Splus, the
original S implementation, as well as different versions of all three.
Testing code meant for use by others necessitates having it work in
multiple versions, so being able to quickly test means having quick
access to all versions; this might mean having to be able to access
programs which can only run on completely different sets of machines.
For example, one might want to be connected to multiple R processes.
Reasons for this include verifying behavior on different versions of
the same software, test and run scenarios where one process is doing
long-term processing while the other is doing short-term testing,
simulations, running multiple processes on multiple machines from the
same place.

ESS provides an interface which mitigates some of the problems noted
above.  It provides an editing interface, an interface to statistical
processes, and additional tools which can be useful for both
statistical software development and data analysis.  It works with
common statistical software including the S family of languages
including S \citep{BecRCW88,ChaJH92,ChaJ98}, \Splus\ \citep{Splus},
and R \citep{ihak:gent:1996}; XLispStat \citep{Tier90} including the
extension of Arc \citep{Cook:Weisberg:1999} and ViSta
\citep{youn:fald:mcfa:1992}; SAS \citep{SAS:8.0}; Stata
\citep{Stata:6.0}; Omegahat \citep{DTLang:2000}; and can be extended
in at least a limited way to most statistical packages which can be
controlled from a command-line.

In the rest of this introduction, we will discuss the environment of
interest and how it can be used.  Sections \ref{sec:S} and
\ref{sec:SAS} will discuss the implementation, features, and use with
S family of languages and SAS, respectively.  The history and advanced
features will be then discussed, and this paper will conclude with a
discussion of future work in this area, including Literate Statistical
Analysis as well as important features.

\subsection{Emacs}
\label{sec:intro:emacs}

Emacs is a mature, powerful, and extensible text editor which has been
freely available for over 15 years and is available for a large number
of platforms, including those currently most frequently in use for
statistical computing, including Unix, Apple Corporation's Macintosh
platform, and Microsoft-based platforms.  While it does not fall into
the category of word processors, it does have similar features.

Most programming and documentation falls under the realm of text
processing.  This is natural given that it is being worked on from the
perspective of the developer and not the end user.  This work can be
enhanced by common IDE features such as contextual highlighting and
recognition of special reserved words for the programming language or
statistical program/package of interest.

With the ESS extensions, Emacs acts as a uniform interface to the
statistical programming code, the statistical program/process,
documentation tools (\LaTeX, SGML, XML, Noweb), and revision control
tools (RCS,CVS,SCCS, PRCS), on both local and remote machines.  It
handles the interface to both source code and transcripts using
context (syntax highlighting, bookmarking features, command-history).

Emacs is also a sophisticated development environment for programming
in traditional compiled languages such as C and Fortran as well as
non-traditional byte-compiled and interpreted languages such as Perl,
Java, and Python.  It provides interfaces to build tools such as make
as well as debugging tools through the use of external debuggers such
as JDebug, GDB, and DBX.

Extensions to Emacs allow it to act as a World-Wide-Web browser, a
highly sophisticated mail and news reader, a shell/terminal window
with history, and as many other common text-based tools.  It can be
re-mapped to act as many other text-editors, such as ed, vi, wordstar,
and brief.  In addition, the above plus its ability to interface with
other processes makes it an ideal platform for providing a universal
interface to statistical packages.  The use of emacs-lisp as an
extension language has also facilitated the programming.

Emacs is equipped to assist with programming in Fortran, C, C++, Java,
and many more languages.  It has an interface to build and debugging
tools including make and many common debuggers such as dbx, gdb, and
jdb.   Along with this, Emacs provides an interface to revision control
systems for maintaining version history and a change-log for files.

One of the strengths of Emacs is that every activity can be
facilitated by keystrokes.  This has the advantage of eliminating the
slowness and potential danger of mouse usages, but also has the
disadvantage of requiring user to memorization.  There is some
ability to use pull-down menus, and the menus can be configured to
assist with learning keystrokes.

The above reasons make Emacs a natural choice for providing a
universal interface for data analysis and programming.

\subsubsection{Help for Using Emacs}

We assume that you are familiar with Emacs terminology and syntax:
file, buffer, region, description of keys etc.  If not, please read
the New Users guide (found in the info pages, "C-h i" (by pressing
control h, i) or Tutorial, "C-h t").

To find the key-sequences for commands, view the keymap (C-h b) or
view help for the current mode (C-h m).   There are also numerous
books which might help.

\section{Statistical User Interfaces}
\label{sec:UI}

For the purposes of the user interface, recent and traditional
interfaces for statistical packages and languages can generally be
classified into 3 forms.  There is the command-line interface that
most of the packages have available; this is the interface that ESS
needs for interfacing at the process level.  There is also the
spreadsheet/MDI interface employed by both spreadsheet packages as
well as most Apple and Microsoft-based statistical packages.  In
addition, there have been other one-time implementation interfaces,
which include graph-based interfaces as implemented in ViSta
\citep{youn:lubi:1995}, the SAS terminal interface, which divides the
terminal window into 3 screens, and possibly others.

\subsection{ESS}
\label{sec:UI:ESS}

ESS originated from the extension for programming and process
interface in Emacs supplied by S-mode (D. Bates, et. al.; M Meyer; D.
Smith).  The extension to a language-independent generic interface was
prompted by the success of R, and the need for an R-mode.  This led to
a merger with the SAS-mode (T. Cook), and the refactoring of the
S-mode codebase to accommodate multiple languages in a flexible way.
A detailed history can be found in section~\ref{sec:history}.

ESS currently supports a number of interactive statistical programs as
well as a few interpreted statistical languages.  There are various
levels of support depending on their capabilities and needs.  Because
of it's history, ESS supports the S family of languages extremely
well; these include recent versions of S, \Splus, and R.  SAS is also
well supported, but to a lesser extent.  The lack of objects in SAS
has prevented the use of object completion facilities.  Stata and
XLispStat (and the XLispStat extensions, ARC and ViSta) are marginally
supported, providing mainly syntax highlighting and
process-interfacing.  Note that even though we refer to it as marginal
support, it is still the basic functionality that the majority of ESS
users take advantage of.  This appears to be sufficient to
differentiate from typical package-provided interfaces.

\section{Features and Use}
\label{sec:basic}


%%% MAKE THIS INTO A PARAGRAPH
%%ESS provides a number of features, including:
%%\begin{itemize}
%%\item syntax highlighting 
%%\item standard formating and customizable automatic indentation
%%\item ability to send text regions and buffers to statistical programs
%%\item command-line history searching 
%%\end{itemize}
ESS provides a number of features for statistical programming, beyond
those generally provided by Emacs, which were listed in
section~\ref{sec:intro:emacs}.

%\item Syntactic indentation and highlighting of source code
For the interface with the programming language code as well as the
interface with the statistical program, this includes syntax
highlighting to denote assignment, reserved words, presence of
strings.  For the programming code, to assist with providing a clear
presentation, customizable automatic indentation is possible, with the
customization relating to how one would want to indent groups of
expression.  For the interface with the statistics package/program,
there is also a means of searching the command-line history for
previous commands as well as editing past commands for current use.
%\item Partial evaluations of code
These are connected by the ability to send, within Emacs, lines,
functions, regions, and whole edited buffers from the programming code
to the statistical program/package for execution.  In addition, it is
possible to have Emacs complete file names from the current underlying
working directory.

%%% MAKE THIS INTO A PARAGRAPH
%%In addition, for S, \Splus, and R, ESS provides
%%\begin{itemize}
%%\item object-name completion
%%\item ability dump, edit, save, and reload functions and similar
%%  programming code.
%%\end{itemize}
In addition to the above, for languages in the S family, including S
(versions 3 and 4, developed at Bell Labs), \Splus (all versions), and
R (all versions), there is object-name completion of both user and
system based functions and data.  There is also the ability to dump
and save objects (user and system generated) into text files in a
formatted manner for editing, as well as to reload after possible
editing back into the statistical package/process.

%%% MAKE THIS INTO A PARAGRAPH
Editing source code (S, LispStat, SAS)
\begin{itemize}
\item Loading and error-checking of code
\end{itemize}

%%% MAKE THIS INTO A PARAGRAPH
Interacting with the process
\begin{itemize}
\item Command-line editing
\item Searchable Command history
\item Command-line completion of object names (currently S only) and file names
\item Quick access to object lists and search lists (currently S only)
\item Transcript recording
\item Interface to the help system (currently S, LispStat, and Stata)
\end{itemize}

%%% MAKE THIS INTO A PARAGRAPH
Transcript manipulation (S3, S+3, S4, R, XLispStat)
\begin{itemize}
\item Recording and saving transcript files
\item Manipulating and editing saved transcripts
\item Re-evaluating commands from transcript files
\end{itemize}

%%%% MAKE THIS INTO A PARAGRAPH
%%Help File Editing (R)
%%\begin{itemize}
%%\item Syntactic indentation and highlighting of source code.
%%\item Sending Examples to running ESS process.
%%\item Previewing
%%\end{itemize}
ESS also provides an interface for writing help files for R functions
and packages.    It provides the ability to preview, as well as
handling embedded R source code in the same manner as ESS normally
handles source code, including syntax highlighting as well as the
ability to submit code to a running ESS process, for example R or
\Splus. 

For small projects, it can be useful to have a single repository (file
or directory with a few files) for documenting code which produces
datasets and analysis results.  This is facilitated by being able to
edit files (different or the same) and being able to specify different
modes for handling programming code for the different statistical
languages.

\section{Using ESS with the S family of languages}
\label{sec:S}

ESS's history as originating from S-mode results in its strength for
programming in S languages.

\subsection{Editing Files}
\label{sec:S:edit}

ESS[S] is the mode for editing S language files.  This mode handles:

- proper indenting, generated by both [Tab] and [Return].

- color and font choices based on syntax.

- ability to send the contents of an entire buffer, a highlighted
  region, an S function, or a single line to an inferior S process, if
  one is currently running.

- ability to switch between processes which would be the target of the 
  buffer (for the above).

- The ability to request help from an S process for variables and
  functions, and to have the results sent into a separate buffer.

- completion of object names and file names.

ESS[S] mode should be automatically turned on when loading a file with
the suffices found in ess-site (*.R, *.S, *.s, etc).  However, one
will have to start up an inferior process to take advantage of the
interactive features.


\subsection{Inferior ESS processes}
\label{sec:S:inf}

iESS (inferior ESS) is the mode for interfacing with active
statistical processes (programs).  This mode handles:

- proper indenting, generated by both [Tab] and [Return].

- color and font highlighting based on syntax.

- ability to resubmit the contents of a multi-line command
  to the executing process with a single keystroke [RET].

- The ability to request help from the current process for variables
  and functions, and to have the results sent into a separate buffer.

- completion of object names and file names.

- interactive history mechanism

- transcript recording and editing

To start up iESS mode, use one of
\begin{Salltt}
   M-x S+3 
   M-x S4
   M-x R
\end{Salltt}
(for \Splus~3.x, S4, and R, respectively.  This assumes that you have
access to each).  Usually the site will have defined one of these programs
(by default S+3) to the simpler name:

   M-x S

%%------- The following is *REALLY* outdated ----
%%-- since 1.2.0  vsize and nsize are not needed anymore
%%---.... have other command line arguments, eg  --verbose

%%--- Martin will fix this up :

Note that R has some extremely useful command line arguments, 
-v and -n.   To enter these, call R using a "prefix argument", by

   C-u M-x R

and when ESS prompts for "Starting Args ? ", enter (for example):

   --max-vsize=10000 --max-nsize=5000

Then that R process will be started up using ``R --max-vsize=10000
--max-nsize=5000''. 


%%

New for ESS 5.1.2 (and later):  "\texttt{S-elsewhere}" command

  The idea of "M-x S-elsewhere" is that we open a telnet (or rlogin)
  to another machine, call the buffer "*S-elsewhere*", and then run S
  on the other machine in that buffer.  We do that by defining "sh" as
  the inferior-S-elsewhere-program-name.  Emacs sets it up in a
  "*S-elsewhere*" iESS buffer.  The user does a telnet or login from
  that buffer to the other machine and then starts S on the other
  machine.  The usual C-c C-n commands from myfile.s on the local
  machine get sent through the buffer "*S-elsewhere*" to be executed
  by S on the other machine.
                           

\subsection{Handling and Reusing Transcripts}
\label{sec:S:trans}

\begin{itemize}
\item  edit transcript 
\item  color and font highlighting based on syntax. 
\item  resubmit multi-line commands to an active process buffer 
\item  The ability to request help from an S process for variables and 
        functions, and to have the results sent into a separate buffer. 
\item  ability to switch between processes which would be the target of the  
  buffer (for the above). 
\end{itemize}

\subsection{Programming Language Help}
\label{sec:S:help}
When viewing help pages, there's a new menu \textsf{[ESS help]} and
useful 1-letter shortcuts for navigation and more, such as
\begin{description}
\item[n,p] move to \textbf{n}ext or \textbf{p}revious help section
\item[s \textit{x}] move to help section code ``\textit{x}'' where
  \textit{x} is e.g. \texttt{u} for ``Usage'', or \texttt{e} for
  ``Examples''.  You can see a full list ..............

\item[h] fast `hyperlink' to other help pages

\item[l] (after \texttt{"s e"}) send examples \textbf{l}inewise to S for
  evaluation, also \texttt{C-c C-r} for sending a whole region.  This 
  is particularly useful in R which guarantees that all examples are
  directly executable (possibly after \texttt{library(*)} for non-base
  packages).
\end{description}

\subsection{Philosophies for using ESS}
\label{sec:S:philosophy}

The first is preferred, and configured for.  The second one can be
retrieved again, by changing emacs variables.

\begin{enumerate}
\item 
  (preferred by the current group of developers):  The source code is 
   real.  The objects are realizations of the source code.  Source
   for \textbf{every} user modified object is placed in a particular directory
   or directories, for later editing and retrieval.

\item (older version): S objects are real.  Source code is a temporary
   realization of the objects.  Dumped buffers should not be saved.
   We strongly discourage this approach.  However, if you insist,
   add the following lines to your \texttt{.emacs} file:\\[-1ex]
   \begin{Salltt}
      (setq ess-keep-dump-files 'nil)
      (setq ess-delete-dump-files t)
      (setq ess-mode-silently-save nil)
   \end{Salltt}
   This ``old'' view was based the permanent storage of objects
   approach in the original S implementations, which used a separate
   disk files for each object.

\end{enumerate}
The second saves a small amount of disk space.  The first allows for
better portability as well as external version control for code.

\subsection{Scenarios for use}
\label{sec:S:scenarios}

We present some basic suggestions for using ESS to interact with S.
These are just a subset of approaches, many better approaches are
possible.  Contributions of examples of how you work with ESS are
appreciated (especially since it helps us determine priorities on
future enhancements)! (comments as to what should be happening are
prefixed by "\verb+##+").

\begin{itemize}
\item Data Analysis Example (source code is real)
\begin{Salltt}
  \Scmt{Load the file you want to work with}
  C-x C-f myfile.s

  \Scmt{Edit as appropriate, and then start up \Splus~3.x}
  M-x S+3

  \Scmt{A new buffer *S+3:1* will appear.  Splus will have been started}
  \Scmt{in this buffer.  The buffer is in iESS [S+3:1] mode.}

  \Scmt{Split the screen and go back to the file editing buffer.}
  C-x 2 C-x b myfile.s

  \Scmt{Send regions, lines, or the entire file contents to \Splus.}
  \Scmt{For regions, highlight a region with keystrokes or mouse}
  \Scmt{and then send with:}
  C-c C-r

  \Scmt{Re-edit myfile.s as necessary to correct any difficulties.  Add}
  \Scmt{new commands here.  Send them to S by region with}
  C-c C-r
  \Scmt{or one line at a time with}
  C-c C-n

  \Scmt{Save the revised myfile.s with C-x C-s.}

  \Scmt{Save the entire *S+3:1* interaction buffer with C-c C-s.  You}
  \Scmt{will be prompted for a file name.  The recommended name is}
  \Scmt{myfile.St.  With the *.St suffix, the file will come up in ESS}
  \Scmt{Transcript mode the next time it is accessed from Emacs.}
  \end{Salltt}

\item Program revision example (source code is real)
  \begin{Salltt}
  \Scmt{Start up \Splus~3.x in a process buffer (this will be *S+3:1*)}
  M-x S+3

  \Scmt{Load the file you want to work with}
  C-x C-f myfile.s
  
  \Scmt{edit program, functions, and code in myfile.s, and}
  \Scmt{send revised functions to S when ready with}
  C-c C-f
  \Scmt{or highlighted regions with}
  C-c C-r
  \Scmt{or individual lines with}
  C-c C-n
  \Scmt{or load the entire buffer with} 
  C-c C-l

  \Scmt{save the revised myfile.s when you have finished}
  C-c C-s
  \end{Salltt}

\item Program revision example (S object is real)
  \begin{Salltt}
  \Scmt{Start up \Splus~3.x, in a process buffer (this will be \textbf{*S+3:1*})} 
  M-x S+3

  \Scmt{Dump an existing S object my.function into a buffer to work with}
  C-c C-d my.function
  \Scmt{a new buffer named \textit{yourloginname}.my.function.S will be created with}
  \Scmt{an editable copy of the object.  The buffer is associated with the}
  \Scmt{pathname {\footnotesize /tmp/\textit{yourloginname}.my.function.S} and will}
  \Scmt{almost certainly not exist after you log off.}

  \Scmt{Enter program, functions, and code into work buffer,}
  \Scmt{and send entire contents to \Splus\ when ready:}
  C-c C-b

  \Scmt{Go to *S+3:1* buffer, which is the process buffer, and examine}
  \Scmt{the results.}
  C-c C-y
  \Scmt{The sequence C-c C-y is a shortcut for:  C-x b *S+3:1*}

  \Scmt{Return to the work buffer (may/may not be prefixed)}
  C-x C-b \textit{yourloginname}.my.function.S
  \Scmt{Fix the function that didn't work, and resubmit by}
  \Scmt{placing the cursor somewhere in the function and}
  C-c C-f
  \Scmt{Or you could've selected a region (using the mouse, or keyboard}
  \Scmt{via setting point/mark) and}
  C-c C-r
  \Scmt{Or you could step through, line by line, using}
  C-c C-n
  \Scmt{Or just send a single line (without moving to the next) using}
  C-c C-j
  \Scmt{To fix that error in syntax for the "rchisq" command, get help}
  \Scmt{by}
  C-c C-v rchisq
\end{Salltt}
\item Data Analysis (S object is real)
\begin{Salltt}
  \Scmt{Start up R in a process buffer (this will be \textbf{*R*})} 
  M-x R

  \Scmt{Work in the process buffer.  When you find an object that needs}
  \Scmt{to be changed (this could be a data frame, or a variable,}
  \Scmt{or a function), dump it to a buffer:}
  C-c C-d my.cool.function

  \Scmt{Edit the function as appropriate, and dump back in to the}
  \Scmt{process buffer}
  C-c C-b

  \Scmt{Return to the R process buffer}
  C-c C-y
  \Scmt{Continue working.}

  \Scmt{When you need help, use}
  C-c C-v rchisq
  \Scmt{(which you can do using command name completion)}
  \Scmt{but entering:   \underline{help("rchisq")} or  \underline{?rchisq}}
  \Scmt{will bring up the help file in a separate buffer}
  \Scmt{\emph{--- currently only for \textbf{*R*}}.}
\end{Salltt}
\end{itemize}


\section{Using ESS with SAS}
\label{sec:SAS}



\section{Advanced Usage}
\label{sec:advanced}

\begin{itemize}
\item Switching the engine
\item \texttt{S+elsewhere}

\end{itemize}

\section{Obtaining ESS}
\label{sec:getIt}

ESS is primarily located at ess.stat.wisc.edu, and is available by FTP
or through the World-Wide-Web (WWW).  A basic installation consists of
downloading the package, unpacking, and then adding a line to the
emacs initialization file (\verb+.emacs+ or \verb+_emacs+), pointing
to the lisp subdirectory of the unpacked archive.

There are also packages for various Linux distributions, as well,
including Debian, RedHat, Mandrake, and SuSE.

\section{History}
\label{sec:history}

ESS (originally S-mode) was initially designed for use with S and
\Splus(tm); hence, this family of statistical languages currently has
the most support.  We denote by S, any of the currently available
members (or ``dialects'') of the family, including S 3.x, S 4.x, \Splus
3.x, \Splus~4.x (incl.\ \Splus~2000), \Splus~5.x, and R.  In addition, we
denote by Emacs, one of the GNU family of editors, either Emacs (as
developed and maintained by the Free Software Foundation) or XEmacs (which
is a derivative work).

ESS is a remarkable example of how open-source products can continue
to develop beyond what their initial authors planned.  ESS started as
S-mode, an Emacs extension which was developed in 1991 as a simple
tool for editing program files for S and \Splus.  In 1994, Rossini
extended S-mode to support XEmacs, which was a forked version of
Emacs.  At the same time, Rossini extended a successful SAS-mode
written by Tom Cook to work with XEmacs.  In 1995, S-mode was merged
into a uniform S-mode for Emacs, XEmacs, and supported S, \Splus, and
R. During 1996 and 1997, this was extended to incorporate the
SAS-mode as well as to provide a generic means for configuring ESS to
accommodate changed as well as new statistical languages.

Most of this was primarily done under Unix.  However, in 1998, thanks
to an example of interprocess communication using Microsoft's DDE by
Brian Ripley, Richard M. Heiberger provided interfaces for \Splus~4.x
and then \Splus~2000.

Most of what has been done recently is debugging and tuning.  New
features in the plans include robust extensions for Literate Data
Analysis using Noweb \citep{NRamsey:1994}, as well as extensions for
XML-based Literate Statistical Analysis.

\section{Remarks and Extensions}
\label{sec:remarks}

There are two active areas of extensions for user environments.  One
is to enhance the capabilities of the IDE for statistical practice;
this includes implementing such common IDE features as object browsers
as well as clean up the interface.

The other exciting extension is towards quasi-Literate Programming
methodologies \citep{Knuth:1992,NRamsey:1994}, which we will refer to as
Literate Statistical Analysis \citep{ross:lunt:2001}. The tools include
the use of Noweb \citep{NRamsey:1994} and an additional step towards the
use of an XML authoring environment for statistical analysis.
Literate Data Analysis based on Noweb, is a means of documenting a
statistical analysis plan and procedure.  Literate Statistical
Analysis is intended to be a round-trip environment for both design
and analysis.

The future use of XML is to accommodate the growing use of WWW-based
services for document publishing as well as information conversion.
By marking up the document with XML, it is possible to display subsets
of the document contextually according to the intent of the document.
Unlike Literate Data Analysis, which provides a single document for
code and analysis plan, Literate Statistical Analysis is a round-trip
cycle, using document modification through the Document Object Model
interface (W3 Consortium).  This is described more in
\citep{ross:lunt:2001}. 


\bibliographystyle{plainnat} %alpha}
\bibliography{ess}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ess"
%%% End: 

