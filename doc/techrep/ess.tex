\documentclass{article}

%\usepackage{2up}

%%% 
\usepackage[authoryear,round]{natbib}
%or (if you have an unshiny latex installation)
%\newcommand{\citep}[1]{{\{\sf#1\}}}
%%%
\usepackage{alltt}

%% Postscript fonts
%\usepackage{palatcm}
\usepackage{times}
%%% \usepackage{amsmath}

%% The following is for creating PDF.
\newif\ifpdf
\ifx\pdfoutput\undefined
  \pdffalse     % not running PDFLaTeX
\else
  \pdfoutput=1  % running PDFLaTeX
  \pdftrue
\fi

\ifpdf
  \usepackage{thumbpdf}
\fi
%\usepackage{html,heqn,htmllist}
%\usepackage[latex2html]{hyperref} 
\ifpdf
  \usepackage[pdftex]{graphicx}
  \usepackage[pdftex]{hyperref} 
\else
  \usepackage[dvips]{graphicx}
  \usepackage[dvips]{hyperref} 
\fi

%%---End of package requiring ---------- Own Definitions ------------- 

\hypersetup{backref,colorlinks=true,pagebackref=true,
  hyperindex=true}%pdfpagemode=FullScreen,

\newcommand*{\Splus}{\textsc{S-Plus}}
\newcommand*{\XLispStat}{\textsc{XLispStat}}
\newcommand*{\Stata}{\textsc{Stata}}
%\newcommand*{\Scmt}[1]{\hfill \#\# \textsl{#1}}
\newcommand*{\Scmt}[1]{\hbox{\qquad {\footnotesize \#\#} \textsl{#1}}}
\newtheorem{defn}{Definition}[section]
\newtheorem{ex}{Example}[section]

\newcommand{\stexttt}[1]{{\small\texttt{#1}}}
\newcommand{\ssf}[1]{{\small\sf{#1}}}
\newcommand{\elcode}[1]{\\{\stexttt{\hspace*{2em} #1}}\\}
\newcommand{\tm}{$^{\mbox{\scriptsize\sc tm}}$}
\newenvironment{Salltt}{\small\begin{alltt}}{\end{alltt}}
\newcommand{\US}{{\char'137}}        % \tt _
\newcommand{\marpar}[1]{\marginpar{\raggedright#1}}
\newcommand{\file}[1]{`\stexttt{#1}'}
%\parskip 1ex

%%--------------------------------------------------------------- Start Text

\title{Emacs Speaks Statistics: A Universal Interface for
  Statistical Analysis}  

\author{A.J. Rossini\footnote{Department of Biostatistics, University
    of Washington and Fred Hutchinson Cancer Research Center, Seattle,
    WA, USA} \and Martin M{\"a}chler\footnote{Seminar for Statistics;
    ETH Zurich; Zurich, Switzerland} \and Kurt
  Hornik\footnote{Technische Universit{\"a}t Wien, Vienna, Austria}
  \and Richard M. Heiberger\footnote{Temple University; Philadelphia,
    PA, USA} \and Rodney Sparapani\footnote{Medical College of
    Wisconsin, WI, USA}}

\date{\today}

\begin{document}

\ifpdf
  \DeclareGraphicsExtensions{.jpg,.pdf,.png,.mps}
\fi

%%%% To cite everything
%%\nocite{*} 

\maketitle

Keywords: Data Analysis, Programming Tools, User Interfaces, SAS,
\Splus, R, \XLispStat, \Stata

\begin{abstract}
  We discuss Emacs Speaks Statistics (ESS), a user interface for
  developing statistical applications and performing data analysis
  using any of several powerful statistical programming languages.
  ESS falls in the programming tools category of Integrated
  Development Environments (IDEs).  We discuss how it works, why one
  should use it, and extensions which increase statistical programming
  efficiency.
\end{abstract}

\section{Introduction}
\label{sec:intro}

Integrated Development Environments (IDEs) combine features and tools
in a single interface in an attempt to increase programmer
productivity and efficiency.  The increased speed in commercial
software development time over the last decade can be partially
attributed to the use of IDEs and similar Rapid Application
Development (RAD) tools and methodologies.  In the field of
statistics, programming is an important skill which can be augmented
and enhanced by the right tools and environment.  This is especially
important with the rise of computational tools such as resampling
(bootstrap and jackknife approaches) and Markov Chain Monte Carlo
(MCMC) sampling (such as Gibbs and Metropolis--Hastings).

In the field of statistics, different analytic tools are targeted for
particular styles of statistical analysis.  This suggests that
efficient work habits can require switching between data analysis
tools.  One example is that general purpose tools such as R
\citep{ihak:gent:1996} are not as easy to use to perform Bayesian
analyses as special tools such as BUGS \citep{SpieThomBest:1999}.  On
the other hand, these specialized tools can not be used efficiently to
handle general analyses and graphical summaries.  Indeed, BUGS is distributed
with procedures that simplify the transfer of BUGS output
to R or S for display of the results.  More generally, this suggests a
potential efficiency gain through the use of multiple
computational tools for complex statistical analyses.  However, most
tools have their own idiosyncratic user interfaces which can
negate an efficiency gain.

Conflicts can be simple, such as different keystrokes for editing
tasks such as copy and paste, beginning of line, highlighting
regions. The simple conflicts are sometimes the most aggravating
because our fingers are trained for one convention and we are
continually interfering with that training.
ESS provides a single keyboard interface for editing files and
immediately solves that specific problem.


Conflicts can be complex, for example, the coordination of several
files of data and code in a single analysis.  ESS, as part of Emacs,
incorporates version code control systems, ftp and other protocols for
transferring files across machines, a smooth interface to
documentation systems such as \LaTeX\ and html, and a myriad of
housekeeping tasks.

Emacs Speaks Statistics (ESS) provides a single keyboard interface for
a family of statistical computing tasks.  The primary user tasks for which
ESS is optimizated are statistical coding
and interactive data analysis.  Statistical coding is the writing of
computer code for data analysis.  This code might be in a compilable
language, such as C or Fortran, or it might be in an interpreted
language such as \Splus, SAS, R, \XLispStat, Perl or Python.  The task
of entering commands for interactive data analysis is similar.  In
either case, text is written in a computer language and sent to a
computer program for compilation or interpretation.  The primary
difference is that the results of a small set of commands are of
critical interest for review in the analysis phase, but the results of
all commands are of interest in the coding phase.  Both of these tasks
can be present at the same time, for example in the use of compiled
Fortran code for optimization, which is being called from an
interpreted language, such as \Splus, R, or \XLispStat, containing the
objective function to optimize.

Few statistical packages have identical command-line interfaces; this
is distinct from the differences between the actual macro or
programming languages.  This means that it might be necessary for a
statistical analyst to learn 2 or 3 different text-based interfaces
for editing and executing code.  Furthermore, it might be necessary
for the analyst to consider dialects of a language, for example under
the S family of languages, there is R, \Splus, and the original S
implementation, as well as different versions of each of these.  Code
design and testing necessitates working in multiple dialects and
versions; this might mean simultaneously accessing programs which run
on completely different sets of machines.  For example, one might want
to be connected to multiple R processes.  Reasons for this include
verifying behavior on different versions of the same software,
test-and-run scenarios where one process is doing long-term processing
while the other is doing short-term testing, simulations, running
multiple processes on multiple machines from the same place.

ESS provides an interface which mitigates some of the problems noted
above.  It provides a superior editor, an interface to statistical
processes, and additional tools which can be useful for both
statistical software development and data analysis.  It works with
common statistical software including the S family of languages
including S \citep{BecRCW88,ChaJH92,ChaJ98}, \Splus\ \citep{Splus},
and R \citep{ihak:gent:1996}; \XLispStat\ \citep{Tier90} including its
extensions Arc \citep{Cook:Weisberg:1999} and ViSta
\citep{youn:fald:mcfa:1992}; SAS \citep{SAS:8.0}; \Stata\
\citep{Stata:6.0}; Omegahat \citep{DTLang:2000}; and can be extended
in at least a limited way to most statistical packages which can be
controlled from a command-line.

The rest of this introduction discusses the ESS development
environment and how it can be used.  Sections \ref{sec:S} and
\ref{sec:SAS} discuss how this is realized for two different
statistical languages, the S family (S, \Splus, and R)
and SAS.  This is followed by the project's history and concludes
with a discussion of future extensions and related work.

\subsection{Emacs}
\label{sec:intro:emacs}

Emacs \citep{RMS:2000} is a mature, powerful, and easily extensible
text editing system which is freely available under the GNU General
Public License for a large number of platforms, including those most
frequently used for statistical computing.  These include Unix, the
Apple Macintosh platform, and Microsoft-based platforms.  While Emacs
is not a word processor, it does share some similar features and can
behave to a limited extent as one.    While Emacs is
not an operating system, it shares many characteristics with operating
systems; most importantly, Emacs can interact with and control other
programs either as subprocesses or as cooperating processes.
Emacs is one of the primary options for text editing on many Unix
systems.

Emacs provides facilities that go beyond simple insertion and
deletion: viewing two or more files at once; editing formatted text;
visual comparison of two similar files; and navigation in units of characters,
words, lines, sentences, paragraphs, and pages.  Emacs knows
the syntax of each programming language.  It can provide
automatic indentation of programs and highlight with fonts
or colors specified syntactic characteristics.
Emacs is extensible,
meaning new functions for editing text and interacting with programs
can easily be written.  Emacs provides full customization of the
keyboard and mouse, meaning that the new functions can be bound to
appropriate keystrokes.  The mouse-based interface, through menus and
toolbars, also tries to facilitate the learning of keystroke-based
short-cuts.  Additional menus can be defined by the user should they
be needed.

Most programming and documentation tasks fall under the realm of text
editing.  This work can be enhanced by common IDE features such as
contextual highlighting and recognition of special reserved words
appropriate to the programming language in use.  In addition, editor
behaviors such as folding, outlining, and bookmarks can assist with
maneuvering around a file.  Type-setting and word-processing, which
focus on the presentation of a document, are tasks that are not pure
text-editing.  Emacs shares many features with word-processing
programs and cooperates with document preparation systems such as
(\LaTeX; SGML, XML, and XSLT; and Noweb).

The capabilities can be extended in an orthogonal manner to include
other Emacs packages for assisting with documentation as noted above;
version control (RCS,CVS, SCCS, PRCS); and remote editing via FTP or
secure transport mechanisms such as ssh and scp.  Emacs handles the
interface to both source code and transcripts contextually, providing
syntax highlighting, bookmarking features, interfaces to directory
structure, and command-history.

Emacs provides a sophisticated development environment for programming
in traditional compiled languages such as C, C++, and Fortran as well
as non-traditional byte-compiled and interpreted languages such as
Perl, Java, and \XLispStat.  The development environment is built on Emacs's
ability to communicate directly with other processes running simultaneously
on the same or connected computers.
Emacs provides interfaces to system-building tools such as
\file{make} and to debugging such as the external debuggers
\file{JDebug}, \file{gdb}, and \file{dbx}.  Finally, Emacs assists with
project tasks
such as documentation of changes, design, and version control.

Other extensions to Emacs allow it to act as a World-Wide-Web browser,
a highly sophisticated mail and news reader, a shell/terminal window
with history, and as an interface to other common text-based tools
such as spell checking programs.  The Emacs keyboard and mouse
interface can be re-mapped to resemble that of other text-editors,
such as ed, vi, wordstar, and brief.

The user interface to Emacs is by keyboard or mouse.  The keyboard
interface is available on all platforms.  The mouse and menus are
available on all systems, including both windowing and non-windowing
environments, which support it.  The mouse-based interface, through
menus and toolbars, also tries to facilitate the learning of
keystroke-based short-cuts.  Additional menus can be defined by the
user should they be needed.

Emacs was one of the first tools available with a programmable
extension language, Emacs Lisp, which is a dialect of Lisp
\citep{RChassell1999,PGraham:1996}.  There are many examples of
specialized extensions for assisting and facilitating common editing
tasks.  Fundamentally important editing tasks such as programming
Makefiles, scripts, and compiled code in many computer languages are
well supported.  Many extensions for handling complex tasks have been
developed, such as spreadsheets, interfaces for reading mail, news,
and the World-Wide-Web (WWW), database front and backends, forms
entry, and interactive games such as tetris.  Emacs provides an
internal help system and a tutorial.  Appendix~\ref{app:scenarios}
provides sample sessions for using Emacs with ESS.

The above reasons suggest that Emacs is a reasonable starting choice
for providing a universal interface for data analysis and programming.
ESS extends Emacs to provide a functional, easily extensible and uniform
interface for multiple statistical packages.  


\section{Statistical User Interfaces}
\label{sec:UI}

Human interfaces for statistical packages and languages can generally
be classified into 3 forms.  There are command-line interfaces (CLIs)
that historically have been used by many packages.  This is the
interface that ESS uses for control.  Recent versions of statistical
packages have generally used graphical user interfaces (GUIs),
sometimes exclusively.  The most common GUI is perhaps the multiple
document interface (MDI), in which menus and toolbars are wrapped
around a region containing documents which display graphics, a window
for entering and editing command, and possibly a spreadsheet
displaying a cases-by-variables view of the data set.  This approach
is employed by both spreadsheet packages such as Microsoft Excel as
well as most Apple and Microsoft-based statistical packages including
\Splus\ and SPSS.  In addition, there have been other one-time
implementation interfaces.  Other interfaces include the flow-chart
guides, implemented as graph-based interfaces in ViSta
\citep{youn:lubi:1995}; the SAS terminal interface, which divides the
terminal window into 3 screens; and by the coherent implementation
provided by DataDesk \citep{vell:prat:1989}, which has a tight link
between data and graphics.

\subsection{Command line interfaces}
\label{sec:UI:command}

The classic command-line interface is available for some statistical
packages on most Unix and mainframe computers.  This interface
consists of entering commands one line at a time.  Current examples can
mostly be found under Unix, including \Splus, R, \Stata, and \XLispStat.
Note that the \Stata\ CLI is deprecated in favor of a new GUI, and
this direction seems to be a general trend.  ESS assists command-line
interfaces by providing a comprehensive interface layer on top of the
command-line.  SAS does not have a true CLI.  The two possible options
are a prompt-less input device which sends a combined log and
list-file text stream directly back to the same device, and second,
the 3-window graphical terminal interface which is being deprecated
in favor of a GUI version.

\subsection{Graphical User Interfaces}
\label{sec:UI:GUI}

The advent of the Apple Macintosh and Microsoft Windows operating
systems have encouraged a partial standardization of interfaces for
statistical packages.  Many packages written for both IBM-based and
Apple-based personal computers have adopted a data display descended
from the spreadsheet data-table approach.  Generally, these feature a
cases-by-variables spreadsheet representation of the data, along with
pull-down menus and dialog boxes for data analysis activities.
Depending upon their nature, numerical results can be saved as well as
displayed on the spreadsheet.  Software that takes this approach
includes SPSS, Minitab, \Splus\ 4.x for Windows and 6.x for Unix and
Windows, DataDesk, ViSta, and many others.

Most of the statistical software, including spreadsheets, uses the
multiple document interface rather than a single document interface
(SDI), which provides a single frame for each document or figure
created.  This seems to be more a function of the availability of GUI
toolkits under the Apple Macintosh and Microsoft Windows, which
promoted such interfaces, than any particular theory for
user-interface development.  Unix-based interfaces tend to be
SDI-based, due to the nature of X11 windowing.

\textbf{rmh: I do not know the words MDI and SDI.  Is this accurate?
S-Plus 4 for Windows uses MDI because there is a single S-Plus frame in which the
commands window, the graphsheets, the objects browser all appear as subwindows.
R uses SDI because the Rgui is one frame, the graphsheet is another, and they can
be independently moved on the screen.} 

\subsection{ESS}
\label{sec:UI:ESS}

ESS currently supports a number of interactive statistical programs as
well as a few interpreted statistical languages.  There are various
levels of support depending on the capabilities of the program and the
needs of users.  Because ESS builds on the extremely powerful Emacs
editing capabilities and the Emacs ability to communicate directly
with a running process, ESS provides very powerful and uniform
interaction with the statistical programs and languages.

Since ESS developed from S-mode, ESS strongly supports the S family of
languages; these include recent versions of S, \Splus, and R.  SAS is
also well supported, but to a lesser extent.  \Stata\ and \XLispStat\ 
(and the \XLispStat\ extensions, ARC and ViSta) are supported with the
basic functionality of syntax highlighting and process-interfacing.
ESS and its interface are fully discussed in the next section.

\section{ESS Features and Use}
\label{sec:basic}

ESS provides a number of features for statistical programming beyond
those provided by Emacs.
%, as listed in section~\ref{sec:intro:emacs}.

\paragraph{Syntactic indentation and highlighting of source code.}
The ESS interface includes a description of the syntax and grammar of
each statistical language it knows about.  This gives ESS the ability
to edit the programming language code, often more smoothly than with
editors distributed with the languages.  The process of programming
code is enhanced as ESS provides the user with a clear presentation of
the code with syntax highlighting to denote assignment, reserved
words, presence of strings, and comments.  ESS has customizable
automatic indentation, with the customization based on the syntactic
structure of groups of expressions.
ESS knows the structure of transcripts of the executing session,
as well as it knows the source language, and provides syntactic
highlighting here as well.
For the interface with the executing statistics package/program,
ESS also provides a means of searching the command-line history for
previous commands as well as editing past commands for current use.

\paragraph{Partial evaluations of code.}
Emacs can send individual lines, entire function definitions, marked
regions, and whole edited buffers from the window in which the code is
displayed for editing to the statistical program/package for
execution.  Emacs can complete partially typed file
names by referring to the current working directory.
Emacs sends the code directly to the running program and
receives the printed output back from the program.  Direct sending of
code is a major improvement over cut-and-paste as it does not require
switching buffers or windows for either the sending or receiving of
information.  The response is received immediately in an editable Emacs buffer.


In addition, for languages in the S family \{S
(versions 3 and 4) developed at Bell Labs, \Splus\ (all versions), and
R (all versions)\} ESS provides object-name completion of both user- and
system-defined functions and data.  There is also the ability to dump
and save objects (user- and system-generated) into text files in a
formatted manner for editing, as well as to reload (after possible
editing) back into the statistical package/process.

\paragraph{Source code checking.}
ESS facilitates the editing of source code by providing a means
for loading and error-checking of small sections of code for S,
\XLispStat, and SAS.  This allows for one form of source-level
debugging.

\paragraph{Interacting with the process.}
Emacs has historically referred to processes under its control as
inferior, accounting for the name inferior ESS (\stexttt{iESS}) to
denote the mode for interfacing with the statistical package.  
The output of the package goes directly to an editable text buffer in Emacs.
This
mode allows for command-line editing and saving history, as well as
recalling and searching for previously entered commands.
Filename completion is available.    In addition (currently only for for S
languages), there exists object-name and function-name completion.
Transcripts are easily recorded and can be edited into an ideal
activity log which can then be saved.  There is a good interface for
handling and intercepting calls to the internal help systems for S,
\XLispStat, and \Stata.

\paragraph{Interacting with statistical programs on remote computers.}
ESS provides the facility to edit and run programs on remote machines
in the same session and with the same simplicity as if they were
running on the local machine.  The remote machine could be a very
different platform than the local machine.

\paragraph{Transcription Editing and Reuse.}
Once a transcript log is generated, perhaps by saving an \file{iESS}
buffer, transcript-mode assists with reuse of part or all of the
entered commands.  It permits editing and re-evaluating the commands
directly from the saved transcript.  This is is useful for
demonstration of techniques as well as for reconstruction of data
analyses.  There currently exist functions within ESS for cleaning
transcripts from S languages back to source code by finding all input
lines and isolating them into an input file.

\paragraph{Help File Editing (R).}
ESS also provides an interface for writing help files for R functions
and packages.  It provides the ability to view and execute embedded R
source code directly from the help file in the same manner as ESS
normally handles code from a source file.  R \stexttt{Help mode} provides syntax
highlighting and the ability to submit code to a running ESS
process, either R or \Splus.

\section{Using ESS with the S family of languages}
\label{sec:S}

ESS originated as S-mode and has historically provided strong support
for the S languages.  This section provides examples for
editing files, communicating with the interactive S process, editing
transcripts, and getting help.

\subsection{Editing Files}
\label{sec:S:edit}

\stexttt{ESS[S]} is the mode for editing S language files.  This mode
handles proper indenting of multi-line code and functions
(automatically when the code is entered and under user
control while editing); color and font highlighting based on syntax; the
ability to send the contents of an entire buffer, a highlighted
region, an S function, or a single line to an inferior S process; the
ability to switch between several inferior S processes (possibly on
different machines); the ability to request help from an S process for
variables and functions, and to have the help results sent into a
separate buffer; and completion of object names and file names.

\stexttt{ESS[S]} mode is automatically turned on for files with the
extensions \file{.R}, \file{.r},
\file{.S}, \file{.s}, \file{.ssc}, \file{.q}.  An inferior
process must be running to take advantage of the interactive features
such as object- and file-name completion and help.

\subsection{Inferior ESS processes}
\label{sec:S:inf}

\stexttt{iESS[S]} is the mode for interfacing with active S
statistical processes.  In effect, this mode replaces the \Splus\ or R
Commands window with an active buffer running inside Emacs.  This mode
provides an interactive history mechanism; transcript recording and
editing; the ability to resubmit the contents of a multi-line command
to the executing process with a single keystroke.  It also provides
the same editing features as the editing mode \stexttt{iESS[S]}.

The statistical processes S and R are started by using the Emacs
function call \stexttt{M-x~S} or \stexttt{M-x~R}.  This call opens up
a buffer and starts the S process inside that buffer.

\stexttt{iESS[S]} uses standard input/output to communicate with the S
program, except with the GUI interface for \Splus\ 4 and 6 for Windows
where standard input/output is not available.
ESS currently provides two options on Windows.  ESS
can use the DDE (Dynamic Data Exchange) protocol
to communicate with the GUI.  The
editing features, including the sending of commands to \Splus, are as
described above.  The printed output does not come back to an Emacs
buffer, but instead appears in the \Splus\ Commands Window.
Transcripts must be physically copied to an Emacs buffer to get the
transcript editing features.   Full GUI
capability is available by switching to the \Splus\ window.
Or ESS can directly access Sqpe, the
\Splus\ computing engine, using exactly the same procedures as are
used for Unix.  With this procedure interactive graphics and other GUI
features are not available.  In the near future, we
anticipate merging these approaches for  \Splus\ 6 by
using the \stexttt{connections} class of the new S4 engine.  We will then
have both interactive GUI and transcript recording and
editing on the Windows platform.

%% This assumes that you have access to the desired statistical
%% package, which doesn't come with ESS.
%% Generally, these start up the package with a particular set of
%% command-line arguments which are tailored for ESS.  However, some
%% packages such as R have extremely useful command line arguments.  To
%% enter these, call R using a ``prefix argument", by \stexttt{C-u M-x R} and
%% when ESS prompts for ``\stexttt{Starting Args ? }", enter (for example):
%% \stexttt{--max-vsize=10000}.  Then R will be started up with those
%% particular arguments.

One useful extension in ESS is relaxation of the requirement that the
statistics program %% we don't need to talk about R or S-PLUS when discussing
%% ``S'' in general.
be available on the local machine.  
ESS provides transparent execution of a statistics package on a remote
machine from within the local Emacs.  The
\stexttt{S+elsewhere} commands assist with transparent execution of a
statistics package on a remote machine.  The idea of
\stexttt{S+elsewhere} is that we open a telnet, rlogin, or ssh
connection to another machine from within a buffer called
\file{*S+elsewhere*}, and then run S on the other machine in that
buffer.  All the editing and interaction features described in
sections \ref{sec:S:edit} and \ref{sec:S:inf} for the local machine
work equally well on the remote machine.  The relevant commands get
sent through the buffer \file{*S+elsewhere*} to be executed by the
program on the other machine.  The interaction, including all the
unique features of working with ESS, appears to the user exactly the
same as if the program were running on the local machine.  With
X-windows running on the local machine, it is even possible to bring
up visual displays from remote Unix systems on a Windows local
machine.

\subsection{Editing and Reusing Transcripts}
\label{sec:S:trans}

\stexttt{ESS Transcript mode} is designed
for editing transcripts, constructed for example by saving
an \file{iESS} buffer.  This mode understands the form of S
transcripts; it does color and font highlighting based on syntax; permits 
resubmitting
multi-line commands to an active process buffer; has the ability to
request help from an S process for variables and functions; and the ability to
switch between processes which would be the target of the resubmissions.
The S language transcripts can be ``cleaned'' by
finding all input lines and isolating them into a stand-alone input file
that can be used as input to another S job or as a model for further
program design.

\subsection{Programming Language Help}
\label{sec:S:help}

When viewing help pages, there's a new menu \textsf{[ESS help]} and
useful 1-letter shortcuts for navigation and more, such as
\begin{list}{}{\renewcommand{\makelabel}[1]{\bf#1\hfill}}
\item[n,\,p] move to \textbf{n}ext or \textbf{p}revious help section
\item[{s \textit{x}}] move to help section code ``\textit{x}'' where
  \textit{x} is e.g. \stexttt{u} for ``Usage'', or \stexttt{e} for
  ``Examples''.  You can see a full list by entering \stexttt{s ?} from within
an \stexttt{ESS Help} buffer.
\item[h] fast `hyperlink' to other help pages
\item[l] (after \stexttt{"s e"}) send examples \textbf{l}inewise to S for
  evaluation, also \stexttt{C-c C-r} for sending a whole region.  This 
  is particularly useful in R which guarantees that all examples are
  directly executable.
% (possibly after \stexttt{library(*)} for non-base packages).
\end{list}

\subsection{Philosophies for Combining S with ESS}
\label{sec:S:philosophy}

There are two primary philosophies for using ESS.  The first is that
the source code (the file \file{myfile.s}, for example) is real,
and objects in S are temporary realizations of the source.  This is
the approach preferred by the current group of developers and the default
when ESS is initially installed.  A project is constructed by writing S
language source code for \textbf{every} user defined function or data
object.  The code is stored in one or more text files stored in a
project directory or directories.  The code is read into S for a
temporary realization as an object.  This approach allows for better
portability, where the user might want to use the written code and
perform the same or related analyses on different versions of the S
language.  This approach also permits external version control for
S language source code.

The second, deprecated view, is that S objects are real.  The text
version of the objects (source code, although we can't use that term
with this philosophy) 
is a temporary realization of the objects.  ESS is then used to edit, but
not save, the objects.
% Dumped buffers (a text representation of the underlying S object)
% should not be saved in this philosophy.  
We strongly discourage this approach.
It is a
natural result of assuming that the S process will always be the
same, an assumption we are not willing to make.
Details for activating this configuration are in the
documentation distributed with ESS.
%However, it can be realized by adding the following lines to one's
%\file{.emacs} configuration file:
%\begin{Salltt}
%  (setq ess-keep-dump-files 'nil)
%  (setq ess-delete-dump-files t)
%  (setq ess-mode-silently-save nil)
%\end{Salltt}
% This ``old'' view was based the permanent storage of objects approach
% in the original S implementations, which used separate internally
% formatted disk files for each object. 


\section{Using ESS with SAS}
\label{sec:SAS}

\stexttt{ESS[SAS]} mode is used for editing SAS files.  It is based on
the SAS mode by Cook
(\stexttt{ftp://ftp.biostat.wisc.edu/pub/cook/sas-mode/sas.tar.gz}).
ESS provides two user interfaces for executing SAS
programs.  Both have similarities to the
windowing interface that SAS itself provides.
One is more similar in behavior to batch processing of SAS jobs
and the other to the ESS interface with S.  In addition, SAS files can be
edited in \stexttt{ESS[SAS]} mode in Emacs and then pasted into the SAS
Display Manager \ssf{Program Editor} window.  All three procedures can
be used with SAS running either locally or remotely.

\subsection{Editing SAS Files}
\label{sec:SAS:edit}

\stexttt{ESS[SAS]} is the mode for editing SAS language files. 
\stexttt{ESS[SAS]} is automatically turned on when editing a file with
a \file{.sas} suffix.  \stexttt{ESS[SAS]} mode provides all the
flexibility of the Emacs editor for editing and searching in each file
and for simultaneously working with multiple SAS files.  For example,
while designing a SAS analysis a user may need to construct macro
files as well as specific files for one or more data sets.  The code
for the macros or the analysis can be compared to similar code
developed for other projects.

\stexttt{ESS[SAS]} mode
handles: proper indenting, generated by both \stexttt{[Tab]} and
\stexttt{[Return]}; color and font choices based on syntax; ability to send
the contents of an entire buffer, a highlighted region, or a single
line to an inferior SAS process, if one is currently running; ability
to switch between processes which would be the target of the buffer
(for the above); ability to save and submit a file
as a batch SAS process with a single keypress; ability to continue
editing a file even while SAS is running it;
the capability of killing the batch SAS
process through the shell buffer; the capability of allowing the
SAS process to keep on
running after you exit Emacs; single keypress navigation of \file{.sas},
\file{.log} and \file{.lst} files (\file{.log} and \file{.lst}
files are automatically refreshed).

% At this writing (ESS release 5.2), the indenting and syntactic
% highlighting for SAS are usually correct.

\paragraph{Preconceptions and Configuration.}

People using ESS and SAS together come from two incompatible starting positions.
Some are Emacs users who are adding SAS to their repertoire.  They expect the 
keyboard to behave as it does in any other Emacs mode and they expect a few new
keys to interact with SAS.  Others are SAS users who have discovered the
power of editing their SAS source files with Emacs.  They expect the keyboard
to behave as it always has in their previous editor and they expect to gain some
more powerful editing and interaction capabilities by using Emacs.

The two places where the keyboard must be configured are the
\texttt{[TAB]} key and the function keys.  The batch processing
keypress commands use the same function keys that the SAS Display
Manager uses.

\paragraph{The \texttt{[TAB]} Key.}
\label{sec:SAS:tab}

There are two options for how ESS will interpret the \stexttt{[TAB]} key
with respect to SAS code.  The \stexttt{TAB} key is bound by default to
\stexttt{sas-indent-line}.  This function is used to syntactically indent SAS
code so \stexttt{PROC} and \stexttt{RUN;} are in the left margin, other
statements are indented 4 spaces from the margin, continuation lines
are indented 4 spaces in from the beginning column of that statement.
This is the type of functionality that Emacs provides in most
programming language modes.  This functionality is equivalent to
uncommenting the following line in \file{ess-site.el}:
\stexttt{;;; (setq ess-sas-edit-keys-toggle 0)}

ESS provides an alternate behavior for the \stexttt{TAB} key that makes it
behave as it does on non-Emacs terminals, i.e. move the cursor to the
next tab stop.  The alternate behavior also provides a backwards \stexttt{TAB}
key: \stexttt{C-TAB}.  With this option the user is responsible for the
indentation of the code.  The alternate behavior is obtained by
uncommenting the following line in \file{ess-site.el}:
\elcode{;;; (setq ess-sas-edit-keys-toggle 1)}
Under the alternate behavior, the \stexttt{TAB} key is bound to
\stexttt{tab-to-tab-stop} and the tab stops are set by default at multiples
of 4.

\paragraph{Function Keys.}
Emacs users will often have customized the function keys for various
editing tasks and expect the keys to continue to behave in their
customized way.  For example, Heiberger uses the function keys to
cycle among the currently open editing buffers.  SAS users who are
familiar with the SAS Display Manager would like to use the function
keys that SAS provides.  SAS provides different function key assignments on
Windows and Unix platforms.  ESS therefore provides all possible options: 
no special function keys in SAS mode,
Unix-style SAS function keys (either
in all buffers or restricted to SAS buffers), Windows-style SAS function
keys (either in all buffers or restricted to SAS buffers).
More detail on the function keys is in section \ref{sec:SAS:proc:batch}


\subsection{SAS process interaction}
\label{sec:SAS:proc}

There are three methods for interacting with SAS.  We describe batch
processing from ESS, running SAS in an inferior ESS buffer, running
SAS with the Display Manager, and running SAS on a remote machine from
a local Emacs.

The ESS methods for interacting with SAS are based on the SAS Display
Manager's procedures.  Why therefore use ESS rather than the
Display Manager?   For two reasons: we prefer Emacs editing of source, and we
want immediate access through the Emacs search and edit commands to
the output in the listing file.
 

The interactive capabilities of ESS require you to start an inferior
SAS process with \stexttt{M-x SAS} (described below).  Batch SAS usage
starts a separate instance of SAS each time a file is submitted.

\subsubsection{SAS Batch processing}
\label{sec:SAS:proc:batch}

The user (or the site manager) must select either Unix style or
Windows style function key definitions for use in the
\stexttt{ESS[SAS]} modes.
%%   The actions available in the
%% \stexttt{ESS[SAS]} modes, and the default function keys that initiate
%% those actions are:\\
%% \begin{tabular}{llll}
%% Unix& PC&\\
%% \stexttt{F2} &\stexttt{F2}& Refresh &revert the buffer with the file if the file on disk is newer\\
%% \stexttt{}   &\stexttt{}  &         &       than the file currently in the buffer.\\
%% \stexttt{F3} &\stexttt{F8}& Submit  &save   the current \file{.sas} buffer (which may be the \file{.sas}\\
%% \stexttt{}   &\stexttt{}  &         &       file associated with the \file{.lst} or \file{.log} file you\\
%% \stexttt{}   &\stexttt{}  &         &       are actually looking at) to a file and submit\\
%% \stexttt{}   &\stexttt{}  &         &       the file to a background SAS job.\\
%% \stexttt{F4} &\stexttt{F5}& Program &switch buffer to \file{.sas} file.\\
%% \stexttt{F5} &\stexttt{F6}& Log     &switch buffer to \file{.log} file, ``refresh" and \\
%% \stexttt{}   &\stexttt{}  &         &        goto next error message, if any.\\
%% \stexttt{F6} &\stexttt{F7}& Listing &switch buffer to \file{.lst} file and ``refresh".\\
%% \stexttt{F7} &\stexttt{F4}& Type-1  &switch buffer to \stexttt{Type-1} (defaults to \file{.txt}) file and ``refresh".\\
%% \stexttt{F8} &\stexttt{F3}& Shell   &switch buffer to shell.\\
%% \end{tabular}
%%
Keys \stexttt{[f3]}--\stexttt{[f8]} mimic SAS Display Manager keys.
One other key has been provided for convenience.  \stexttt{F2}
performs the ``refresh" operation on the current buffer.  ``refresh"
compares the buffer date stamp with the file date stamp and replaces
the buffer with the file if the file is newer.  This is the same
operation that is automatically performed when Log, Listing, or
\stexttt{Type-1} are pressed.  \stexttt{Type-1} takes you to a file
with a user-specified extension; \file{.txt} by default.
\stexttt{Type-1} files are not a standard from the SAS Institute, but
are included here because many companies have developed internal
standards that use them.  You can over-ride the default, by specifying
a different extension in your \file{.emacs} file:\\
\stexttt{(setq ess-sas-suffix-1 '.txt')}

\paragraph{SAS Interface.}
\label{sec:SAS:interface}

The default command used by the Submit function key
(\stexttt{F3} or \stexttt{F8}) to
submit a batch SAS job is simply \stexttt{sas}.  If necessary, you can
over-ride this in your \file{.emacs} file.
The default assumption is that SAS is run on the local machine.  This too
can be overridden by changing \stexttt{ess-sas-submit-method} to point to
SAS on a remote machine.
% something like one of the following:
% \begin{Salltt}
%    ;;; (setq ess-sas-submit-command "nohup nice sas") ;; Unix
%    ;;; (setq ess-sas-submit-command "c:/progra~1/sas/sas.exe") ;; Windows
%    ;;; (setq ess-sas-submit-command "invoke SAS using program file") ;; Mac
% \end{Salltt}
% Note that when you are specifying a path under Windows, you should
% avoid spaces (that is use {\stexttt{"progra~1"}}, not \stexttt{"Program Files"}) and you
% should use forward slashes \stexttt{"/"}.  There may be occasions when you want
% to run a particular buffer under a different version of SAS or specify
% different options on the command line.  In that case, you can
% over-ride \stexttt{ess-sas-submit-command} in your local buffer with file
% variables or other means.

% There is a built-in delay before a batch SAS job is submitted when using
% a Unix shell under either Unix or Windows.  This is necessary in many cases 
% since the shell might not be ready to receive a command.  This delay is 
% currently set high enough so as not to be a problem on any system.  But,
% there may be cases when it needs to be set higher, or could be set much
% lower to speed things up.  You can over-ride the default in your \stexttt{.emacs}
% file by (the default of 5 seconds is shown):
% \elcode{(setq ess-sleep-for 5)}


% \subsection{Using Transcripts}
% \label{sec:SAS:trans}
% 
% Not yet available.  The intent is that a marked section of a log file
% from a previous SAS run can be resubmitted to SAS.  The user would
% highlight a region from 'PROC' to 'RUN;' and then send it to the
% inferior SAS process with the [RET] key.  ESS would automatically
% clean the region (remove line numbers) and send the entire region over
% as a single request to SAS.
% 

\subsubsection{Inferior SAS processes}
\label{sec:SAS:proc:inf}

\stexttt{iESS} (inferior ESS) is the mode for interfacing with active
statistical processes (programs).  To start up \stexttt{iESS[SAS]} mode, use:
\elcode{M-x SAS}
% We plan to add the ability to request help from a process for
% variables and functions, and to have the results sent into a separate
% buffer, as well as the completion of object names and file names.
A single instance of SAS is started in an \file{iESS[SAS]} buffer.  Individual
\stexttt{DATA} and \stexttt{PROC} steps are sent to this instance of SAS and the results
are appended to the \file{*log*} and \file{*lst*} buffers.

The \stexttt{iESS[SAS]} mode was written with two primary goals.
\begin{itemize}
\item Using Emacs, a window environment becomes available for dial-up
  users who do not have access to the SAS window environment.
\item The authors prefer the Emacs environment for editing and
  managing input and output files, even on computer systems which run
  the SAS window environment.
\end{itemize}
A secondary goal was also realized.  With an X-windows
terminal connected by ppp at (the now slow speed of)
14400 baud to a Unix system running SAS,
\stexttt{iESS[SAS]} interaction with SAS was hundreds of times faster than the
SAS window system.  The savings come because the ESS windows are
subunits of a text-based xterm window, rather than the remotely
managed graphical windows provided by SAS.  (The timings are SAS
timings from the log files.  The SAS windows times include window
management and communications times as well as calculation times.  The
\stexttt{iESS} times include only the calculations by the SAS computing engine.)

\subsubsection{ESS and Display Manager}
It is possible to use ESS for editing SAS files with \stexttt{ESS[SAS]} mode
and then pick up the file or a region and drop it directly into the SAS
Display Manager \ssf{Program Editor} window.
%% This method gives the user access to
%% interactive SAS graphics.  With any of the other Emacs interactions, the user
%% is limited to static graphics, for example by printing to a postscript device.

\subsubsection{SAS elsewhere}

\paragraph{Batch Processing.}
Batch Processing works when Emacs is running on a local machine and SAS
is running on a remote machine.  The local machine must be directly
connected to the network (possibly by ppp).\\
Set the \stexttt{ess-sas-submit-method} with
\elcode{(setq-default ess-sas-submit-method 'iESS)}
and behave exactly as if the SAS process were local.\\
Edit the remote file
\file{/other.machine:myfile.sas}
in the local Emacs.
When it is submitted, it will automatically be saved back to the remote
machine and be exactly where the remote SAS will find it.

\paragraph{\stexttt{iESS} Processing on remote Emacs.}
Telnet to a remote computer using a telnet client other than an Emacs buffer.
Run an Emacs on the remote machine in the telnet window.
Run \stexttt{M-x SAS} on the remote machine in that remote instance of Emacs.

\paragraph{\stexttt{iESS} Processing on local Emacs.}
In principle, this can be done, but none of us has found the need
compelling.  Essentially what is needed is for three independent shell
processes to be connected to the remote machine.  The SAS process on
the remote machine runs in one of the shell windows, and redirects its
log output and its lst output to the other two.


\subsection{Design of \texttt{ESS[SAS]} mode}
\label{sec:SAS:phil}

\stexttt{ESS[SAS]} mode was designed to aid the user in writing and maintaining
input command files, such as \file{myfile.sas}, for SAS.  These are files
containing SAS statements.  In a batch environment such files would be
submitted to SAS by the operating system command:
\elcode{sas myfile.sas}
In a SAS window environment, these files would be brought into the
\ssf{SAS: PROGRAM EDITOR} window and then submitted with the
\ssf{Local/Submit}
menu commands.

The \file{*SAS:1.log*} or \file{myfile.log} buffer in \stexttt{ESStr} mode
corresponds to the file \file{myfile.log} in SAS batch usage and to the
\ssf{SAS: LOG} window in the SAS window environment.  All commands
submitted to SAS, informative messages, warnings, and errors appear
here.

The \file{*SAS:1.lst*} or \file{myfile.lst} buffer in \stexttt{ESSlst} mode
corresponds to the file \file{myfile.lst} in SAS batch usage and to the
\ssf{SAS: OUTPUT} window in the SAS window environment.  All data-related
printed output from the \stexttt{PROC}s appear in this window.

The interactive \stexttt{iESS [SAS:1]} buffer exists solely as a communications buffer.
Files are edited in the \file{myfile.sas} buffer.  The \stexttt{C-c C-r} key in
\stexttt{ESS[SAS]} mode is the functional equivalent of bringing a file into the
\ssf{SAS: PROGRAM EDITOR} window followed by the \ssf{Local/Submit} menu
commands.  The user should never use this buffer directly.

\section{Obtaining ESS}
\label{sec:getIt}

ESS is primarily located at \stexttt{ess.stat.wisc.edu}, and is available by FTP
or through the World-Wide-Web (WWW).  A basic installation consists of
downloading the package, unpacking, and then adding a line to the
Emacs initialization file (\file{.emacs} or \file{\US emacs}), pointing
to the lisp subdirectory of the unpacked archive.  Unix users, but not
Windows users, may choose to do an optional installation by executing
the Makefile that comes with the ESS package.

There exist binary packages for various Linux distributions, as well,
including Debian, RedHat, Mandrake, and SuSE.

\section{History}
\label{sec:history}

ESS (originally S-mode) was initially designed for use with S and
\Splus\tm; hence, this family of statistical languages currently has
the most support.  We use S generically to denote any of the currently
available implementations in this of the family, including S 3.x, S
4.x, \Splus~3.x, \Splus~4.x (incl.\ \Splus~2000), \Splus~5.x,
\Splus~6.x and R.  In addition, we use Emacs to denote the GNU family
of editors which can be represented either by Emacs, as developed and
maintained by the Free Software Foundation, or XEmacs, which is a
derivative work.

ESS originated from the extension for programming and process
interface in Emacs supplied by S-mode (D. Bates, F. Ritter, et.al.; 
M. Meyer; D. Smith).  The extension to a language-independent generic
interface was prompted by the success of R, and the need for an
R-mode.  This led to a merger with the SAS-mode (T. Cook), and the
refactoring of the S-mode codebase to accommodate multiple languages
in a flexible way.
%  A detailed history can be found in section~\ref{sec:history}.

ESS is a remarkable example of how open-source products can continue
to develop beyond what their initial authors planned.  ESS started as
S-mode, an Emacs extension which was developed in 1991 as a simple
tool for editing program files for S and \Splus.  In 1994, Rossini
extended S-mode to support XEmacs, which is a forked version of
Emacs.  At the same time, Rossini extended a successful SAS-mode
written by Tom Cook to work with XEmacs.  In 1995, S-mode was merged
into a uniform S-mode for Emacs, XEmacs, and supported S, \Splus, and
R.  During 1996 and 1997, Richard M. Heiberger incorporated 
SAS-mode into ESS and designed the inferior ESS mode for SAS.
At the same time Rossini developed a
generic means for configuring ESS to accommodate changed as well as
new statistical languages.

Most of this was primarily done under Unix.  Beginning in 1998, thanks
to an example of interprocess communication using Microsoft's DDE by
Brian Ripley, Richard M. Heiberger provided interfaces for \Splus~4.x
and then \Splus~2000 and \Splus~6.x.  

Beginning in 1998, Rodney Sparapani designed the SAS batch interaction
mode.  Sparapani and Heiberger developed SAS batch support including
function key behavior that followed SAS Institute's function key
definitions,  developed a more comprehensive and efficient syntax
highlighting mechanism using the Emacs \stexttt{font-lock-mode},
extended the  \stexttt{*ESS-elsewhere*} functionality to include SAS processes,
and provided  automated error message lookup in the log file.
These are features that people using SAS today
actually need and want.  ESS is now by far the best environment for
SAS available at any price and it's free.

\section{Remarks and Extensions}
\label{sec:remarks}

%Much of what has been done recently is debugging and tuning.  
New
features in the plans include robust extensions for Literate Data
Analysis using Noweb \citep{NRamsey:1994}, as well as extensions for
XML-based Literate Statistical Analysis.

There are two active areas of extensions for user environments.  One
is to enhance the capabilities of the IDE for statistical practice;
this includes implementing such common IDE features as object browsers
as well as clean up the interface.

The other exciting extension is towards the use of Literate
Programming methodologies \citep{Knuth:1992,NRamsey:1994}, which we
will refer to as Literate Statistical Analysis \citep{ross:lunt:2001}.
The tools include the use of Noweb \citep{NRamsey:1994} and an
additional step towards the use of an XML authoring environment for
statistical analysis.  Literate Data Analysis based on Noweb, is a
means of documenting a statistical analysis plan and procedure.
Literate Statistical Analysis is intended to be a round-trip
environment for both design and analysis.
{\bf Tony, we need two sentences here saying what Literate Statistical Analysis
is and why we should want it.}\marpar{Tony}


The future use of XML is to accommodate the growing use of WWW-based
services for document publishing as well as information conversion.
XML is the next generation of the popular web-authoring language HTML.
XML provides to the user the ability to provide new functionally defined tags
for the document.  HTML tags are limited to font-selection.  Thus in HTML
we can say {\bf put this phrase in bold}, but we can't say why.  In XML
\marpar{Tony, check this for validity.}
we can say, {\bf this phrase is \underline{important}} and have a general
instruction that says \underline{important} phrases should be displayed in bold
face, or perhaps in another setting that \underline{important} phrases should
be printed in red type.  A style description file tells the browser how to
display \underline{important} phrases.  Such a style file is not available
when the only information we have on the phrase is that it should be bold.
By marking up the document with XML, it is possible to display subsets
of the document contextually according to the intent of the document.

Unlike Literate Data Analysis, \marpar{We need a sentence here summarizing DOM}
which provides a single document for
code and analysis plan, Literate Statistical Analysis is a round-trip
cycle, using document modification through the Document Object Model
interface (W3 Consortium).  This is described more in
\citep{ross:lunt:2001}.

\textbf{RODNEY:} Are you telling the reader where ESS is going?  If
so, this is news to me.  I'm guessing that ESS is going to add BUGS
(that's my plan) and will have better support for all of the packages
you mentioned: S et.~al., SAS, \Stata, \XLispStat, etc.  If I am
confused, then many readers will be to.

\bibliographystyle{plainnat} %alpha}
\bibliography{ess}


\newpage
\appendix

\textbf{rmh: these appendices do not belong in the published article.
They are part of the documentation that comes with the program.}

\section{Scenarios for Use}
\label{app:scenarios}

The Appendix sections discuss specific use patterns for ESS under two very
different statistical language systems, S and SAS.

\subsection{Scenarios for using S}
\label{sec:S:scenarios}

We present some basic suggestions for using ESS to interact with S.
We illustrate both data analysis and program revision examples under
the philosophies that source code is real.
Examples using the philosophy that S objects are real is available in
the documentation distributed with ESS.

\subsubsection{Data Analysis Example (source code is real)}
The current ESS developers recommend this procedure.

\noindent
Load the file you want to work with
  \elcode{C-x C-f myfile.s}
Edit as appropriate, and then start up \Splus\ or R,
  \elcode{M-x S}
or 
  \elcode{M-x R}
A new buffer \file{*S+x:1*} or \file{*R:1*} will appear.
\Splus\ or R will have been started
in this buffer.  The buffer is in \stexttt{iESS [S]} or \stexttt{iESS [R]} mode.
Under Windows, the \Splus\ buffers are in  \stexttt{ddeESS [S]} mode.

Split the screen and go back to the file editing buffer.
  \elcode{C-x 2 C-x b myfile.s}
Send regions, lines, or the entire file contents to \Splus.
For regions, highlight a region with keystrokes or mouse
and then send with:
  \elcode{C-c C-r}
For R on all platforms and for \Splus\ on Unix, the commands appear in
the \file{*S+x:1*} buffer and the program's response also appears.
For \Splus\ on Windows, the commands are forwarded to the \Splus\ Commands
window and the program's response also appears in the Commands window.

Re-edit \file{myfile.s} as necessary to correct any difficulties.  Add
new commands here.  Send them to S by region with
  \elcode{C-c C-r}
or one line at a time with
  \elcode{C-c C-n}
Save the revised \file{myfile.s} with \stexttt{C-x C-s}.

Save the entire \file{*S+x:1*} interaction buffer with \stexttt{C-x C-s}.
You will be prompted for a file name.  The recommended name is
\file{myfile.St} (\stexttt{St} for S Transcript).
Files with the \file{*.St} suffix will automatically come up in ESS
Transcript mode the next time they are accessed from Emacs.


\subsubsection{Program revision example (source code is real)}
The current ESS developers recommend this procedure.

\noindent
Start up \Splus\ in a process buffer (this will be \file{*S+3:1*})
  \elcode{M-x S}
Load the file you want to work with
  \elcode{C-x C-f myfile.s}
Edit program, functions, and code in \file{myfile.s}.
When ready, send revised functions to S with
  \elcode{C-c C-f}
or send highlighted regions with
  \elcode{C-c C-r}
or send individual lines with
  \elcode{C-c C-n}
or load the entire buffer into S with
  \elcode{C-c C-l}
Save the revised \file{myfile.s} when you have finished
  \stexttt{C-x C-s}

%\subsubsection{Program revision example (S object is real)}
%The current ESS developers do {\bf not} recommend this procedure.

%\noindent
%Start up \Splus~3.x, in a process buffer (this will be \file{*S+3:1*}) 
%  \elcode{M-x S+3}
%Dump an existing S object my.function into a buffer to work with
%  \elcode{C-c C-d my.function}
%a new buffer named \textit{yourloginname}.my.function.S will be created with
%an editable copy of the object.  The buffer is associated with the
%pathname
% \elcode{/tmp/\textit{yourloginname}.my.function.S}
%and will almost certainly not exist after you log off.

%Enter program, functions, and code into work buffer,
%and send entire contents to \Splus\ when ready:
%  \elcode{C-c C-b}
%Go to the \file{*S+3:1*} buffer, which is the process buffer, and examine
%the results.
%  \elcode{C-c C-y}
%The sequence \stexttt{C-c C-y} is a shortcut for:  \stexttt{C-x b *S+3:1*}

%Return to the work buffer (may/may not be prefixed)
%  \elcode{C-x C-b \textit{yourloginname}.my.function.S}
%Fix the function that didn't work, and resubmit by
%placing the cursor somewhere in the function and
%  \elcode{C-c C-f}
%Or select a region (using the mouse, or keyboard
%via setting point/mark) and
%  \elcode{C-c C-r}
%Or step through, line by line, using
%  \elcode{C-c C-n}
%Or just send a single line (without moving to the next) using
%  \elcode{C-c C-j}
%To fix that error in syntax for the \stexttt{rchisq} command, get help
%by
%  \elcode{C-c C-v rchisq}

%\subsubsection{Data Analysis (S object is real)}
%The current ESS developers do {\bf not} recommend this procedure.

%\noindent
%Start up R in a process buffer (this will be \textbf{*R*}) 
%  \elcode{M-x R}
%Work in the process buffer.  When you find an object that needs
%to be changed (this could be a data frame, or a variable,
%or a function), dump it to a buffer:
%  \elcode{C-c C-d my.cool.function}
%Edit the function as appropriate, and dump back in to the
%process buffer
%  \elcode{C-c C-b}
%Return to the R process buffer
%  \elcode{C-c C-y}
%Continue working.
%When you need help, use
%  \elcode{C-c C-v rchisq}
%(which you can do using command name completion)
%but entering:   \stexttt{help("rchisq")} or \stexttt{?rchisq}
%will bring up the help file in a separate buffer
%\emph{--- currently only for \textbf{*R*}}.

\subsection{Scenarios for using SAS}
\label{sec:SAS:scen}

We present three scenarios for using ESS to interact with SAS.  The
first two mimic different aspects of the SAS Display Manager behavior.
The Batch scenario sends an entire
\file{myfile.sas} file over to SAS and receives
\file{myfile.log} and \file{myfile.lst} back.  The Interactive
scenario sends one \stexttt{DATA} step or one \stexttt{PROC} step over
at a time and receives back increments to the \file{myfile.log} and
\file{myfile.lst} files.  Both scenarios work with SAS running
either on the same machine that Emacs is running on, or on a remote
machine.  The third uses ESS for editing and then submits the file using the SAS
Display Manager itself.  Further detailed instructions can be found in the ESS
documentation.

%We recommend the following line appear in your \file{autoexec.sas}
%in your home directory on the machine running SAS: 
%\elcode{options noovp pagesize=60 linesize=80 formdlim=' ';}
%Interpretations\\
%\begin{tabular}{ll}
%\stexttt   noovp         & prevents error messages from printing 3
%                          times         \\ 
%\stexttt   pagesize=60   & standard printed page length instead of
%                          window length \\ 
%\stexttt   linesize=80   & keeps output lines from folding on standard
%                          terminals \\ 
%\stexttt   formdlim=' '  & blank replaces \stexttt{C-l} formfeeds to
%                          prevent mostly  \\ 
%\stexttt                 & empty printed pages                     \\
%\end{tabular}\\

\subsubsection{Batch SAS}
\label{sec:SAS:batch}

A complete SAS job, multiple \stexttt{DATA} and \stexttt{PROC} steps,
is sent over to a new instance of SAS.  The results from the complete
job are received back in \file{.log} and \file{.lst} files.
The keystrokes illustrated match the SAS Unix keystrokes.
SAS Windows keys are identified in the comments

Find the file you want to work with
    \elcode{C-x C-f myfile.sas}
\file{myfile.sas} will be in \stexttt{ESS[SAS]} mode.
Edit as appropriate, then save and submit the batch SAS job.
    \elcode{F3  /*-pc- F8*/}
The job runs in the shell buffer while you continue to edit 
\file{myfile.sas}.  If you are running a Unix shell (under Unix or
Windows) the message buffer will notify you with a shell
notification when the job is complete.  If so, then you 
will also have the option of terminating the batch job
before it is finished.
    \elcode{F8  /*-pc- F3*/}
In any case, you may want to visit the \file{.log} while the process
is still running (Unix only) or when it is done and check for
error messages 
(you will be taken to the next error message, if any).
The \file{.log} will be refreshed and it's buffer will be made active.
    \elcode{F5  /*-pc- F6*/}
Now, refresh the \file{.lst} and go to it's buffer.
    \elcode{F6  /*-pc- F7*/}
If you wish to make changes, go to the \file{.sas} file with
    \elcode{F4 /*-pc- F5*/}
and make your editing changes.  The go back to the submit instruction.

\stexttt{PROC GPLOT} graphs will normally be produced in a postscript
file and be viewed later.  Include the lines
\begin{Salltt}
    /* required goptions for batch files */
    /* comment out these lines for interactive use on X-terminals*/
    filename grafout 'temp.ps';
    goptions device=ps gsfname=grafout gsfmode=append gaccess=sasgastd;
\end{Salltt}
\noindent
in \file{myfile.sas}.


\subsubsection{Interactive SAS in an inferior ESS buffer}
A single instance of SAS is started in an \stexttt{iESS[SAS]} buffer.
Individual \stexttt{DATA} and \stexttt{PROC} steps are sent to this
instance of SAS and the results are appended to the \file{*log*}
and \file{*lst*} buffers.

Find the file you want to work with
    \elcode{C-x C-f myfile.sas}
\file{myfile.sas} will be in \stexttt{ESS[SAS]} mode.
Edit as appropriate, and then start up SAS with the cursor in
the \file{myfile.sas} buffer
    \elcode{M-x SAS}
Four buffers will appear on screen:\\
\begin{tabular}{lll}  \hline
  Buffer name     & Emacs mode         & use\\  \hline
  \stexttt{myfile.sas}  & \stexttt{ESS[SAS]}       &source file   \\
  \stexttt{*SAS:1*}     & \stexttt{iESS [SAS:1]}   &ESS communication buffer \\
  \stexttt{*SAS:1.log*} & \stexttt{Shell [] ESStr} &SAS log information      \\
  \stexttt{*SAS:1.lst*} & \stexttt{Shell [] ESSlst}&SAS listing information  \\
  \hline
\end{tabular}\\[1ex]
If you would prefer each of the four buffers to appear in its own
individual frame, you can arrange for that.  Place the cursor in the
buffer displaying \file{myfile.sas}.  Enter the sequence \stexttt{C-c C-w}.
The cursor will normally be in buffer \file{myfile.sas}.  If
not, put it there:
    \elcode{C-x b myfile.sas}
Send regions, lines, or the entire file contents to SAS
(regions are the most useful).  A highlighted region will normally
begin with the keywords \stexttt{DATA} or \stexttt{PROC} and end with the
keyword \stexttt{RUN;}
    \elcode{C-c C-r}
Information appears in the log buffer, analysis results in the
listing buffer.  In case of errors, make the corrections in the
\file{myfile.sas} buffer and resubmit with another \stexttt{C-c C-r}

\stexttt{PROC GPLOT} graphs will normally be produced in a postscript
file and be viewed later.  Include the lines
\begin{Salltt}
    /* required goptions for batch files */
    /* comment out these lines for interactive use on X-terminals*/
    filename grafout 'temp.ps';
    goptions device=ps gsfname=grafout gsfmode=append gaccess=sasgastd;
\end{Salltt}
\noindent
in \file{myfile.sas}.

\stexttt{PROC PLOT} graphs can be viewed in the listing buffer.  You
may wish to control the vertical spacing to allow the entire plot to
be visible on screen, for example, by\\
\stexttt{proc plot; plot a*b / vpos=25;}
 
At the end of the session you may save the log and listing buffers
with the usual \stexttt{C-x C-s} commands.  You will be prompted for a
file name.  Typically, the names \file{myfile.log} and
\file{myfile.lst} will be used.  You will almost certainly want to
edit the saved files before including them in a report.  The files are
read-only by default.  You can make them writable by the Emacs command
\stexttt{C-x C-q}.
 
At the end of the session, the input file \file{myfile.sas} will
typically have been revised.  You can save it.  It can be used later
as the beginning of another \stexttt{iESS[SAS]} session.  It can also
be used as a batch input file to SAS.
 
The \file{*SAS:1*} buffer is strictly for ESS use.  The user should
never need to read it or write to it.  Refer to the \file{.lst} and
\file{.log} buffers for monitoring output.

%% Here is a typical \file{myfile.sas}:
%% \begin{Salltt}
%%     title 'Analysis of Case 0502';
%% 
%%     data case0502;
%%         infile '/home/public/stat/Data/case0502.asc'
%%                firstobs=2;
%%         input percent code;
%%     run;
%% 
%%     proc glm;
%%       class code;
%%       model percent=code /ss1;
%%     run;
%% \end{Salltt}


%For the Interactive scenario,
%the default settings of the \stexttt{inferior-SAS-args} in \file{essd-sas.el}
%are \stexttt{-stdio -linesize 80 -noovp -nosyntaxcheck}
%with the interpretations:\\
%\begin{tabular}{ll}
%\stexttt  -stdio          &required to make the redirection of stdio work       \\
%\stexttt  -linesize 80    &keeps output lines from folding on standard terminals\\
%\stexttt  -noovp          &prevents error messages from printing 3 times        \\
%\stexttt  -nosyntaxcheck  &permits recovery after syntax errors                 \\
%\end{tabular}\\
%The \stexttt{noovp} and \stexttt{linesize=80} appear in both the
%\stexttt{inferior-SAS-args} and in the \file{autoexec.sas}.  The
%redundancy means that these options are in effect for SAS batch usage
%and SAS window manager usage as well as for \stexttt{iESS[SAS]} usage.

\subsubsection{SAS Display Manager}
\label{sec:SAS:display}
This interaction procedure gives you the full Emacs editing capabilities
and the full graphical interaction with the SAS Display Manager, particularly
the access to the interactive graphics windows.

Find the file you want to work with
    \elcode{C-x C-f myfile.sas}
\file{myfile.sas} will be in \stexttt{ESS[SAS]} mode.
Edit as appropriate, and then highlight a region to be submitted to
SAS.  Move the cursor to the SAS Display Manager \ssf{PROGRAM EDITOR} window.
Paste the region there and press the SAS \ssf{RUN} button.

Revisions to the SAS code are made in the Emacs \file{myfile.sas}
buffer.  Useful portions of the SAS log and listing windows can be
copied and placed in new Emacs buffers or dropped directly into a
document in Emacs or in another editor.
\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ess"
%%% End: 

