\documentclass{article}

%\usepackage{2up}

%%% 
\usepackage[authoryear,round]{natbib}
%or (if you have an unshiny latex installation)
%\newcommand{\citep}[1]{{\{\sf#1\}}}
%%%
\usepackage{alltt}

%% Postscript fonts
%\usepackage{palatcm}
\usepackage{times}
%%% \usepackage{amsmath}

%% The following is for creating PDF.
\newif\ifpdf
\ifx\pdfoutput\undefined
  \pdffalse     % not running PDFLaTeX
\else
  \pdfoutput=1  % running PDFLaTeX
  \pdftrue
\fi

\ifpdf
  \usepackage{thumbpdf}
\fi
%\usepackage{html,heqn,htmllist}
%\usepackage[latex2html]{hyperref} 
\ifpdf
  \usepackage[pdftex]{graphicx}
  \usepackage[pdftex]{hyperref} 
\else
  \usepackage[dvips]{graphicx}
  \usepackage[dvips]{hyperref} 
\fi

%%---End of package requiring ---------- Own Definitions ------------- 

\hypersetup{backref,colorlinks=true,pagebackref=true,
  hyperindex=true}%pdfpagemode=FullScreen,

\newcommand*{\Splus}{\textsc{S-Plus}}
%\newcommand*{\Scmt}[1]{\hfill \#\# \textsl{#1}}
\newcommand*{\Scmt}[1]{\hbox{\qquad {\footnotesize \#\#} \textsl{#1}}}
\newtheorem{defn}{Definition}[section]
\newtheorem{ex}{Example}[section]

\newcommand{\elcode}[1]{\\{\tt\hspace*{2em} #1}\\}
\newcommand{\tm}{$^{\mbox{\scriptsize\sc tm}}$}
\newenvironment{Salltt}{\small\begin{alltt}}{\end{alltt}}

%%--------------------------------------------------------------- Start Text

\title{Emacs Speaks Statistics: A Universal Interface for
  Statistical Analysis}  

\author{A.J. Rossini\footnote{Department of Biostatistics, University
    of Washington and Fred Hutchinson Cancer Research Center, Seattle,
    WA, USA} \and Martin M{\"a}chler\footnote{Seminar for Statistics;
    ETH Zurich; Zurich, Switzerland} \and Kurt
  Hornik\footnote{Technische Universit{\"a}t Wien, Vienna, Austria}
  \and Richard M. Heiberger\footnote{Temple University; Philadelphia,
    PA, USA} \and Rodney Sparapani\footnote{Medical College of
    Wisconsin, WI, USA}}

\date{\today}

\begin{document}

\ifpdf
  \DeclareGraphicsExtensions{.jpg,.pdf,.png,.mps}
\fi

%%%% To cite everything
%%\nocite{*} 

\maketitle

Keywords: Statistical Analysis, Programming, User Interfaces, SAS,
S-PLUS, R, XLispStat, Stata

\begin{abstract}
  We discuss Emacs Speaks Statistics (ESS), a user interface for
  statistical programming based on Emacs, intended for developing
  statistical applications and performing data analysis.  It falls in
  the programming tools category of Integrated Development
  Environments (IDEs).  We discuss how it works, why one should use
  it, and extensions which increase the programming efficiency for
  statistical programming.
\end{abstract}

\section{Introduction}
\label{sec:intro}

Integrated Development Environments (IDEs) combine features and tools
in a single interface in an attempt to increase programmer
productivity and efficiency.  The increased speed in commercial
software development time over the last decade can be partially
attributed to the use of IDEs and similar Rapid Application
Development (RAD) tools and methodologies.  In the field of
statistics, programming is an important skill which can be augmented
and enhanced by the right tools and environment.  This is especially
important with the rise of computational tools such as resampling
methods such as the bootstrap and jackknife, as well as simulation
methods such as Markov Chain Monte Carlo (MCMC).

In the field of statistics, different analytic tools are targeted for
particular styles of statistical analysis.  This suggests that
efficiency work habits can require switching between data analysis
tools.  One example is that general purpose tools such as R
\citep{ihak:gent:1996} are not as easy to use performing Bayesian
analyses as special tools such as BUGS \citep{SpieThomBest:1999}.  On
the other hand, these specialized tools can not be efficiently used to
handle general analyses and graphical summaries.  This suggests a
potential efficiency gain through the use of using multiple
computational tools for complex statistical analyses.  However, most
of these tools have their own idiosyncratic user interfaces, which can
negate any possible efficiency gain.

Emacs Speaks Statistics (ESS) provides a single interface for a family
of statistical computing tasks using a keyboard.  The primary user
tasks which ESS focuses on for optimization and efficiency are
statistical coding and interactive data analysis.  Statistical coding
is the writing of computer code for data analysis.  This code might be
C or Fortran, with the intent to compile into an object file using a
compiler, or it might be run by an interpreter, for example, \Splus\,
SAS, R, or Python.  The task of entering of commands for interactive
data analysis is similar.  The primary difference is that the results
of a small set of commands are of critical interest for review in the
latter, but the results of all commands are of interest in the former.
Both of these tasks can be present at the same time, for example in
the use of compiled Fortran code for optimization, which is being
called from an interpreted language, such as \Splus, R, or XLispStat,
containing the objective function to optimize.

Very few statistical packages have identical command-line interfaces;
this is in addition to the differences between the actual macro or
programming languages.  This means that it might be necessary for a
statistical analyst to learn 2 or 3 different text-based interfaces
for editing and executing code.  Furthermore, it might be necessary
for the analyst to consider dialects of a language, for example under
the S family of languages, there is R, \Splus, the original S
implementation, as well as different versions of all three.  Testing
code meant for use by others necessitates having it work in multiple
versions, so being able to quickly test means having quick access to
all versions; this might mean having to be able to access programs
which can only run on completely different sets of machines.  For
example, one might want to be connected to multiple R processes.
Reasons for this include verifying behavior on different versions of
the same software, test and run scenarios where one process is doing
long-term processing while the other is doing short-term testing,
simulations, running multiple processes on multiple machines from the
same place.

ESS provides an interface which mitigates some of the problems noted
above.  It provides an editing interface, an interface to statistical
processes, and additional tools which can be useful for both
statistical software development and data analysis.  It works with
common statistical software including the S family of languages
including S \citep{BecRCW88,ChaJH92,ChaJ98}, \Splus\ \citep{Splus},
and R \citep{ihak:gent:1996}; XLispStat \citep{Tier90} including its
extensions Arc \citep{Cook:Weisberg:1999} and ViSta
\citep{youn:fald:mcfa:1992}; SAS \citep{SAS:8.0}; Stata
\citep{Stata:6.0}; Omegahat \citep{DTLang:2000}; and can be extended
in at least a limited way to most statistical packages which can be
controlled from a command-line.

The rest of this introduction will discuss the proposed development
environment and how it can be used.  Sections \ref{sec:S} and
\ref{sec:SAS} will discuss how this is realized for two different
statistical languages, the S family and SAS.  This will be followed by
the project's history, concluding with a discussion of future
extensions and related work.

\subsection{Emacs}
\label{sec:intro:emacs}

Emacs \citep{RMS:2000} is a mature, powerful, and easily extensible
text editor which is freely available, under the terms of the Free
Software Foundation's Copy-left agreement, for a large number of
environments.  These include frequently used statistical computing
platforms such as Apple Corporation's Macintosh platform, and
Microsoft-based operating system.  Emacs has been around for many
years, and in the past was considered as one of the primary options
for text editing on many Unix systems.

Most programming and documentation tasks fall under the realm of text
editing.  This work can be enhanced by common IDE features such as
contextual highlighting and recognition of special reserved words for
the programming language being used.  In addition, editor behaviors
such as folding, outlining, and bookmarking can assist with
maneuvering around a file.  One task which is not in this realm is
word processing, which focuses on producing a presentation of a
document, in addition to text editing.  While Emacs is not a word
processor, it does share some features.

ESS provides Emacs with an easily extensible and uniform interface to
text handling for statistical packages.  The capabilities can be
extended in an orthogonal manner to include other Emacs packages for
assisting with documentation (\LaTeX; SGML, XML, and XSLT; Noweb);
version control (RCS,CVS,SCCS, PRCS); and remote editing via FTP or
secure mechanisms such as SSH/SCP.  It handles the interface to both
source code and transcripts contextually, providing syntax
highlighting, bookmarking features, interfaces to directory structure,
and command-history.

Emacs provides a sophisticated development environment for programming
in traditional compiled languages such as C, C++, and Fortran as well
as non-traditional byte-compiled and interpreted languages such as
Perl, Java, and Python.  It provides interfaces to build tools such as
make as well as debugging tools through the use of external debuggers
such as JDebug, gdb, and dbx.  Finally, it assists with project tasks
such as documentation of changes, design, and version control.

Other extensions to Emacs allow it to act as a World-Wide-Web browser,
a highly sophisticated mail and news reader, a shell/terminal window
with history, and as an interface to other common text-based tools
such as spell checking programs.  The emacs keyboard and mouse interface can
be re-mapped
to resemble that of other text-editors, such as ed, vi, wordstar, and
brief.  

The user interface to Emacs is by keyboard or mouse.  
Keystrokes are available on all platforms.  The mouse and menus are available
on all systems, including both windowing and
non-windowing environments,  which support it.  The mouse-based interface, through menus
and toolbars, also tries to facilitate the learning of keystroke-based
short-cuts.  
Additional menus can be defined by the user should they be needed.

Emacs was one of the first tools available with a programmable
extension language, a dialect of Lisp
\citep{RChassell1999,PGraham:1996}.  There are many examples of
specialized extensions for assisting and facilitating common editing
tasks.  This includes complex tasks such as connections with
spreadsheets, database front and backends, forms entry, and even
interactive games such as tetris.    Fundamentally important editing
tasks such as
programming Makefiles, scripts, and compiled code in all standard and many
non-standard computer languages are included.

Emacs also has an internal help system and tutorial for its use.
Appendix~\ref{app:scenarios} provides sample sessions to help
familiarize one with approaches for using Emacs with ESS.

The above reasons make Emacs a reasonable choice as a starting point
for providing a universal interface for data analysis and programming.
ESS is an attempt to provide a functional and extensible common
interface to multiple packages.

\section{Statistical User Interfaces}
\label{sec:UI}

For the purposes of the user interface, recent and traditional
interfaces for statistical packages and languages can generally be
classified into 3 forms.  There is the command-line interface that
most of the packages have available; this is the interface that ESS
needs for interfacing at the process level.  There is also the
spreadsheet/MDI interface employed by  spreadsheet packages as
well as most Apple and Microsoft-based statistical packages.  In
addition, there have been other specially designed implementation interfaces,
which include graph-based interfaces as implemented in ViSta
\citep{youn:lubi:1995}, the SAS terminal interface, which divides the
terminal window into 3 screens, and possibly others.  Another approach
is taken by DataDesk \citep{vell:prat:1989}, which provides a visual
and tightly linked interface.

\subsection{Command line interfaces}
\label{sec:UI:command}

The classic command-line interface is still available for statistical
packages on most Unix and mainframe computers.  This generally
consists of typing a single line at a time, with some form of
wrap-around for those lines which are extremely long in terms of
character counts.  For example, \Splus, R, Stata, XLispStat, and SAS
still have command-line interfaces, though they are currently deemphasized.
For example, it is difficult to determine how to use
it under SAS, and the Stata interface is deprecated towards use of a
newer GUI.

ESS assists command-line interfaces by providing a comprehensive
interface layer on top of the command-line.

\subsection{Graphical User Interfaces}
\label{sec:UI:GUI}

The advent of the Apple Macintosh and Microsoft Windows operating
systems have encouraged a partial standardization of interfaces for
statistical packages.  Many packages written for both IBM-based and
Apple-based personal computers have adopted a data display 
descended from the spreadsheet
data-table approach.  Generally, these feature a cases-by-variables
spreadsheet representation of the data, along with pull-down menus and
dialog boxes for data analysis activities.  Depending upon their
nature, numerical results can be saved on the spreadsheet.  Software
that takes this approach includes SPSS, Minitab, \Splus 4.x for Windows and 6.x for Unix and Windows,
DataDesk, ViSta, and many others.

\subsection{ESS}
\label{sec:UI:ESS}

ESS provides a front-end text-based user interface to a variety of
interactive statistical programs and interpreted statistical
languages.  There are various levels of support depending on their
capabilities and needs.  Because of it's history, ESS supports the S
family of languages extremely well; these include recent versions of
S, \Splus, and R.  SAS is also well supported, but to a lesser extent.
Syntax highlighting and
the extremely well-designed editing facilities of emacs are most
heavily used. 
The lack of objects in SAS has prevented the use of object completion
facilities.  Stata and XLispStat (and the XLispStat extensions, ARC
and ViSta) are supported with the basic functionality, syntax
highlighting and process-interfacing that
the majority of ESS users take advantage of.  This appears to be
sufficient to differentiate from typical package-provided interfaces.

\section{Features and Use}
\label{sec:basic}


ESS provides a number of features for statistical programming beyond
those provided by Emacs, as listed in section~\ref{sec:intro:emacs}.

\paragraph{Syntactic indentation and highlighting of source code}
For the interface with the programming language code as well as the
interface with the statistical program, this includes syntax
highlighting to denote assignment, reserved words, presence of
strings.  For the programming code, to assist with providing a clear
presentation, customizable automatic indentation is possible, with the
customization relating to how one would want to indent groups of
expression.  For the interface with the statistics package/program,
there is also a means of searching the command-line history for
previous commands as well as editing past commands for current use.

\paragraph{Partial evaluations of code}
These are connected by the ability to send, within Emacs, lines,
functions, regions, and whole edited buffers from the programming code
to the statistical program/package for execution.  In addition, it is
possible to have Emacs complete file names from the current underlying
working directory.

In addition to the above, for languages in the S family, including S
(versions 3 and 4, developed at Bell Labs), \Splus (all versions), and
R (all versions), there is object-name completion of both user and
system based functions and data.  There is also the ability to dump
and save objects (user and system generated) into text files in a
formatted manner for editing, as well as to reload after possible
editing back into the statistical package/process.

\paragraph{Source code checking}
ESS also facilitates the editing of source code by providing a means
for loading and error-checking of small sections of
code for S, XLispStat, and SAS.  This
allows for one form of crude source-level debugging.

\paragraph{Interacting with the process}
{\tt iESS}, the mode for controlling interactive processes, allows for
command-line editing and saving history, as well as recalling and
searching for previously entered commands.  Filename completion exists,
and for for S languages, there exists object-name and function-name completion.
Transcripts are easily recorded and editable into a coherent activity
log.   There is a good interface to the help systems for S,
XLispStat, and Stata.

\paragraph{Interacting with statistical programs on remote computers}
ESS provides the facility to edit and
run programs on remote machines which potentially could be quite
different platforms than the local machine.

Transcript manipulation is another important task that ESS
facilitates.  Once a transcript log is generated, perhaps saving an
iESS buffer, transcript-mode allows for a quick means of reproducing
results, which is useful for demonstration of techniques as well as
for reconstruction of data analyses.  In particular this allows for
the recording and saving of transcripts, manipulating and editing
saved transcripts, as well as re-evaluating commands from transcript
lines.  For the S languages, the transcript can be ``cleaned'' by
finding all input lines and isolating them into an input file.

\paragraph{Help File Editing (R)}
ESS also provides an interface for writing help files for R functions
and packages.    It provides the ability to preview, as well as
handling embedded R source code in the same manner as ESS normally
handles source code, including syntax highlighting as well as the
ability to submit code to a running ESS process, for example R or
\Splus. 

\section{Using ESS with the S family of languages}
\label{sec:S}

We give, as one application, how ESS can be used with the S language,
and its implementations via \Splus and R.  Since ESS originated as
S-mode, this indicates why it is so strong for programming S.  We give
examples for editing files, communicating with the interactive S
process, handling transcripts, and getting help.

\subsection{Editing Files}
\label{sec:S:edit}

ESS[S] is the mode for editing S language files.  This mode handles:
proper indenting, generated by both [Tab] and [Return]; color and font
choices based on syntax; the ability to send the contents of an entire
buffer, a highlighted region, an S function, or a single line to an
inferior S process, if one is currently running; the ability to switch
between processes which would be the target of the buffer (see
previous); the ability to request help from an S process for variables
and functions, and to have the results sent into a separate buffer;
and completion of object names and file names.

ESS[S] mode should be automatically turned on when loading a file with
the suffices found in ess-site (*.R, *.S, *.s, *.q, etc.).  However,
one must start up an inferior process to take advantage of the
interactive features, including object completion.

\subsection{Inferior ESS processes}
\label{sec:S:inf}

iESS (inferior ESS) is the mode for interfacing with active
statistical processes (programs).  The processes are referred to as
inferior since they are controlled by Emacs.  The inferior ESS modes
handles proper indenting, generated by both [Tab] and [Return]; color
and font highlighting based on syntax; ability to \textbf{resubmit}
the contents of a multi-line command to the executing process with a
single keystroke [RET]; the ability to request help from the current
process for variables and functions, and to have the results sent into
a separate buffer; completion of object and file names; interactive
history mechanism; and transcript recording and editing.

Generally, the statistical processes are started by running a
function, using the Emacs function call \verb+M-x+, for example by
\verb|M-x S|.  This assumes that you have access to the desired
statistical package, which doesn't come with ESS.  Generally, these
start up the package with a particular set of command-line arguments
which are tailored for ESS.  However, some packages such as R have
some extremely useful command line arguments, -v and -n.  To enter
these, call R using a "prefix argument", by
\begin{Salltt}
   C-u M-x R
\end{Salltt}
and when ESS prompts for "Starting Args ? ", enter (for example):
\begin{Salltt}
   --max-vsize=10000 --max-nsize=5000
\end{Salltt}
Then that R process will be started up with those particular arguments.

One critically useful command family is that of the \verb|S+elsewhere|
and \verb|ESS-elsewhere| commands, which allow for a transparent execution
of a program on another machine.  The idea of 
\verb|S+elsewhere| is that we open a telnet, rlogin, or ssh connection to
another machine, call the buffer \verb|*S+elsewhere*|, and then run S (or R or SAS)
on the other machine in that buffer.
The usual {\tt C-c C-n} commands from {\tt myfile.s} on the local
machine get sent through the buffer {\tt *S-elsewhere*} to be executed
by the program on the other machine.  To the user, the interaction---including
all the unique features of working with ESS---appears exactly the same as if the
program were running on the local machine.
It is still possible to bring up
visual displays from the remote system locally, using the X11
windowing system.  Note that this holds for Unix, Microsoft, and Apple
platforms being used for the local system.

\subsection{Handling and Reusing Transcripts}
\label{sec:S:trans}

The general features which are provided for transcript handling are a
mode for editing transcripts which understands the form of S
transcripts; color and font highlighting based on syntax; resubmit
multi-line commands to an active process buffer; the ability to
request help from an S process for variables and functions, and to
have the results sent into a separate buffer; and the ability to
switch between processes which would be the target of the buffer (for
the above).  The S language transcripts can be ``cleaned'' by
finding all input lines and isolating them into a standalone input file
that can be used as input to another S job or as a model for further
program design.


\subsection{Programming Language Help}
\label{sec:S:help}
When viewing help pages, there's a new menu \textsf{[ESS help]} and
useful 1-letter shortcuts for navigation and more, such as
\begin{description}
\item[n,p] move to \textbf{n}ext or \textbf{p}revious help section
\item[s \textit{x}] move to help section code ``\textit{x}'' where
  \textit{x} is e.g. \texttt{u} for ``Usage'', or \texttt{e} for
  ``Examples''.  You can see a full list ..............
\item[h] fast `hyperlink' to other help pages
\item[l] (after \texttt{"s e"}) send examples \textbf{l}inewise to S for
  evaluation, also \texttt{C-c C-r} for sending a whole region.  This 
  is particularly useful in R which guarantees that all examples are
  directly executable (possibly after \texttt{library(*)} for non-base
  packages).
\end{description}

\subsection{Philosophies for combining S with ESS}
\label{sec:S:philosophy}

There are two primary philosophies for using ESS.   
\paragraph{Source is real}
ESS is initially
configured for the first, which is
preferred by the current group of developers.
In this approach, the source code is real.  The S objects
are realizations of the source code.  Source for \textbf{every} user
modified object is placed in a particular directory or directories,
for later editing and retrieval.  This implicitly assumes that one
might want to use written code and analyses on possibly different
versions of the S language and allows for better portability as well
as external version control for source code.

\paragraph{Objects are real}
The second, deprecated view, is that S objects are real.  Source code
is a temporary realization of the objects.  Dumped buffers
should not be saved.  We strongly discourage this approach, which is a
natural result of assuming that the S process will always be the same.
However, it can be realized by adding the following lines to one's
\texttt{.emacs} configuration file:
\begin{Salltt}
  (setq ess-keep-dump-files 'nil)
  (setq ess-delete-dump-files t)
  (setq ess-mode-silently-save nil)
\end{Salltt}
This ``old'' view was based the permanent storage of objects approach
in the original S implementations.  It uses a separate (internally formatted)
disk file for each object.


\section{Using ESS with SAS}
\label{sec:SAS}

The SAS module in ESS ({\tt ESS[SAS]}) is currently undergoing development
but is still functional and pretty stable.  While ESS (originally
S-mode) was initially designed for use with S and \Splus\tm, it has
been extended to support other languages, including SAS\tm.  The
editing of SAS files is based on the stable, old SAS mode by Cook
({\tt ftp://ftp.biostat.wisc.edu/pub/cook/sas-mode/sas.tar.gz}).  Those
editing features and new advanced features are part of {\tt ESS[SAS]}.  The
user interface with {\tt ESS[SAS]} is similar in behavior to the interface
for S (unlike Cook's SAS mode) and to the windowing interface that SAS
itself uses.

\subsection{Editing SAS Files}
\label{sec:SAS:edit}

{\tt ESS[SAS]} is the mode for editing SAS language files.  This mode
handles: proper indenting, generated by both {\tt [Tab]} and {\tt [Return]}; color
and font choices based on syntax; ability to send the contents of an
entire buffer, a highlighted region, or a single line to an inferior
SAS process, if one is currently running; ability to switch between
processes which would be the target of the buffer (for the above);
ability to save and submit the file you are working on as a batch SAS
process with a single keypress and to continue editing while it is
running; the capability of killing the batch SAS process through the
shell buffer or allow the SAS process to keep on running after you
exit Emacs; single keypress navigation of {\tt .sas}, {\tt .log} and {\tt .lst} files
({\tt .log} and {\tt .lst} files are automatically refreshed with each keypress).

{\tt ESS[SAS]}, the mode for editing SAS language files, is automatically
turned on when editing a file with a {\tt ".sas"} suffix (or other, if
specified in {\tt ess-site.el}).  The batch processing keypress commands are
enabled by default to use the same function keys that the SAS Display
Manager uses.  The interactive capabilities of ESS require you to
start an inferior SAS process with {\tt M-x SAS} (described below).

At this writing (ESS release 5.2), the indenting and syntactic
highlighting for SAS are usually correct.


\subsubsection{SAS and TAB}
\label{sec:SAS:tab}

There are two options for how ESS will interpret the {\tt [TAB]} key with
respect to SAS code.  The {\tt TAB} key is bound by default to
sas-indent-line.  This function is used to syntactically indent SAS
code so {\tt PROC} and {\tt RUN;} are in the left margin, other statements are
indented 4 spaces from the margin, continuation lines are indented 4
spaces in from the beginning column of that statement.  This is the
type of functionality that Emacs provides in most programming language
modes.  This functionality is equivalent to uncommenting the following
line in {\tt ess-site.el}:
\begin{verbatim}
;;; (setq ess-sas-edit-keys-toggle 0)
\end{verbatim}

ESS provides an alternate behavior for the {\tt TAB} key that makes it
behave as it does on non-emacs terminals, i.e. move the cursor to the
next tab stop.  The alternate behavior also provides a backwards {\tt TAB}
key: {\tt C-TAB}.  This functionality is obtained by uncommenting the
following line in {\tt ess-site.el}:
\begin{verbatim}
;;; (setq ess-sas-edit-keys-toggle 1)
\end{verbatim}
Under the alternate behavior, the {\tt TAB} key is bound to {\tt tab-to-tab-stop}
and the tab stops are set by default at multiples of 4.

\subsection{SAS process interaction}
\label{sec:SAS:proc}


\subsubsection{SAS Batch processing}
\label{sec:SAS:proc:batch}

The description of the setup for function keys for batch processing of
SAS files is unavoidably more complex than we wish it were.  The actual
use of the function keys is simple (see Section \ref{sec:SAS:batch}).
There are five distinct options.

The first option is to have function keys in {\tt ESS[SAS]} modes do
whatever they normally do in other emacs modes.  Many users will have
defined some of the keys {\tt[f2]-[f8]} in their \verb+.emacs+ or
\verb|_emacs| file, or will have installation-wide definitions in
their {\tt site-start.el} file.  By default, ESS does not override those
definitions.  This default is intended to make {\tt ESS[SAS]} mode behave
similarly to other emacs modes.

Users who are primarily familiar with SAS, and who are learning emacs
as a way to approach SAS, will likely want to duplicate the function
key capabilities that SAS Institute provides with its Display Manager.
There are still 4 distinct options for how this can be done.  SAS
provides different function key definitions with its PC and Unix
products; ESS can use either.  The {\tt ESS[SAS]} function key definitions
can be active in all buffers (global) or limited (local) only to
buffers that have SAS-related file extensions: {\tt .sas}, {\tt .log}, {\tt .lst}, and
{\tt Type-1} which defaults to {\tt .txt}.  The distinction between local and
global appears subtle.  If you want the {\tt ESS[SAS]} definitions to work
when you are in {\tt *shell*} or when editing files other than the file
extensions that SAS recognizes, you will most likely want to use the
global definitions.  If you want your function keys to understand SAS
batch commands when you are editing SAS files, and to behave normally
when editing other files, then you will choose the local definitions.

The option can be chosen both site-wide and by individual users.

%The site manager can uncomment only one of the following lines.
%ESS[SAS] Function keys are available in ESS[SAS] and related modes if you
%uncomment either of the following lines in your ess-site.el:
%\begin{verbatim}
%;;2; (setq ess-sas-local-unix-keys t)
%;;3; (setq ess-sas-local-pc-keys t)
%\end{verbatim}
%ESS[SAS] Function keys are available in all Emacs modes if you
%uncomment either of the following lines in your ess-site.el:
%\begin{verbatim}
%;;4; (setq ess-sas-global-unix-keys t)
%;;5; (setq ess-sas-global-pc-keys t)
%\end{verbatim}
%The names -unix- and -pc- have nothing to do with the operating system
%that you are running.  Rather they mimic the definitions that the SAS
%Display Manager uses by default on those platforms.

%The option can be selected by an individual by adding a line to the
%\verb+.emacs+ (or \verb+_emacs+) file, immediately following the
%\begin{verbatim}
% (load "ess-site")
%\end{verbatim}
%line.  If your site manager has chosen an option 2,3,4,5 you don't
%want, you must turn it off before selecting a different option.  To
%turn off an option, add the appropriate line (uncommented) to your
%\verb+.emacs+ (\verb+_emacs+) file.
%\begin{verbatim}
%;;2; (setq ess-sas-local-unix-keys nil)
%;;3; (setq ess-sas-local-pc-keys nil)
%;;4; (setq ess-sas-global-unix-keys nil)
%;;5; (setq ess-sas-global-pc-keys nil)
%\end{verbatim}

The function keys act as follows:\\
\begin{tabular}{llll}
Unix& PC&\\
\tt F2  &\tt  F2& Refresh:&revert the buffer with the file if the file on disk is newer\\
\tt     &\tt    &         &       than the file currently in the buffer.\\
\tt F3  &\tt  F8& Submit: &save   the current {\tt .sas} buffer (which may be the {\tt .sas}\\
\tt     &\tt    &         &       file associated with the {\tt .lst} or {\tt .log} file you\\
\tt     &\tt    &         &       are actually looking at) to a file and submit\\
\tt     &\tt    &         &       the file to a background SAS job.\\
\tt F4  &\tt  F5& Program:&switch buffer to {\tt .sas} file.\\
\tt F5  &\tt  F6& Log:    &switch buffer to {\tt .log} file, ``refresh" and \\
\tt     &\tt    &         &        goto next error message, if any.\\
\tt F6  &\tt  F7& Listing:&switch buffer to {\tt .lst} file and ``refresh".\\
\tt F7  &\tt  F4& Type-1: &switch buffer to {\tt Type-1} (defaults to {\tt .txt}) file and ``refresh".\\
\tt F8  &\tt  F3& Shell:  &switch buffer to shell.\\
\end{tabular}


Keys {\tt [f3]-[f8]} mimic SAS Display Manager keys.  One other key has been
provided for convenience.  {\tt F2} performs the ``refresh" operation on the
current buffer.  ``refresh" compares the buffer date stamp with the
file date stamp and replaces the buffer with the file if the file is
newer.  This is the same operation that is automatically performed
when Log, Listing, or {\tt Type-1} are pressed.  {\tt Type-1} takes you to a file
with a user-specified extension; {\tt .txt} by default.  You can over-ride
the default, by specifying a different extension in your {\tt .emacs} file:
\begin{verbatim}
(setq ess-sas-suffix-1 '.txt')
\end{verbatim}

\paragraph{SAS Interface}
\label{sec:SAS:interface}

The default command used by the Submit function key ({\tt F3} or {\tt F8}) to
submit a batch SAS job is simply {\tt "sas"}.  If necessary, you can
over-ride this in your \verb+.emacs+ file something like one of the
following:
{\small
\begin{verbatim}
;;; (setq ess-sas-submit-command "nohup nice sas") ;; Unix
;;; (setq ess-sas-submit-command "c:/progra~1/sas/sas.exe") ;; Windows
;;; (setq ess-sas-submit-command "invoke SAS using program file") ;; Mac
\end{verbatim}
}
Note that when you are specifying a path under Windows, you should
avoid spaces (that is use {\verb+"progra~1"+}, not {\tt "Program Files"}) and you
should use forward slashes {\tt "/"}.  There may be occasions when you want
to run a particular buffer under a different version of SAS or specify
different options on the command line.  In that case, you can
over-ride {\tt ess-sas-submit-command} in your local buffer with file
variables or other means.

There is a built-in delay before a batch SAS job is submitted when using
a Unix shell under either Unix or Windows.  This is necessary in many cases 
since the shell might not be ready to receive a command.  This delay is 
currently set high enough so as not to be a problem on any system.  But,
there may be cases when it needs to be set higher, or could be set much
lower to speed things up.  You can over-ride the default in your {\tt .emacs}
file by (the default of 5 seconds is shown):
\begin{Salltt}
(setq ess-sleep-for 5)
\end{Salltt}


% \subsection{Using Transcripts}
% \label{sec:SAS:trans}
% 
% Not yet available.  The intent is that a marked section of a log file
% from a previous SAS run can be resubmitted to SAS.  The user would
% highlight a region from 'PROC' to 'RUN;' and then send it to the
% inferior SAS process with the [RET] key.  ESS would automatically
% clean the region (remove line numbers) and send the entire region over
% as a single request to SAS.
% 

\subsubsection{Inferior SAS processes}
\label{sec:SAS:proc:inf}

{\tt iESS} (inferior ESS) is the mode for interfacing with active
statistical processes (programs).  To start up {\tt iESS[SAS]} mode, use:
\begin{verbatim}
   M-x SAS
\end{verbatim}   
% We plan to add the ability to request help from a process for
% variables and functions, and to have the results sent into a separate
% buffer, as well as the completion of object names and file names.
A single instance of SAS is started in an {\tt iESS[SAS]} buffer.  Individual
{\tt DATA} and {\tt PROC} steps are sent to this instance of SAS and the results
are appended to the {\tt *log*} and {\tt *lst*} buffers.

The {\tt iESS[SAS]} mode was written with two primary goals.
\begin{itemize}
\item Using Emacs, a window environment becomes available for dial-up
  users who do not have access to the SAS window environment.
\item The authors prefer the Emacs environment for editing and
  managing input and output files, even on computer systems which run
  the SAS window environment.
\end{itemize}
A secondary goal was also realized.  With an X-windows
terminal connected by ppp at (the now slow speed of)
14400 baud to a Unix system running SAS,
{\tt iESS[SAS]} interaction with SAS was hundreds of times faster than the
SAS window system.  The savings come because the ESS windows are
subunits of a text-based xterm window, rather than the remotely
managed graphical windows provided by SAS.  (The timings are SAS
timings from the log files.  The SAS windows times include window
management and communications times as well as calculation times.  The
{\tt iESS} times include only the calculations by the SAS computing engine.)


\subsection{ESS interface with SAS Design Philosophy}
\label{sec:SAS:phil}

{\tt ESS[SAS]} mode was designed to aid the user in writing and maintaining
input command files, such as {\tt myfile.sas}, for SAS.  These are files
containing SAS statements.  In a batch environment such files would be
submitted to SAS by the operating system command:
\begin{Salltt}
  sas myfile.sas
\end{Salltt}
In a SAS window environment, these files would be brought into the
"SAS: PROGRAM EDITOR" window and then submitted with the 'Local' 'Submit'
menu commands.

The {\tt *SAS:1.log*} or {\tt myfile.log} buffer in {\tt ESStr} mode
corresponds to the file {\tt myfile.log} in SAS batch usage and to the
"SAS: LOG" window in the SAS window environment.  All commands
submitted to SAS, informative messages, warnings, and errors appear
here.

The {\tt *SAS:1.lst*} or {\tt myfile.lst} buffer in {\tt ESSlst} mode
corresponds to the file {\tt myfile.lst} in SAS batch usage and to the
"SAS: OUTPUT" window in the SAS window environment.  All data related
printed output from the {\tt PROC}s appear in this window.

The interactive {\tt iESS [SAS:1]} buffer exists solely as a communications buffer.
Files are edited in the myfile.sas buffer.  The {\tt C-c C-r} key in
{\tt ESS[SAS]} mode is the functional equivalent of bringing a file into the
"SAS: PROGRAM EDITOR" window followed by the 'Local' 'Submit' menu
commands.  The user should never use this buffer directly.

\section{Obtaining ESS}
\label{sec:getIt}

ESS is primarily located at {\tt ess.stat.wisc.edu}, and is available by FTP
or through the World-Wide-Web (WWW).  A basic installation consists of
downloading the package, unpacking, and then adding a line to the
emacs initialization file (\verb+.emacs+ or \verb+_emacs+), pointing
to the lisp subdirectory of the unpacked archive.

There exist packages for various Linux distributions, as well,
including Debian, RedHat, Mandrake, and SuSE.

\section{History}
\label{sec:history}

ESS (originally S-mode) was initially designed for use with S and
\Splus\tm; hence, this family of statistical languages currently has
the most support.  We denote by S, any of the currently available
members (or ``dialects'') of the family, including S 3.x, S 4.x, \Splus
3.x, \Splus~4.x (incl.\ \Splus~2000), \Splus~5.x, \Splus~6.x and R.
In addition, we
denote by Emacs, one of the GNU family of editors, either Emacs (as
developed and maintained by the Free Software Foundation) or XEmacs (which
is a derivative work).

ESS originated from the extension for programming and process
interface in Emacs supplied by S-mode (D. Bates, F. Ritter, et.al.; 
M. Meyer; D. Smith).  The extension to a language-independent generic
interface was prompted by the success of R, and the need for an
R-mode.  This led to a merger with the SAS-mode (T. Cook), and the
refactoring of the S-mode codebase to accommodate multiple languages
in a flexible way.  A detailed history can be found in
section~\ref{sec:history}.

ESS is a remarkable example of how open-source products can continue
to develop beyond what their initial authors planned.  ESS started as
S-mode, an Emacs extension which was developed in 1991 as a simple
tool for editing program files for S and \Splus.  In 1994, Rossini
extended S-mode to support XEmacs, which was a forked version of
Emacs.  At the same time, Rossini extended a successful SAS-mode
written by Tom Cook to work with XEmacs.  In 1995, S-mode was merged
into a uniform S-mode for Emacs, XEmacs, and supported S, \Splus, and
R. During 1996 and 1997, Richard M. Heiberger incorporated 
SAS-mode into ESS and designed the inferior ESS mode for SAS.
At the same time Rossini developed a
generic means for configuring ESS to accommodate changed as well as
new statistical languages.

Most of this was primarily done under Unix.  Beginning in 1998, thanks
to an example of interprocess communication using Microsoft's DDE by
Brian Ripley, Richard M. Heiberger provided interfaces for \Splus~4.x
and then \Splus~2000 and \Splus~6.x.  Beginning in 2000, Rodney
Sparapani designed the SAS batch interaction mode.

Most of what has been done recently is debugging and tuning.  New
features in the plans include robust extensions for Literate Data
Analysis using Noweb \citep{NRamsey:1994}, as well as extensions for
XML-based Literate Statistical Analysis.

\section{Remarks and Extensions}
\label{sec:remarks}

There are two active areas of extensions for user environments.  One
is to enhance the capabilities of the IDE for statistical practice;
this includes implementing such common IDE features as object browsers
as well as clean up the interface.

The other exciting extension is towards the use of Literate
Programming methodologies \citep{Knuth:1992,NRamsey:1994}, which we
will refer to as Literate Statistical Analysis \citep{ross:lunt:2001}.
The tools include the use of Noweb \citep{NRamsey:1994} and an
additional step towards the use of an XML authoring environment for
statistical analysis.  Literate Data Analysis based on Noweb, is a
means of documenting a statistical analysis plan and procedure.
Literate Statistical Analysis is intended to be a round-trip
environment for both design and analysis.

The future use of XML is to accommodate the growing use of WWW-based
services for document publishing as well as information conversion.
By marking up the document with XML, it is possible to display subsets
of the document contextually according to the intent of the document.
Unlike Literate Data Analysis, which provides a single document for
code and analysis plan, Literate Statistical Analysis is a round-trip
cycle, using document modification through the Document Object Model
interface (W3 Consortium).  This is described more in
\citep{ross:lunt:2001}. 

\bibliographystyle{plainnat} %alpha}
\bibliography{ess}

\appendix


\section{Scenarios for Use}
\label{app:scenarios}

The Appendix sections discuss specific use patterns for ESS under 2 very
different statistical language systems, S and SAS.

\subsection{Scenarios for using S}
\label{sec:S:scenarios}

We present some basic suggestions for using ESS to interact with S.
We illustrate both data analysis and program revision examples under each of
the philosophies of reality (S objects or source code).

\subsubsection{Data Analysis Example (source code is real)}
The current ESS developers recommend this procedure.

\noindent
Load the file you want to work with
  \elcode{C-x C-f myfile.s}
Edit as appropriate, and then start up \Splus~3.x
  \elcode{M-x S+3}
A new buffer {\tt *S+3:1*} will appear.  Splus will have been started
in this buffer.  The buffer is in {\tt iESS [S+3:1]} mode.

Split the screen and go back to the file editing buffer.
  \elcode{C-x 2 C-x b myfile.s}
Send regions, lines, or the entire file contents to \Splus.
For regions, highlight a region with keystrokes or mouse
and then send with:
  \elcode{C-c C-r}
Re-edit myfile.s as necessary to correct any difficulties.  Add
new commands here.  Send them to S by region with
  \elcode{C-c C-r}
or one line at a time with
  \elcode{C-c C-n}
Save the revised myfile.s with C-x C-s.

Save the entire {\tt *S+3:1*} interaction buffer with {\tt C-x C-s}.  You
will be prompted for a file name.  The recommended name is
{\tt myfile.St} (for S Transcript).  With the {\tt *.St} suffix,
the file will automatically come up in ESS
Transcript mode the next time it is accessed from Emacs.


\subsubsection{Program revision example (source code is real)}
The current ESS developers recommend this procedure.

\noindent
Start up \Splus~3.x in a process buffer (this will be {\tt *S+3:1*})
  \elcode{M-x S+3}
Load the file you want to work with
  \elcode{C-x C-f myfile.s}
Edit program, functions, and code in {\tt myfile.s}.
When ready, send revised functions to S with
  \elcode{C-c C-f}
or send highlighted regions with
  \elcode{C-c C-r}
or send individual lines with
  \elcode{C-c C-n}
or load the entire buffer into S with
  \elcode{C-c C-l}
Save the revised myfile.s when you have finished
  \elcode{C-x C-s}

\subsubsection{Program revision example (S object is real)}
The current ESS developers do {\bf not} recommend this procedure.

\noindent
Start up \Splus~3.x, in a process buffer (this will be {\tt *S+3:1*}) 
  \elcode{M-x S+3}
Dump an existing S object my.function into a buffer to work with
  \elcode{C-c C-d my.function}
a new buffer named \textit{yourloginname}.my.function.S will be created with
an editable copy of the object.  The buffer is associated with the
pathname
 \elcode{/tmp/\textit{yourloginname}.my.function.S}
and will almost certainly not exist after you log off.

Enter program, functions, and code into work buffer,
and send entire contents to \Splus\ when ready:
  \elcode{C-c C-b}
Go to the {\tt *S+3:1*} buffer, which is the process buffer, and examine
the results.
  \elcode{C-c C-y}
The sequence {\tt C-c C-y} is a shortcut for:  {\tt C-x b *S+3:1*}

Return to the work buffer (may/may not be prefixed)
  \elcode{C-x C-b \textit{yourloginname}.my.function.S}
Fix the function that didn't work, and resubmit by
placing the cursor somewhere in the function and
  \elcode{C-c C-f}
Or select a region (using the mouse, or keyboard
via setting point/mark) and
  \elcode{C-c C-r}
Or step through, line by line, using
  \elcode{C-c C-n}
Or just send a single line (without moving to the next) using
  \elcode{C-c C-j}
To fix that error in syntax for the {\tt rchisq} command, get help
by
  \elcode{C-c C-v rchisq}

\subsubsection{Data Analysis (S object is real)}
The current ESS developers do {\bf not} recommend this procedure.

\noindent
Start up R in a process buffer (this will be \textbf{*R*}) 
  \elcode{M-x R}
Work in the process buffer.  When you find an object that needs
to be changed (this could be a data frame, or a variable,
or a function), dump it to a buffer:
  \elcode{C-c C-d my.cool.function}
Edit the function as appropriate, and dump back in to the
process buffer
  \elcode{C-c C-b}
Return to the R process buffer
  \elcode{C-c C-y}
Continue working.
When you need help, use
  \elcode{C-c C-v rchisq}
(which you can do using command name completion)
but entering:   {\tt help("rchisq")} or {\tt ?rchisq}
will bring up the help file in a separate buffer
\emph{--- currently only for \textbf{*R*}}.



\subsection{Scenarios for using ESS with SAS}
\label{sec:SAS:scen}

We present two scenarios for using ESS to interact with SAS.  Each mimics
a different aspect of the SAS Display Manager behavior.
The Batch scenario sends an entire {\tt myfile.sas} file over to
SAS and receives {\tt myfile.log} and {\tt myfile.lst} back.  The Interactive
scenario sends one {\tt DATA} step or one {\tt PROC} step over at a time
and receives back increments to the {\tt myfile.log} and {\tt myfile.lst} files.
Both scenarios work with SAS running either on the same machine that emacs
is running on, or on a remote machine.

We recommend the following line appear in
your {\tt autoexec.sas} in your home directory on the machine running SAS:
\elcode{options noovp pagesize=60 linesize=80 formdlim=' ';}
Interpretations\\
\begin{tabular}{ll}
\tt   noovp         & prevents error messages from printing 3 times         \\
\tt   pagesize=60   & standard printed page length instead of window length \\
\tt   linesize=80   & keeps output lines from folding on standard terminals \\
\tt   formdlim=' '  & blank replaces {\tt C-l} formfeeds to prevent mostly  \\
\tt                 & empty printed pages                                   \\
\end{tabular}\\

\subsubsection{Batch SAS (-unix-keys illustrated, pc-keys in the comments)}
\label{sec:SAS:batch}
A complete SAS job, multiple {\tt DATA} and {\tt PROC} steps, is sent over
to a new instance of SAS.  The results from the complete job are received back
in {\tt log} and {\tt lst} files.

Find the file you want to work with
    \elcode{C-x C-f myfile.sas}
{\tt myfile.sas} will be in ESS[SAS] mode.
Edit as appropriate, then save and submit the batch SAS job.
    \elcode{F3  /*-pc- F8*/}
The job runs in the shell buffer while you continue to edit 
{\tt myfile.sas}.  If you are running a Unix shell under Unix or
Windows, the message buffer will notify you with a shell
notification when the job is complete.  If so, then you 
will also have the option of terminating the batch job
before it is finished.
    \elcode{F8  /*-pc- F3*/}
In any case, you may want to visit the {\tt .log} while the process
is still running (unix only) or when it is done and check for
error messages 
(you will be taken to the next error message, if any).
The {\tt .log} will be refreshed and you will be placed in it's buffer.
    \elcode{F5  /*-pc- F6*/}
Now, refresh the {\tt .lst} and go to it's buffer.
    \elcode{F6  /*-pc- F7*/}
If you wish to make changes, go to the {\tt .sas} file with
    \elcode{F4 /*-pc- F5*/}
and make your editing changes.  The go back to the submit instruction.

\subsubsection{Interactive SAS}
A single instance of SAS is started in an {\tt iESS[SAS]} buffer.  Individual
{\tt DATA} and {\tt PROC} steps are sent to this instance of SAS and the results
are appended to the {\tt *log*} and {\tt *lst*} buffers.

 Find the file you want to work with
    \elcode{C-x C-f myfile.sas}
 {\tt myfile.sas} will be in {\tt ESS[SAS]} mode.
Edit as appropriate, and then start up SAS with the cursor in
the {\tt myfile.sas} buffer
    \elcode{M-x SAS}
Four buffers will appear on screen:\\
\begin{tabular}{lll}
\hline
Buffer name     & emacs mode         & use\\
\hline
\tt myfile.sas  & \tt ESS[SAS]       &your source file         \\
\tt *SAS:1*     & \tt iESS [SAS:1]   &ESS communication buffer \\
\tt *SAS:1.log* & \tt Shell [] ESStr &SAS log information      \\
\tt *SAS:1.lst* & \tt Shell [] ESSlst&SAS listing information  \\
\hline
\end{tabular}\\[1ex]
 If you would prefer each of the four buffers to appear in its
 own individual frame, you can arrange for that.  Place the
 cursor in the buffer displaying myfile.sas.  Enter the
 sequence:
    \elcode{C-c C-w}
The cursor will normally be in buffer {\tt myfile.sas}.
If not, put it there:
    \elcode{C-x b myfile.sas}
Send regions, lines, or the entire file contents to SAS
(regions are most useful).  A highlighted region will normally
begin with the keywords {\tt DATA} or {\tt PROC} and end with the
keyword {\tt RUN;}
    \elcode{C-c C-r}

Information appears in the log buffer, analysis results in the
listing buffer.  In case of errors, make the corrections in the
{\tt myfile.sas} buffer and resubmit with another {\tt C-c C-r}

{\tt PROC GPLOT} graphs will normally be produced in a postscript
file and be viewed later.  Include the lines
{\small
\begin{verbatim}
    /* required goptions for batch files */
    /* comment out these lines for interactive use on X-terminals*/
    filename grafout 'temp.ps';
    goptions device=ps gsfname=grafout gsfmode=append gaccess=sasgastd;
\end{verbatim}
}
\noindent
in {\tt myfile.sas}.

 {\tt PROC PLOT} graphs can be viewed in the listing buffer.  You may
 wish to control the vertical spacing to allow the entire plot
 to be visible on screen, for example, by
\begin{verbatim}
    proc plot; plot a*b / vpos=25;
\end{verbatim}

 At the end of the session you may save the log and listing
 buffers with the usual {\tt C-x C-s} commands.  You will be prompted
 for a file name.  Typically, the names {\tt myfile.log} and {\tt mfile.lst}
 will be used.  You will almost certainly want to edit the saved
 files before including them in a report.  The files are
 read-only by default.  You can make them writable by the Emacs
 command {\tt C-x C-q}.

 At the end of the session, the input file {\tt myfile.sas} will
 typically have been revised.  You can save it.  It can be used
 later as the beginning of another {\tt iESS[SAS]} session.  It can
 also be used as a batch input file to SAS.

 The {\tt *SAS:1*} buffer is strictly for ESS use.  The user should
 never need to read it or write to it.  Refer to the {\tt .lst} and
 {\tt .log} buffers for monitoring output!


%% Here is a typical {\tt myfile.sas}:
%% \begin{verbatim}
%%     title 'Analysis of Case 0502';
%% 
%%     data case0502;
%%         infile '/home/public/stat/Data/case0502.asc'
%%                firstobs=2;
%%         input percent code;
%%     run;
%% 
%%     proc glm;
%%       class code;
%%       model percent=code /ss1;
%%     run;
%% \end{verbatim}


For the Interactive scenario,
the default settings of the {\tt inferior-SAS-args} in {\tt essd-sas.el}
are {\tt -stdio -linesize 80 -noovp -nosyntaxcheck}
with the interpretations:\\
\begin{tabular}{ll}
\tt  -stdio          &required to make the redirection of stdio work       \\
\tt  -linesize 80    &keeps output lines from folding on standard terminals\\
\tt  -noovp          &prevents error messages from printing 3 times        \\
\tt  -nosyntaxcheck  &permits recovery after syntax errors                 \\
\end{tabular}\\
The {\tt noovp} and {\tt linesize=80} appear in both the {\tt
inferior-SAS-args} and in the {\tt autoexec.sas}.  The redundancy means that
these options are in effect for SAS batch usage and SAS window manager
usage as well as for {\tt iESS[SAS]} usage.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ess"
%%% End: 

