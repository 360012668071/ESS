\documentclass{article}

%\usepackage{2up}

\usepackage{doublespace}

%%% 
\usepackage[authoryear,round]{natbib}
%or (if you have an unshiny latex installation)
%\newcommand{\citep}[1]{{\{\sf#1\}}}
%%%
\usepackage{alltt}

%% Postscript fonts
%\usepackage{palatcm}
\usepackage{times}
%%% \usepackage{amsmath}

%% The following is for creating PDF.
\newif\ifpdf
\ifx\pdfoutput\undefined
  \pdffalse     % not running PDFLaTeX
\else
  \pdfoutput=1  % running PDFLaTeX
  \pdftrue
\fi

\ifpdf
  \usepackage{thumbpdf}
\fi
%\usepackage{html,heqn,htmllist}
%\usepackage[latex2html]{hyperref} 
\ifpdf
  \usepackage[pdftex]{graphicx}
  \usepackage[pdftex]{hyperref} 
\else
  \usepackage[dvips]{graphicx}
  \usepackage[dvips]{hyperref} 
\fi

%%---End of package requiring ---------- Own Definitions ------------- 

\hypersetup{backref,colorlinks=true,pagebackref=true,
  hyperindex=true}%pdfpagemode=FullScreen,

\newcommand*{\Splus}{\textsc{S-Plus}}
\newcommand*{\XLispStat}{\textsc{XLispStat}}
\newcommand*{\Stata}{\textsc{Stata}}
%\newcommand*{\Scmt}[1]{\hfill \#\# \textsl{#1}}
\newcommand*{\Scmt}[1]{\hbox{\qquad {\footnotesize \#\#} \textsl{#1}}}
\newtheorem{defn}{Definition}[section]
\newtheorem{ex}{Example}[section]

\newcommand{\stexttt}[1]{{\small\texttt{#1}}}
\newcommand{\ssf}[1]{{\small\sf{#1}}}
\newcommand{\elcode}[1]{\\{\stexttt{\hspace*{2em} #1}}\\}
\newcommand{\tm}{$^{\mbox{\scriptsize\sc tm}}$}
\newenvironment{Salltt}{\small\begin{alltt}}{\end{alltt}}
\newcommand{\US}{{\char'137}}        % \tt _
\newcommand{\marpar}[1]{\marginpar{\raggedright#1}}
\newcommand{\file}[1]{`\stexttt{#1}'}
%\parskip 1ex

%%--------------------------------------------------------------- Start Text

\title{Emacs Speaks Statistics: A Universal Interface for
  Statistical Analysis}  

\author{A.J. Rossini\footnote{Department of Biostatistics, University
    of Washington and Fred Hutchinson Cancer Research Center, Seattle,
    WA, USA} \and Martin M{\"a}chler\footnote{Seminar for Statistics;
    ETH Zurich; Zurich, Switzerland} \and Kurt
  Hornik\footnote{Technische Universit{\"a}t Wien, Vienna, Austria}
  \and Richard M. Heiberger\footnote{Temple University; Philadelphia,
    PA, USA} \and Rodney Sparapani\footnote{Medical College of
    Wisconsin, WI, USA}}

\date{\today}

\begin{document}

\ifpdf
  \DeclareGraphicsExtensions{.jpg,.pdf,.png,.mps}
\fi

%%%% To cite everything
%%\nocite{*} 

\singlespace

\maketitle

Keywords: Data Analysis, Programming Tools, User Interfaces, SAS,
\Splus, R, \XLispStat, \Stata

\begin{abstract}
  We discuss Emacs Speaks Statistics (ESS), a user interface for
  developing statistical applications and performing data analysis
  using any of several powerful statistical programming languages.
  ESS falls in the programming tools category of Integrated
  Development Environments (IDEs), which are approaches for developing
  and visualizing computer programs.  We discuss how it works, the
  advantages of using it, and extensions for increasing statistical
  programming efficiency.
\end{abstract}

\doublespace

\section{Introduction}
\label{sec:intro}

Integrated Development Environments (IDEs) are computer programming
environments which combine features and tools in a single interface
with the intent of increasing programmer productivity and efficiency.
The use of IDEs and other Rapid Application Development (RAD) tools
has increased speed in commercial development time of complex software
systems in the last decade for programming languages such as Visual
Basic, Java, C++, Python, and Smalltalk.  For the field of statistics,
programming is an important skill which can be augmented and enhanced
by the right tools and environment.  This is especially important with
the increased use of simulation-based statistical procedures including
resampling (bootstrap and jackknife approaches) and Markov Chain Monte
Carlo (MCMC) sampling.

Statistical software tools are intended for either ``general'' data
analysis or can target specialized statistical analyses.  The
specialized tools can be orders of magnitude more efficient for
generating data analyses.  This is balanced by the inability of the
specialized tools to perform a wide range of operations common to data
analysis.  Tightly coupled interoperability between these programs
exists only in a few situations; the need to switch between tools
occurs much more often.  For example, general purpose tools such as R
\citep{ihak:gent:1996} do not perform Bayesian analyses as easily as
tools such as WinBUGS can \citep{SpieThomBest:1999}.  On the other
hand, these specialized tools lack breadth in the range of analyses
and graphics that can be generated.  Indeed, BUGS is distributed with
applications providing loose interoperability for simplifying the
transfer of output to R or \Splus\ for processing the results.
However, while the interfaces for WinBUGS and R are similar, they are
still distinct enough to create tension on the part of the analyst.

Emacs Speaks Statistics (ESS) \citep{ESS} provides a single point of interface for
a variety of statistical computing tools.  ESS is optimized for the
tasks of statistical coding and interactive data analysis.
Statistical coding is the writing of computer code for data analysis.
This code might be in a compilable language, such as C or Fortran, or
it might be in an interpreted language such as \Splus, SAS, R,
\XLispStat, Perl, or Python.  The task of entering commands for
interactive data analysis is similar.  In either case, text is written
in a computer language and sent to a computer program for compilation
or interpretation.  The primary difference is that the results of a
small set of commands are of critical interest for review in the
analysis phase, but the results of all commands are of interest in the
coding phase.  Both of these tasks can occur simultaneously, for
example in the use of compiled C code for optimization, which is
called from an interpreted language such as R, where the objective
function to optimize is written.

Simple conflicts between interfaces are exemplified by different
keystrokes for editing tasks such as copy and paste, beginning of
line, highlighting regions.  These are sometimes the most aggravating
because our fingers are trained for a primary interface convention
which is continually interfered with.  ESS solves this problem by
providing a uniform keyboard interface.

Some interface conflicts can be complex, involving the coordination of
several data files, multiple statistical software packages, and the
corresponding source code in each of these languages, combined for a
single analysis.  ESS, as part of Emacs, has tools which assist in
this, including support for version and source code control systems,
tools for accessing programs and files on remote machines, and
interfaces to documentation systems including \LaTeX\ and
\textsc{xml}.  In addition, Emacs can assist with or be programmed to
perform many tasks related to data cleaning, management, and editing.

The use of multiple running statistical processes, either on a single
machine or a variety of machines, is a useful feature.  This ability
assists with code design and testing across multiple versions of
statistical software packages, as well as large scale numerical
simulations.  For example, one might want to be connected to multiple
R processes of different versions in order to verify behavior on
different versions of the same software; multiple processes of the
same version to perform test-and-run scenarios where one process is
doing long-term processing while the other is doing short-term
testing; simulations; and to distribute the load over a variety of
remote machines.

ESS mitigates some of the problems noted above.  It provides a well
designed and documented programming editor, an interface to
statistical processes, and additional tools which aid both statistical
software development and data analysis.  It works with common
statistical software, including the S languages (which include S
\citep{BecRCW88,ChaJH92,ChaJ98}, \Splus\ \citep{Splus}, and R
\citep{ihak:gent:1996}); \XLispStat\ \citep{Tier90} and its extensions
Arc \citep{Cook:Weisberg:1999} and ViSta \citep{youn:fald:mcfa:1992};
SAS \citep{SAS:8.0}; \Stata\ \citep{Stata:6.0}; Omegahat
\citep{DTLang:2000}; and BUGS \citep{SpieThomBest:1999}.  ESS can be
extended to accommodate most statistical packages which can be
controlled from a command-line.

The next section introduces common forms of statistical user
interfaces.  This is followed by a discussion of how ESS and Emacs
fit.  Realizations for the S family and SAS are discussed in sections
\ref{sec:S} and \ref{sec:SAS} respectively.  Finally, the conclusion
brings up related work and future extensions.

\section{Statistical User Interfaces}
\label{sec:UI}

Human interfaces for statistical packages and languages can generally
be classified into 3 forms, the command-line interface, the graphical
user interface, and specialized interfaces which only have 1 or 2
examples.  Command-line interfaces (CLIs) have historically been used
by many packages.  This is the interface that ESS uses for control and
provides a limited GUI for.  Modern statistical packages have
generally used graphical user interfaces (GUIs), sometimes
exclusively.  In addition, there have been many single-implementation
interfaces, including flow-chart guides, implemented as graph-based
interfaces in ViSta \citep{youn:lubi:1995}; the SAS terminal
interface, which divides the terminal window into 3 screens; and by
the coherent implementation provided by DataDesk
\citep{vell:prat:1989}, which has a tight link between data and
graphics.

Individual feelings about computer user interfaces have traditionally
been extremely personal.  It is extremely difficult to convince
computer users to change from one to another.  

\subsection{Command line interfaces}
\label{sec:UI:command}

The classic command-line interface is available for some statistical
packages on most Unix and mainframe computers.  This interface
consists of entering commands one line at a time.  Current examples
can mostly be found under Unix, including \Splus, R, \Stata, and
\XLispStat.  Note that the \Stata\ CLI is deprecated in favor of a new
GUI, and this direction seems to be a general trend.  ESS assists
command-line interfaces by providing a comprehensive interface layer
on top of the command-line.  SAS does not have a true CLI.  The two
possible options are a prompt-less input device which sends a combined
log and list-file text stream directly back to the same device, and
second, the 3-window graphical terminal interface which is being
deprecated in favor of a GUI version.

\subsection{Graphical User Interfaces}
\label{sec:UI:GUI}

The advent of the Apple Macintosh and Microsoft Windows operating
systems have encouraged a partial standardization of interfaces for
statistical packages.  Many packages written for both IBM-based and
Apple-based personal computers have adopted a data display descended
from the spreadsheet data-table approach.  Generally, these feature a
cases-by-variables spreadsheet representation of the data, along with
pull-down menus and dialog boxes for data analysis activities.
Depending upon their nature, numerical results can be saved as well as
displayed on the spreadsheet.  Software that takes this approach
includes SPSS, Minitab, \Splus\ 4.x for Windows and 6.x for Unix and
Windows, DataDesk, ViSta, and many others.

Most of the statistical software, including spreadsheets, uses the
Multiple Document Interface (MDI), where multiple windows representing
numerous documents are enclosed by the surrounding application, rather
than a Single Document Interface (SDI), which provides a single frame
for each document, view, or figure created.  The use of MDI seems to
be more a function of the availability of GUI toolkits for Apple
Macintosh and Microsoft Windows applications, which promote such
interfaces, rather than from a consistent recommendation of theories
for user-interface design.  Unix-based interfaces tend to be
SDI-based, due in part to the nature of the X11 windowing system and
until recently, the small number of available GUI toolkits.

The common approach taken by statistics packages for MDI is to wrap
menus and toolbars around a region containing representations of
documents.  These representations usually include one or more frames
possibly featuring display graphics, a command-line window, a source
code editing window, or possibly a spreadsheet displaying, for
example, a cases-by-variables view of the data set or a drilldown
contingency table interface.  This approach is employed by both
spreadsheet packages such as Microsoft Excel as well as most Apple and
Microsoft-based statistical packages including \Splus\ and SPSS.

\section{The ESS user interface}
\label{sec:ESS}

ESS provides a number of features for statistical programming beyond
those provided by Emacs.

\subsection{How ESS extends the CLI}
\label{sec:ESS:UI}

ESS currently supports a number of interactive statistical programs as
well as a few interpreted statistical languages.  There are various
levels of support depending on the capabilities of the program and the
needs of users.  Because ESS builds on the extremely powerful Emacs
editing capabilities and the Emacs ability to communicate directly
with a running process, ESS provides very powerful and uniform
interaction with the statistical programs and languages.

Since ESS developed from S-mode, ESS strongly supports the S family of
languages; these include recent versions of S, \Splus, and R.  SAS is
also well supported, but to a lesser extent.  \Stata\ and \XLispStat\ 
(and the \XLispStat\ extensions, ARC and ViSta) are supported with the
basic functionality of syntax highlighting and process-interfacing.
ESS and its interface are fully discussed in the next section.

\subsection{Features and capabilities}
\label{sec:ESS:features}

\paragraph{Syntactic indentation and highlighting of source code.}
The ESS interface includes a description of the syntax and grammar of
each statistical language it knows about.  This gives ESS the ability
to edit the programming language code, often more smoothly than with
editors distributed with the languages.  The process of programming
code is enhanced as ESS provides the user with a clear presentation of
the code with syntax highlighting to denote assignment, reserved
words, presence of strings, and comments.  ESS has customizable
automatic indentation, with the customization based on the syntactic
structure of groups of expressions.  ESS knows the structure of
transcripts of the executing session, as well as it knows the source
language, and provides syntactic highlighting here as well.  For the
interface with the executing statistics package/program, ESS also
provides a means of searching the command-line history for previous
commands as well as editing past commands for current use.

\paragraph{Partial evaluations of code.}
Emacs can send individual lines, entire function definitions, marked
regions, and whole edited buffers from the window in which the code is
displayed for editing to the statistical program/package for
execution.  Emacs can complete partially typed file names by referring
to the current working directory.  Emacs sends the code directly to
the running program and receives the printed output back from the
program.  Direct sending of code is a major improvement over
cut-and-paste as it does not require switching buffers or windows for
either the sending or receiving of information.  The response is
received immediately in an editable Emacs buffer.

In addition, for languages in the S family \{S (versions 3 and 4)
developed at Bell Labs, \Splus\ (all versions), and R (all versions)\}
ESS provides object-name completion of both user- and system-defined
functions and data.  There is also the ability to dump and save
objects (user- and system-generated) into text files in a formatted
manner for editing, as well as to reload (after possible editing) back
into the statistical package/process.

\paragraph{Source code checking.}
ESS facilitates the editing of source code by providing a means
for loading and error-checking of small sections of code for S,
\XLispStat, and SAS.  This allows for one form of source-level
debugging.

\paragraph{Interacting with the process.}
Emacs has historically referred to processes under its control as
inferior, accounting for the name inferior ESS (\stexttt{iESS}) to
denote the mode for interfacing with the statistical package.  The
output of the package goes directly to an editable text buffer in
Emacs.  This mode allows for command-line editing and saving history,
as well as recalling and searching for previously entered commands.
Filename completion is available.  In addition (currently only for for
S languages), there exists object-name and function-name completion.
Transcripts are easily recorded and can be edited into an ideal
activity log which can then be saved.  There is a good interface for
handling and intercepting calls to the internal help systems for S,
\XLispStat, and \Stata.

\paragraph{Interacting with statistical programs on remote computers.}
ESS provides the facility to edit and run programs on remote machines
in the same session and with the same simplicity as if they were
running on the local machine.  The remote machine could be a very
different platform than the local machine.

\paragraph{Transcription Editing and Reuse.}
Once a transcript log is generated, perhaps by saving an \file{iESS}
buffer, transcript-mode assists with reuse of part or all of the
entered commands.  It permits editing and re-evaluating the commands
directly from the saved transcript.  This is is useful for
demonstration of techniques as well as for reconstruction of data
analyses.  There currently exist functions within ESS for cleaning
transcripts from S languages back to source code by finding all input
lines and isolating them into an input file.

\paragraph{Help File Editing (R).}
ESS also provides an interface for writing help files for R functions
and packages.  It provides the ability to view and execute embedded R
source code directly from the help file in the same manner as ESS
normally handles code from a source file.  \stexttt{Rd} mode provides
syntax highlighting and the ability to submit code to a running ESS
process, either R or \Splus.

\subsection{Emacs}
\label{sec:ESS:emacs}

Emacs \citep{RMS:2000} is a mature, powerful, and easily extensible
text editing system which while traditionally used under Unix, is
freely available under the GNU General Public License for a large
number of platforms, including Unix, the Apple Macintosh platform, and
Microsoft Windows platforms.  Emacs shares some features with word
processors, and more importantly, shares many characteristics with
operating systems.  Most importantly, Emacs can interact with and
control other programs either as subprocesses or as cooperating
processes.

Emacs commands can be entered by keyboard or mouse.  The keyboard
interface is available on all platforms.  The mouse and menus are
available on all systems, including both windowed and non-windowed
environments, which support mice.  The mouse-based interface, through
menus and toolbars, also tries to facilitate the learning of
keystroke-based short-cuts.  Additional menus can be defined by the
user should they be needed.

%Emacs was one of the first tools available with a programmable
%extension language, Emacs Lisp, which is a dialect of Lisp
%\citep{RChassell1999,PGraham:1996}.  There are many examples of
%specialized extensions for assisting and facilitating common editing
%tasks.  Fundamentally important editing tasks such as programming
%Makefiles, scripts, and compiled code in many computer languages are
%well supported.  Many extensions for handling complex tasks have been
%developed, such as spreadsheets, interfaces for reading mail, news,
%and the World-Wide-Web (WWW), database front and back ends, forms
%entry, and interactive games such as tetris.  Emacs provides an
%internal help system and a tutorial.

Emacs provides facilities that go beyond simple insertion and
deletion: viewing two or more files at once; editing formatted text;
visual comparison of two similar files; and navigation in units of
characters, words, lines, sentences, paragraphs, and pages.  Emacs
knows the syntax of each programming language.  It can provide
automatic indentation of programs and highlight with fonts or colors
specified syntactic characteristics.  Emacs is extensible using a
dialect of Lisp \citep{RChassell1999,PGraham:1996}.  This means that
new functions, with user interaction, can be written for common and
repeated text-editing tasks.  Emacs provides full customization of the
keyboard and mouse.  The mouse-based interface, through menus and
toolbars facilitates the learning of keystroke-based short-cuts.
Additional user-defined menus can be constructed.

Most programming and documentation tasks fall under the realm of text
editing.  This work can be enhanced by common IDE features such as
contextual highlighting and recognition of special reserved words
appropriate to the programming language in use.  In addition, editor
behaviors such as folding, outlining, and bookmarks can assist with
maneuvering around a file.  Type-setting and word-processing, which
focus on the presentation of a document, are tasks that are not pure
text-editing.  Emacs shares many features with word-processing
programs and cooperates with document preparation systems such as
(\LaTeX; SGML, XML, and XSLT; and Noweb).

The capabilities can be extended in an orthogonal manner to include
other Emacs packages for assisting with documentation as noted above;
version control (RCS, CVS, SCCS, PRCS); and remote editing via FTP or
secure transport mechanisms such as ssh and scp.  Emacs handles the
interface to both source code and transcripts contextually, providing
syntax highlighting, bookmarking features, interfaces to directory
structure, and command-history.

%Emacs provides a sophisticated development environment for programming
%in traditional compiled languages such as C, C++, and Fortran as well
%as non-traditional byte-compiled and interpreted languages such as
%Perl, Java, and \XLispStat.  The development environment is built on
%Emacs's ability to communicate directly with other processes running
%simultaneously on the same or connected computers.  Emacs provides
%interfaces to system-building tools such as \file{make} and to
%debugging such as the external debuggers \file{JDebug}, \file{gdb},
%and \file{dbx}.  Finally, Emacs assists with project tasks such as
%documentation of changes, design, and version control.

Other extensions to Emacs allow it to act as a World-Wide-Web browser,
a highly sophisticated mail and news reader, a shell/terminal window
with history, and as an interface to other common text-based tools
such as spell checking programs.  The Emacs keyboard and mouse
interface can be re-mapped to resemble that of other text-editors,
such as ed, vi, wordstar, and brief.

The above reasons suggest that Emacs is a reasonable starting choice
for providing a universal interface for data analysis and programming.
ESS extends Emacs to provide a functional, easily extensible and
uniform interface for multiple statistical packages.

\section{History of ESS}
\label{sec:ESS:history}

ESS (originally S-mode) was initially designed for use with S and
\Splus\tm; hence, this family of statistical languages currently has
the most support.  We use S generically to denote any of the currently
available implementations in this of the family, including S 3.x, S
4.x, \Splus~3.x, \Splus~4.x (incl.\ \Splus~2000), \Splus~5.x,
\Splus~6.x and R.  In addition, we use Emacs to denote the GNU family
of editors which can be represented either by Emacs, as developed and
maintained by the Free Software Foundation, or XEmacs, which is a
derivative work.

ESS originated from the extension for programming and process
interface in Emacs supplied by S-mode (D. Bates, F. Ritter, et.al.; 
M. Meyer; D. Smith).  The extension to a language-independent generic
interface was prompted by the success of R, and the need for an
R-mode.  This led to a merger with the SAS-mode (T. Cook), and the
refactoring of the S-mode codebase to accommodate multiple languages
in a flexible way.
%  A detailed history can be found in section~\ref{sec:history}.

ESS is a remarkable example of how open-source products can continue
to develop beyond what their initial authors planned.  ESS started as
S-mode, an Emacs extension which was developed in 1991 as a simple
tool for editing program files for S and \Splus.  In 1994, Rossini
extended S-mode to support XEmacs, which is a forked version of Emacs.
At the same time, Rossini extended a successful SAS-mode written by
Tom Cook to work with XEmacs.  In 1995, S-mode was merged into a
uniform S-mode for Emacs, XEmacs, and supported S, \Splus, and R.
During 1996 and 1997, Richard M. Heiberger incorporated SAS-mode into
ESS and designed the inferior ESS mode for SAS.  At the same time
Rossini developed a generic means for configuring ESS to accommodate
changed as well as new statistical languages.

Most of the original work was done for Unix.  The first example of
interprocess communication for Windows using DDE was constructed in
1998 by Brian Ripley.  Based on this work, Richard M. Heiberger
provided interfaces for \Splus~4.x and then \Splus~2000 and
\Splus~6.x.

In 1998, Rodney Sparapani designed the SAS batch interaction
mode.  Sparapani and Heiberger developed SAS batch support including
function key behavior that followed SAS Institute's function key
definitions, developed a more comprehensive and efficient syntax
highlighting mechanism using the Emacs \stexttt{font-lock-mode},
extended the \stexttt{*ESS-elsewhere*} functionality to include SAS
processes, and provided automated error message lookup in the log
file.  This provides a strong development environment for SAS.

An earlier description of ESS appears in \citep{heiberger:dsc:2001}.
The present paper is intended as the primary non-technical description of ESS.
Details on the functions within ESS and examples of its use are included in
the online documentation that comes as part of the downloadable package.

\section{Using ESS with the S family of languages}
\label{sec:S}

ESS originated as S-mode and has historically provided strong support
for the S languages.  This section provides examples for editing
files, communicating with the interactive S process, editing
transcripts, and getting help.

\subsection{Editing Files}
\label{sec:S:edit}

\stexttt{ESS[S]} is the mode for editing S language files.  This mode
handles proper indenting of multi-line code and functions
(automatically when the code is entered and under user control while
editing); color and font highlighting based on syntax; the ability to
send the contents of an entire buffer, a highlighted region, an S
function, or a single line to an inferior S process; the ability to
switch between several inferior S processes (possibly on different
machines); the ability to request help from an S process for variables
and functions, and to have the help results sent into a separate
buffer; and completion of object names and file names.

\stexttt{ESS[S]} mode is automatically turned on for files with the
extensions \file{.R}, \file{.r}, \file{.S}, \file{.s}, \file{.ssc},
\file{.q}.  An inferior process must be running to take advantage of
the interactive features such as object- and file-name completion and
help.

\subsection{Inferior ESS processes}
\label{sec:S:inf}

\stexttt{iESS[S]} is the mode for interfacing with active S
statistical processes.  In effect, this mode replaces the \Splus\ or R
Commands window with an active buffer running inside Emacs.  This mode
provides an interactive history mechanism; transcript recording and
editing; the ability to resubmit the contents of a multi-line command
to the executing process with a single keystroke.  It also provides
the same editing features as the editing mode \stexttt{iESS[S]}.

The statistical processes S and R are started by using the Emacs
function call \stexttt{M-x~S} or \stexttt{M-x~R}.  This call opens up
a buffer and starts the S process inside that buffer.

\stexttt{iESS[S]} uses standard input/output to communicate with the S
program, except with the GUI interface for \Splus\ 4 and 6 for Windows
where standard input/output is not available.  ESS currently provides
two options on Windows.  ESS can use the DDE (Dynamic Data Exchange)
protocol to communicate with the GUI.  The editing features, including
the sending of commands to \Splus, are as described above.  The
printed output does not come back to an Emacs buffer, but instead
appears in the \Splus\ Commands Window.  Transcripts must be
physically copied to an Emacs buffer to get the transcript editing
features.  Full GUI capability is available by switching to the
\Splus\ window.  Or ESS can directly access Sqpe, the \Splus\ 
computing engine, using exactly the same procedures as are used for
Unix.  With this procedure interactive graphics and other GUI features
are not available.  In the near future, we anticipate merging these
approaches for \Splus\ 6 by using the \stexttt{connections} class of
the new S4 engine.  We will then have both interactive GUI and
transcript recording and editing on the Windows platform.

One useful extension in ESS is relaxation of the requirement that the
statistics program be available on the local machine.  ESS provides
transparent execution of a statistics package on a remote machine from
within the local Emacs.  The \stexttt{S+elsewhere} commands assist
with transparent execution of a statistics package on a remote
machine.  The idea of \stexttt{S+elsewhere} is that we open a telnet,
rlogin, or ssh connection to another machine from within a buffer
called \file{*S+elsewhere*}, and then run S on the other machine in
that buffer.  All the editing and interaction features described in
sections \ref{sec:S:edit} and \ref{sec:S:inf} for the local machine
work equally well on the remote machine.  The relevant commands get
sent through the buffer \file{*S+elsewhere*} to be executed by the
program on the other machine.  The interaction, including all the
unique features of working with ESS, appears to the user exactly the
same as if the program were running on the local machine.  With
X-windows running on the local machine, it is even possible to bring
up visual displays from remote Unix systems on a Windows local
machine.

\subsection{Editing and Reusing Transcripts}
\label{sec:S:trans}

ESS Transcript mode is designed for editing transcripts, constructed for
example by saving an \file{iESS} buffer.  This mode understands the form
of S transcripts; it does color and font highlighting based on syntax;
permits resubmitting multi-line commands to an active process buffer;
has the ability to request help from an S process for variables and
functions; and the ability to switch between processes which would be
the target of the resubmissions.  The S language transcripts can be
``cleaned'' by finding all input lines and isolating them into a
stand-alone input file that can be used as input to another S job or as
a model for further program design.

\subsection{Programming Language Help}
\label{sec:S:help}

When viewing help pages, there's a new menu \textsf{[ESS help]} and
useful 1-letter shortcuts for navigation and more, such as
\begin{list}{}{\renewcommand{\makelabel}[1]{\bf#1\hfill}}
 \item[n,\,p] move to \textbf{n}ext or \textbf{p}revious help section
 \item[{s \textit{x}}] move to help section code ``\textit{x}'' where
  \textit{x} is e.g. \stexttt{u} for ``Usage'', or \stexttt{e} for
  ``Examples''.  You can see a full list by entering \stexttt{s ?} from
  within an ESS Help buffer.
 \item[h] fast `hyperlink' to other help pages
 \item[l] (after `\stexttt{s e}') send examples \textbf{l}inewise to S
  for evaluation, also \stexttt{C-c C-r} for sending a whole region.
  This is particularly useful in R which guarantees that all examples
  are directly executable.
% (possibly after \stexttt{library(*)} for non-base packages).
\end{list}

\subsection{Philosophies for Combining S with ESS}
\label{sec:S:philosophy}

There are two primary philosophies for using ESS.  The first is that the
source code (the file \file{myfile.s}, for example) is real, and objects
in S are temporary realizations of the source.  This is the approach
preferred by the current group of developers and the default when ESS is
initially installed.  A project is constructed by writing S language
source code for \emph{every} user defined function or data object.  The
code is stored in one or more text files stored in a project directory
or directories.  The code is read into S for a temporary realization as
an object.  This approach allows for better portability, where the user
might want to use the written code and perform the same or related
analyses on different versions of the S language.  This approach also
permits external version control for S language source code.

The second, deprecated view, is that S objects are real.  The text
version of the objects (source code, although we can't use that term
with this philosophy) is a temporary realization of the objects.  ESS
is then used to edit, but not save, the objects.
%% (AJR sez) The next 2 lines were commented out.  I'm not sure why, I
%% kind of like them\ldots
Dumped buffers (a text representation of the underlying S object)
should not be saved in this philosophy.
%%
We strongly discourage this approach.  It is a natural result of
assuming that one will always use a single S process and that
transportability is not important, assumptions we are not willing to
make.  Details for activating this configuration are in the
documentation distributed with ESS.


\section{Using ESS with SAS}
\label{sec:SAS}

\stexttt{ESS[SAS]} mode is used for editing SAS files.  It is based on
the SAS mode by Cook
(\stexttt{ftp://ftp.biostat.wisc.edu/pub/cook/sas-mode/sas.tar.gz}).
ESS provides two user interfaces for executing SAS programs.  Both
have similarities to the windowing interface that SAS itself provides.
One is more similar in behavior to batch processing of SAS jobs and
the other to the ESS interface with S.  In addition, SAS files can be
edited in \stexttt{ESS[SAS]} mode in Emacs and then pasted into the
SAS Display Manager \ssf{Program Editor} window.  All three procedures
can be used with SAS running either locally or remotely.

\subsection{Editing SAS Files}
\label{sec:SAS:edit}

\stexttt{ESS[SAS]} is the mode for editing SAS language files.
\stexttt{ESS[SAS]} is automatically turned on when editing a file with
a \file{.sas} suffix.  \stexttt{ESS[SAS]} mode provides all the
flexibility of the Emacs editor for editing and searching in each file
and for simultaneously working with multiple SAS files.  For example,
while designing a SAS analysis a user may need to construct macro
files as well as specific files for one or more data sets.  The code
for the macros or the analysis can be compared to similar code
developed for other projects.

\stexttt{ESS[SAS]} mode handles: proper indenting, generated by both
\stexttt{[Tab]} and \stexttt{[Return]}; color and font choices based
on syntax; ability to send the contents of an entire buffer, a
highlighted region, or a single line to an inferior SAS process, if
one is currently running; ability to switch between processes which
would be the target of the buffer (for the above); ability to save and
submit a file as a batch SAS process with a single keypress; ability
to continue editing a file even while SAS is running it; the
capability of killing the batch SAS process through the shell buffer;
the capability of allowing the SAS process to keep on running after
you exit Emacs; single keypress navigation of \file{.sas}, \file{.log}
and \file{.lst} files (\file{.log} and \file{.lst} files are
automatically refreshed).

% At this writing (ESS release 5.2), the indenting and syntactic
% highlighting for SAS are usually correct.

\paragraph{Preconceptions and Configuration.}

People using ESS and SAS together come from two incompatible starting
positions.  Some are Emacs users who are adding SAS to their
repertoire.  They expect the keyboard to behave as it does in any
other Emacs mode and they expect a few new keys to interact with SAS.
Others are SAS users who have discovered the power of editing their
SAS source files with Emacs.  They expect the keyboard to behave as it
always has in their previous editor and they expect to gain some more
powerful editing and interaction capabilities by using Emacs.

The two places where the keyboard must be configured are the
\texttt{[TAB]} key and the function keys.  The batch processing
keypress commands use the same function keys that the SAS Display
Manager uses.

\paragraph{The \texttt{[TAB]} Key.}
\label{sec:SAS:tab}

There are two options for how ESS will interpret the \stexttt{[TAB]} key
with respect to SAS code.  The \stexttt{TAB} key is bound by default to
\stexttt{sas-indent-line}.  This function is used to syntactically
indent SAS code so `\stexttt{PROC}' and `\stexttt{RUN;}' are in the left
margin, other statements are indented 4 spaces from the margin,
continuation lines are indented 4 spaces in from the beginning column of
that statement.  This is the type of functionality that Emacs provides
in most programming language modes.  This functionality is equivalent to
uncommenting the following line in \file{ess-site.el}: \elcode{;;; (setq
  ess-sas-edit-keys-toggle 0)}

ESS provides an alternate behavior for the \stexttt{TAB} key that
makes it behave as it does on non-Emacs terminals, i.e. move the
cursor to the next tab stop.  The alternate behavior also provides a
backwards \stexttt{TAB} key: \stexttt{C-TAB}.  With this option the
user is responsible for the indentation of the code.  The alternate
behavior is obtained by uncommenting the following line in
\file{ess-site.el}: \elcode{;;; (setq ess-sas-edit-keys-toggle 1)}
Under the alternate behavior, the \stexttt{TAB} key is bound to
\stexttt{tab-to-tab-stop} and the tab stops are set by default at
multiples of 4.

\paragraph{Function Keys.}
Emacs users will often have customized the function keys for various
editing tasks and expect the keys to continue to behave in their
customized way.  For example, Heiberger uses the function keys to
cycle among the currently open editing buffers.  SAS users who are
familiar with the SAS Display Manager would like to use the function
keys that SAS provides.  SAS provides different function key
assignments on Windows and Unix platforms.  ESS therefore provides all
possible options: no special function keys in SAS mode, Unix-style SAS
function keys (either in all buffers or restricted to SAS buffers),
Windows-style SAS function keys (either in all buffers or restricted
to SAS buffers).  More detail on the function keys is in section
\ref{sec:SAS:proc:batch}


\subsection{SAS process interaction}
\label{sec:SAS:proc}

There are three methods for interacting with SAS.  We describe batch
processing from ESS, running SAS in an inferior ESS buffer, running
SAS with the Display Manager, and running SAS on a remote machine from
a local Emacs.

The ESS methods for interacting with SAS are based on the SAS Display
Manager's procedures.  Why therefore use ESS rather than the Display
Manager?  For two reasons: we prefer Emacs editing of source, and we
want immediate access through the Emacs search and edit commands to
the output in the listing file.
 

The interactive capabilities of ESS require you to start an inferior
SAS process with \stexttt{M-x SAS} (described below).  Batch SAS usage
starts a separate instance of SAS each time a file is submitted.

\subsubsection{SAS Batch processing}
\label{sec:SAS:proc:batch}

The user (or the site manager) must select either Unix style or
Windows style function key definitions for use in the
\stexttt{ESS[SAS]} modes.
%%   The actions available in the
%% \stexttt{ESS[SAS]} modes, and the default function keys that initiate
%% those actions are:\\
%% \begin{tabular}{llll}
%% Unix& PC&\\
%% \stexttt{F2} &\stexttt{F2}& Refresh &revert the buffer with the file if the file on disk is newer\\
%% \stexttt{}   &\stexttt{}  &         &       than the file currently in the buffer.\\
%% \stexttt{F3} &\stexttt{F8}& Submit  &save   the current \file{.sas} buffer (which may be the \file{.sas}\\
%% \stexttt{}   &\stexttt{}  &         &       file associated with the \file{.lst} or \file{.log} file you\\
%% \stexttt{}   &\stexttt{}  &         &       are actually looking at) to a file and submit\\
%% \stexttt{}   &\stexttt{}  &         &       the file to a background SAS job.\\
%% \stexttt{F4} &\stexttt{F5}& Program &switch buffer to \file{.sas} file.\\
%% \stexttt{F5} &\stexttt{F6}& Log     &switch buffer to \file{.log} file, ``refresh" and \\
%% \stexttt{}   &\stexttt{}  &         &        goto next error message, if any.\\
%% \stexttt{F6} &\stexttt{F7}& Listing &switch buffer to \file{.lst} file and ``refresh".\\
%% \stexttt{F7} &\stexttt{F4}& Type-1  &switch buffer to \stexttt{Type-1} (defaults to \file{.txt}) file and ``refresh".\\
%% \stexttt{F8} &\stexttt{F3}& Shell   &switch buffer to shell.\\
%% \end{tabular}
%%
Keys \stexttt{[f3]}--\stexttt{[f8]} mimic SAS Display Manager keys.  One
other key has been provided for convenience.  \stexttt{F2} performs the
``refresh'' operation on the current buffer.  ``refresh'' compares the
buffer date stamp with the file date stamp and replaces the buffer with
the file if the file is newer.  This is the same operation that is
automatically performed when Log, Listing, or \stexttt{Type-1} are
pressed.  \stexttt{Type-1} takes you to a file with a user-specified
extension; \file{.txt} by default.  \stexttt{Type-1} files are not a
standard from the SAS Institute, but are included here because many
companies have developed internal standards that use them.  You can
over-ride the default, by specifying a different extension in your
\file{.emacs} file: \elcode{(setq ess-sas-suffix-1 '.txt')}

\paragraph{SAS Interface.}
\label{sec:SAS:interface}

The default command used by the Submit function key
(\stexttt{F3} or \stexttt{F8}) to
submit a batch SAS job is simply \stexttt{sas}.  If necessary, you can
over-ride this in your \file{.emacs} file.
The default assumption is that SAS is run on the local machine.  This too
can be overridden by changing \stexttt{ess-sas-submit-method} to point to
SAS on a remote machine.
% something like one of the following:
% \begin{Salltt}
%    ;;; (setq ess-sas-submit-command "nohup nice sas") ;; Unix
%    ;;; (setq ess-sas-submit-command "c:/progra~1/sas/sas.exe") ;; Windows
%    ;;; (setq ess-sas-submit-command "invoke SAS using program file") ;; Mac
% \end{Salltt}
% Note that when you are specifying a path under Windows, you should
% avoid spaces (that is use {\stexttt{"progra~1"}}, not \stexttt{"Program Files"}) and you
% should use forward slashes \stexttt{"/"}.  There may be occasions when you want
% to run a particular buffer under a different version of SAS or specify
% different options on the command line.  In that case, you can
% over-ride \stexttt{ess-sas-submit-command} in your local buffer with file
% variables or other means.

% There is a built-in delay before a batch SAS job is submitted when using
% a Unix shell under either Unix or Windows.  This is necessary in many cases 
% since the shell might not be ready to receive a command.  This delay is 
% currently set high enough so as not to be a problem on any system.  But,
% there may be cases when it needs to be set higher, or could be set much
% lower to speed things up.  You can over-ride the default in your \stexttt{.emacs}
% file by (the default of 5 seconds is shown):
% \elcode{(setq ess-sleep-for 5)}


% \subsection{Using Transcripts}
% \label{sec:SAS:trans}
% 
% Not yet available.  The intent is that a marked section of a log file
% from a previous SAS run can be resubmitted to SAS.  The user would
% highlight a region from 'PROC' to 'RUN;' and then send it to the
% inferior SAS process with the [RET] key.  ESS would automatically
% clean the region (remove line numbers) and send the entire region over
% as a single request to SAS.
% 

\subsubsection{Inferior SAS processes}
\label{sec:SAS:proc:inf}

\stexttt{iESS} (inferior ESS) is the mode for interfacing with active
statistical processes (programs).  To start up \stexttt{iESS[SAS]} mode,
use: \elcode{M-x SAS}
% We plan to add the ability to request help from a process for
% variables and functions, and to have the results sent into a separate
% buffer, as well as the completion of object names and file names.
A single instance of SAS is started in an \file{iESS[SAS]} buffer.
Individual \stexttt{DATA} and \stexttt{PROC} steps are sent to this
instance of SAS and the results are appended to the \file{*log*} and
\file{*lst*} buffers.

The \stexttt{iESS[SAS]} mode was written with two primary goals.
\begin{itemize}
 \item Using Emacs, a window environment becomes available for dial-up
  users who do not have access to the SAS window environment.
 \item The authors prefer the Emacs environment for editing and managing
  input and output files, even on computer systems which run the SAS
  window environment.
\end{itemize}
A secondary goal was also realized.  With an X-windows terminal
connected by ppp at (the now slow speed of) 14400 baud to a Unix system
running SAS, \stexttt{iESS[SAS]} interaction with SAS was hundreds of
times faster than the SAS window system.  The savings come because the
ESS windows are subunits of a text-based xterm window, rather than the
remotely managed graphical windows provided by SAS.  (The timings are
SAS timings from the log files.  The SAS windows times include window
management and communications times as well as calculation times.  The
\stexttt{iESS} times include only the calculations by the SAS computing
engine.)

\subsubsection{ESS and Display Manager}
It is possible to use ESS for editing SAS files with \stexttt{ESS[SAS]} mode
and then pick up the file or a region and drop it directly into the SAS
Display Manager \ssf{Program Editor} window.
%% This method gives the user access to
%% interactive SAS graphics.  With any of the other Emacs interactions, the user
%% is limited to static graphics, for example by printing to a postscript device.

\subsubsection{SAS elsewhere}

\paragraph{Batch Processing.}
Batch Processing works when Emacs is running on a local machine and SAS
is running on a remote machine.  The local machine must be directly
connected to the network (possibly by ppp).  Set the
\stexttt{ess-sas-submit-method} with \elcode{(setq-default
  ess-sas-submit-method 'iESS)} and behave exactly as if the SAS process
were local.  Use the local Emacs to edit the remote file
\file{/other.machine:myfile.sas}.  When it is submitted, it will
automatically be saved back to the remote machine and be exactly where
the remote SAS will find it.

\paragraph{\stexttt{iESS} Processing on remote Emacs.}
Telnet to a remote computer using a telnet client other than an Emacs buffer.
Run an Emacs on the remote machine in the telnet window.
Run \stexttt{M-x SAS} on the remote machine in that remote instance of Emacs.

\paragraph{\stexttt{iESS} Processing on local Emacs.}
In principle, this can be done, but none of us has found the need
compelling.  Essentially what is needed is for three independent shell
processes to be connected to the remote machine.  The SAS process on
the remote machine runs in one of the shell windows, and redirects its
log output and its lst output to the other two.

\subsection{Design of \texttt{ESS[SAS]} mode}
\label{sec:SAS:phil}

\stexttt{ESS[SAS]} mode was designed to aid the user in writing and maintaining
input command files, such as \file{myfile.sas}, for SAS.  These are files
containing SAS statements.  In a batch environment such files would be
submitted to SAS by the operating system command:
\elcode{sas myfile.sas}
In a SAS window environment, these files would be brought into the
\ssf{SAS: PROGRAM EDITOR} window and then submitted with the
\ssf{Local/Submit}
menu commands.

The \file{*SAS:1.log*} or \file{myfile.log} buffer in \stexttt{ESStr}
mode corresponds to the file \file{myfile.log} in SAS batch usage and to
the \ssf{SAS: LOG} window in the SAS window environment.  All commands
submitted to SAS, informative messages, warnings, and errors appear
here.

The \file{*SAS:1.lst*} or \file{myfile.lst} buffer in \stexttt{ESSlst}
mode corresponds to the file \file{myfile.lst} in SAS batch usage and to
the \ssf{SAS: OUTPUT} window in the SAS window environment.  All
data-related printed output from the \stexttt{PROC}s appear in this
window.

The interactive \stexttt{iESS [SAS:1]} buffer exists solely as a
communications buffer.  Files are edited in the \file{myfile.sas}
buffer.  The \stexttt{C-c C-r} key in \stexttt{ESS[SAS]} mode is the
functional equivalent of bringing a file into the \ssf{SAS: PROGRAM
  EDITOR} window followed by the \ssf{Local/Submit} menu commands.  The
user should never use this buffer directly.


\section{Remarks and Extensions}
\label{sec:remarks}

There are two active areas of extensions for user environments.  One
is to enhance the capabilities of the IDE for statistical practice;
this includes implementing such common IDE features as object
browsers, tool-tips, and interfacing cleaning.  The other is to
target appropriate potentially useful programming methodologies for
transfer to statistical practice.

Literate Programming methodologies \citep{Knuth:1992,NRamsey:1994}.
We refer to the application to statistical analysis as Literate
Statistical Practice \citep{rossini:dsc:2001}.  The tools used are
Noweb \citep{NRamsey:1994} and the use of an XML authoring environment
for statistical analysis.

IDE extensions which are important to construct include class
browsers, analysis templates, tool-tips, and similar tools for
effective working.  Class browsers can be thought of as a tree or
outline for presenting variables and functions, allowing for rapid and
appropriate inspection.   Analysis templates would allow groups to
provide standardized templates for initiating an analysis.

Combinations of the above include report construction and generation,
using literate programming techniques.  This could be a useful
approach for solving data management auditing.

%\textbf{RODNEY:} Are you telling the reader where ESS is going?  If
%so, this is news to me.  I'm guessing that ESS is going to add BUGS
%(that's my plan) and will have better support for all of the packages
%you mentioned: S et.~al., SAS, \Stata, \XLispStat, etc.  If I am
%confused, then many readers will be to.

\singlespace

\bibliographystyle{plainnat} %alpha}
\bibliography{ess}

\appendix
\section{Obtaining ESS}
\label{sec:getIt}

ESS \citep{ESS} is primarily located at \stexttt{ess.stat.wisc.edu}, and is
available by FTP or through the World-Wide-Web (WWW).  A basic
installation consists of downloading the package, unpacking, and then
adding a line to the Emacs initialization file (\file{.emacs} or
\file{\US emacs}), pointing to the lisp subdirectory of the unpacked
archive.  Unix users, but not Windows users, may choose to do an
optional installation by executing the Makefile that comes with the
ESS package.

There exist binary packages for various Linux distributions, as well,
including Debian, RedHat, Mandrake, and SuSE.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ess"
%%% End: 

